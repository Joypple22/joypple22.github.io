<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Syeon</title>
    <description>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 24 Oct 2021 00:09:42 +0900</pubDate>
    <lastBuildDate>Sun, 24 Oct 2021 00:09:42 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>[DOM] DOM(document object model)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;여러 DOM에 대한 포스팅을 읽고 난 뒤 나름대로 정리한 포스팅입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-dom-이란&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-event&quot;&gt;Event&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-참고-자료&quot;&gt;참고 자료&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-dom이란&quot;&gt;📌 DOM이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DOM은 document object model의 약자로 JavaScript를 통해 HTML를 컨트롤하기 위해 도입되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;브라우저가 렌더링되는 과정
&amp;lt;img src=/assets/img/c_s/dom-tree.png alt=”img” width=’700px’ /&amp;gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;각각 HTML과 CSSOM으로부터 HTML과 CSS를 파서한 후 트리를 만든다.&lt;/li&gt;
    &lt;li&gt;HTML트리와 스타일 규칙은 어테치먼트 과정에서 하나로 합쳐진다.&lt;/li&gt;
    &lt;li&gt;이렇게 만들어진 랜더 트리를 통해 그려지고 브라우저에 표시된다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림은 브라우저가 서버로부터 사용자가 요청한 페이지를 화면 상에 그리는 순서를 요약한 것이다.&lt;/li&gt;
  &lt;li&gt;순서에 따르면 HTML을 파서한 이후 DOM이 개입하여 DOM트리를 구성한다.&lt;/li&gt;
  &lt;li&gt;DOM은 HTML에 영향을 끼치지만 CSS에는 일반적으로 관여하지 않기 때문에 CSS 가상 선택자 같은 요소에 영향을 주지 못한다.&lt;/li&gt;
  &lt;li&gt;이렇듯 DOM과 HTML은 서로 다를 수 있으며 HTML은 단순하게 화면에 보이고자 하는 모양과 구조를, DOM은 HTML을 객체화하여 유효하지 않은 HTML을 수정하기도 하고 직접 HTML에 간섭하여 조작할 수 있다.&lt;/li&gt;
  &lt;li&gt;또한, 브라우저와 콘솔 element 텝에서 보이지 않는 테그들은(display: none같은…) DOM에는 하나의 노드로 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-event&quot;&gt;📌 Event&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DOM를 통해 HTML에 접근할 수 있게 되면서 HTML에 특정 이벤트를 원하는 HTML요소에 적용할 수 있게 되었다.&lt;/li&gt;
  &lt;li&gt;querySelector, getElementById, getElementsByTagName, getElementsByClassName 등을 활용하여 특정 HTML 요소에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;접근한 요소에 addEventListener를 사용하여 특정 이벤트를 적용시킬 수 있다. (이벤트 종류: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/Events&quot;&gt;MDN-event&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;각 createElement, classList(add, remove, toggle), setAttribute 등 HTML 요소를 컨트롤 할 수 있는 다양한 메소드들이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Naver D2와 여러 포스팅을 읽고 나름대로 중요하다고 생각하는 것들을 요약해보았다.&lt;/li&gt;
  &lt;li&gt;특히 Naver 포스트는 많이 어렵다고 느껴 반복적으로 읽고 학습하는 것이 중요해보였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-참고-자료&quot;&gt;🎈 참고 자료&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;Naver D2 - 브라우저는 어떻게 동작할까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@surim014/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot;&gt;DOM이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@surim014/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot;&gt;HTML, DOM 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/dom.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/dom.html</guid>
        
        <category>computer_science</category>
        
        <category>DOM</category>
        
        <category>event</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] 문자 숫자열과 영단어</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;카카오 코딩 테스트 문제 ‘문자 숫자열과 영단어’입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.
다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.&lt;/p&gt;

  &lt;p&gt;1478 → “one4seveneight”
10203 → “1zerotwozero3”
234567 → “23four5six7”&lt;/p&gt;

  &lt;p&gt;이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution(s) {
    let answer = s;
    let numObj = {
        zero: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6,
        seven: 7,
        eight: 8,
        nine: 9,
    };

    function DFS() {
        for(let i in numObj) {
            let answer2 = answer;
            answer2 = answer2.replace(i, numObj[i]);

            if(answer2 !== answer) {
                answer = answer2;
                DFS();
            }
        }
    }

    DFS();

    return parseInt(answer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replaceAll&lt;/code&gt;을 사용하여 문제를 풀 마음이었지만 프로그래머스는 replaceAll을 지원하지 않는다고…ㅠ&lt;/li&gt;
  &lt;li&gt;어떻게 할까 고민하다가 replace를 상황에 따라 계속 해주면 되는거 아닌가? 싶은 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;상황이라함은 중복되는 숫자가 한 문자열에 존재할 경우였다.&lt;/li&gt;
  &lt;li&gt;기존 수를 변수로 할당하고 replace하여 기존 값과 replace하여 변하는 값이 있다면 다시 검사하는 방식으로 로직을 구현했다.&lt;/li&gt;
  &lt;li&gt;어떤 방법으로 다시 검사할까 고민하다가 최근에 배운 DFS (재귀함수)를 사용하여 구현해보았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이렇게 하니 모든 테스트케이스에는 통과했지만, 속도는 한 테스트케이스당 0.2s ~ 0.3s정도 나오는 것 같았다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-다른-풀이&quot;&gt;📌 다른 풀이&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution(s) {
  let num = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];

  let answer = s;

  for(let i = 0; i &amp;lt; num.length; i++) {
    let arr = answer.split(num[i]);
    answer = arr.join(i);
  }

  return parseInt(answer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이 중에서 제일 좋아요? 수를 많이 받는 코드이다.&lt;/li&gt;
  &lt;li&gt;잘 살펴보면 num 배열을 for문으로 돌리는 것까지는 내 코드와 비슷하지만, 필자는 DFS를 사용함으로서 이중 삼중으로 반복 로직을 실행시켰다.&lt;/li&gt;
  &lt;li&gt;하지만 이 로직에서는 for하나로 split를 사용함으로서 전체 string을 for가 돌때마다 한번씩만 호출하면 된다.&lt;/li&gt;
  &lt;li&gt;역시나 테스트 코드는 모두 통과임과 함께 속도도 하나의 테스트 코드당 0.06s ~ 0.07s가 걸린다.&lt;/li&gt;
  &lt;li&gt;시간복잡도 측면에서 훨씬 좋은 코드인 것이다..!!ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;역시나 알고리즘은 재밌다!!!&lt;/li&gt;
  &lt;li&gt;여러가지 알고리즘 자료구조를 활용해 최적의 코드를 구현하는 방법! 더 연구하고 많이 사용해보아야겠다.&lt;/li&gt;
  &lt;li&gt;하지만 나도 과거에 쩔쩔매던 재귀함수를 활용해서 스스로 코드를 구현한 것에 보람을 느낀다 :)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm.html</guid>
        
        <category>algorithm</category>
        
        <category>재귀함수</category>
        
        <category>split</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Refactorying2] Chapter 6-1 함수 추출하기</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;chapter 6-1 함수 추출하기에 대한 생각 정리🤔&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-함수-추출하기&quot;&gt;함수 추출하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-예시-및-생각-정리&quot;&gt;예시 및 생각 정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-함수-추출하기&quot;&gt;📌 함수 추출하기??&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수 추출하기는 하나의 코드를 여러 조각으로 나누는 작업이다.&lt;/li&gt;
  &lt;li&gt;각각 독립적인 함수로 만들기 위해서는 함수의 목적을 파악하고 분리하기!!(목적이 명확하다면 변수명 짓는 것도 보다 수월해질 것🤩)&lt;/li&gt;
  &lt;li&gt;사람마다, 팀마다 목적에 맞게 나누는 정도는 다 다르지만..(저자는 reverse메소드 하나 사용하기 위해 함수를 만든 적도 있다고..), 상황에 맞는 유연함을 보여야할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-예시-및-생각-정리&quot;&gt;📌 예시 및 생각 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = {name: 'syeon', goToWork: [true, true, true, true]};

function goWorkRecording(person) {
  let counting = 0;

  console.log('In the morning');

  for(let working of person.goToWork) {
    if(working) {
      counting += 1;
    }
  };

  const today = new Date();
  person.date = `${today.getFullYear()}/${today.getMonth()}/${today.getDate()}`;

  console.log(`이름 : ${person.name}`);
  console.log(`오늘 날짜 : ${person.date}`);
  console.log(`출근 횟수 : ${counting}`);
}

goWorkRecording(person);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서적에 소개된 예시와 비슷한 함수를 만들어보았다.(이제 직장인이어서 출근으로 비유한 새내기 개발지🌱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수 추출하기 에서는 이정도로???라고 할 정도로 함수를 나누며 설명한다.&lt;/li&gt;
  &lt;li&gt;핵심은 매개 변수, 지역 변수 등의 배치를 최대한 쉽고 간결하게..이게 무슨 일을 하는 함수인지 바로 알 수 있도록 구현하는 것이라고 생각했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = {name : 'syeon', goToWork: [true, true, true, true]};

function goWorkRecording(person) {
  alertMorning();

  const counting = countWorking(person);

  getToday();

  showRecords(person, counting);

  function alertMorning() {
    console.log('In the Morning');
  };

  function countWorking(person) {
    let result = 0;

    for(let working of person.goToWork) {
      if(working) result += 1;
    }
    return result;

  };

  function getToday() {
    let today = new Date();
    return `${today.getFullYear()}/${today.getMonth()}/${today.getDate()}`;
  }

  function showRecords(person, counting) {
    console.log(`이름 : ${person.name}`);
    console.log(`오늘 날짜 : ${person.date}`);
    console.log(`출근 횟수 : ${counting}`);
  }
}
goWorkRecording(person);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코드가 생각보다 많이 길어졌다.&lt;/li&gt;
  &lt;li&gt;하지만 이 goWorkRecording이라는 함수가 무엇을 하려는지는 좀더 명확하게 보인다.&lt;/li&gt;
  &lt;li&gt;책에서는 나오지 않았지만, 본인은 중복 함수인 함수 선언문들을 제일 아래로 내려 놓은게 인사이트였다.&lt;/li&gt;
  &lt;li&gt;별거 아닌것처럼 보여도 무심결 함수 선언하고 함수 호출하고의 생각이 당연한 것처럼 여겼는데 이렇게보니 더 깔끔하다는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;alertMorning함수는 goWorkRecording에서 참조하는 지역변수가 없으므로 바깥으로 빼서 재사용성을 높일 수도 있다.&lt;/li&gt;
  &lt;li&gt;countWorking함수도 본래 goWorkRecording의 지역변수였던 counting을 함수 내부로 넣고 결과 값을 result으로 뺀 점, 그리고 그 결과값 result는 결국 couting 변수에 할당되어 다른 함수에서 사용할 수 있게 만든 것…이런 것이 바로 코드를 섬세하게 다룬다 라고 하는 것임을 알았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 생각보다 기초적이지만 처음에 등장한만큼 중요한 기법이라고 생각된다. 리팩터링을 다시 한번 생각해보게 되었고, 앞으로도 기대가 된다 😊&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/chaper6-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/book/chaper6-1.html</guid>
        
        <category>refactorying2</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>[Refactorying2] Chapter 3 &amp; 4 : 전반적인 코드 개선 방법</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Refactorying2 chapter 3과 4를 읽고..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-chapter-3--chapter-4&quot;&gt;📌 Chapter 3 &amp;amp; Chapter 4&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;3단원과 4단원은 어떤 코드를 점검하고 리팩토링을 고려해야하는지, 리팩토링과 테스트 코드는 구체적으로 어떤 연관을 가지는 것인지에 대해서 이야기한다. 3단원에서 소개하는 점검해야하는 리팩터링 요소들은 생각보다 엄청 많았다. 변수 이름 정하기부터 시작하여, 반복문 클래스를 어떻게 해는 것이 좋다! 라고 소개하지만… 신입인 나는 아직 경험해보지 못했던 상황들이 많이 있었다..ㅠㅠ 테스트 코드 또한 마찬가지였다..(jest를 빨리 익혀야겠다..!!)&lt;/p&gt;

&lt;p&gt;3단원을 통해서 고려해야할 코드들은 생각보다 많고, 이것들은 모두 코드를 명확하게 만들어주는 도구라고 생각하니 빨리 익히고 싶은 마음이 들었지만..! 급히 먹는 밥이 체한다고..🍚 천천히 잘 씹어 먹어야겠다😊&lt;/p&gt;

&lt;p&gt;4단원에서도 테스트 코드를 한차례 더 강조했는데 역시나 모든 코드에 테스트를 할 수 있다면 좋겠지만 우리의 몸과 마음은 유한하니.. 중심이 되는 코드들을 중점으로 테스트를 하는 것을 권장한다. 어디선가 ‘프론트엔드는 브라우저 상으로 잘 출력이 되는지 확인할 수 있으니까 굳이 안만들어도 되지 않나?’라는 이야기를 들은 적이 있었다. 그 때는 ‘어 그런가?’라고 생각했지만, 곧 이 생각은 바뀌게 되었다. 확실히 테스트 코드는 처음에 시간이 조금 걸릴 수는 있지만, 지속적인 테스트나 디버깅에 있어서 테스트 코드가 없는 것보다 월등한 속도를 보여준다고 주변에서 먼저 경험한 동기들에게 전해들었다! 즉 누구에게나 테스트 코드는 필요하다!&lt;/p&gt;

&lt;p&gt;더 나은 코드를 구현하기 위해 앞으로도 홧팅하며 달린다 🏃🏻&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/chapter3-4.html</link>
        <guid isPermaLink="true">http://localhost:4000/book/chapter3-4.html</guid>
        
        <category>refactorying2</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>[Refactorying2] Chapter 2 : 리팩터링 원칙</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;chapter 2 리펙터링 원칙을 읽고…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;[목차]
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-chapter-2-리팩터링-원칙을-읽으며&quot;&gt;Chapter 2 리팩터링 원칙을 읽으며..&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-chapter-2-리팩터링-원칙을-읽으며&quot;&gt;📌 Chapter 2 리팩터링 원칙을 읽으며..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이번 주제 또한 실질적인 기법을 알려주기 전에 리펙터링의 필요성과 효율 등을 이야기해주는 단원이었다.&lt;/p&gt;

&lt;p&gt;궁극적으로 리팩터링은 심미적으로 코드를 아름답게하기 위해, 좋아보이기 위해 진행하는 것이 아니다. 리팩터링을 통해 개발 속도를 높이고, 더 적은 노력으로 많은 가치를 창출하는 것에 있다.&lt;/p&gt;

&lt;p&gt;분명 리팩터링에는 여러가지 이점들이 존재한다. 소프트웨어를 이해하기 쉬워지고, 디버깅을 쉽게 할 수 있는 등 그밖에 여러가지 이점들을 가지고 있지만, 저자는 무턱대고 리팩터링을 하는 것을 권장하지 않는다고 말한다.&lt;/p&gt;

&lt;p&gt;리팩터링의 시기에 대한 명쾌한 해답은 없다. 누군가에게는 기능 추가와 동시에 하는 것이 베스트이고, 누군가에게는 팀원들과 코드리뷰를 하면서, 누군가는 날잡고 몇일동안.. 사실 특정 누군가에게 해당 방안들이 적용되는 것이 아니라 상황에 따라 취해야할 행동이 다르다고 생각된다. 하지만 이러한 행동을 취하기 위해서는 많은 경험과 고민들을 거쳐야만 할 것이다.&lt;/p&gt;

&lt;p&gt;본인은 기능을 구현함과 동시에 리팩터링을 진행하는 편이다. 비록 신입 개발자이지만.. 더 개선할 수 있을 것 같은데? 라는 마음으로 계속 고민하는 편이다. 하지만 기한이 빡빡한 새로운 프로젝트에 돌입한다면 기능을 우선적으로 구현해야지..라는 생각을 가지고 있다.&lt;/p&gt;

&lt;p&gt;책에서는 여러가지 리팩토링 시 고려해야할 점들, 리팩토링의 시기들을 이야기하지만 본인이 느꼈을 때 결론은 이것인 것 같다.
“코드의 지구력 설계를 위해서는 리팩토링이 필요하다. 리팩토링을 진행할 때 코드 테스트를 병행하고, 팀이라면 CI(지속적 통합) 방식으로 컨플릭같은 에러를 최소화하는 것이 좋다. 하지만 리팩터링 해야할 요소는 마땅한 리팩터링을 해야하는 근거가 필요하다. 기존보다 성능이 덜 좋거나, 래거시 코드 등 다양한 리팩터링 대상을 놓고, 기존 서비스를 잘 유지하는 차원에서 진행하는 것이 리팩토링의 원칙이다.”&lt;/p&gt;

&lt;p&gt;위의 내용이 맞는지 틀린지 사실 잘 모르겠지만 이제 다음 단원부터 시작되는 실질적인 리팩터링 기법들을 읽고 난 뒤 다시 단원 1장과 2장을 정독해보아야겠다. :)&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/chapter2.html</link>
        <guid isPermaLink="true">http://localhost:4000/book/chapter2.html</guid>
        
        <category>refactorying2</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>[Algorithm] 이진 트리 순회(DFS: 깊이 우선 탐색)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;재귀 함수를 응용한 이진트리순회(DFS 깊이 우선 탐색) 알고리즘!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-이진-트리-순회란&quot;&gt;📌 이진 트리 순회란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;2갈래 나무 형태로 되어 있는 자료구조이다.&lt;/li&gt;
  &lt;li&gt;부모 노드 root에는 left right 방향으로 총 2개의 자식 노드를 가진다.&lt;/li&gt;
  &lt;li&gt;이 노드들을 차례대로 순환하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/DFS.png&quot; width=&quot;500px&quot; height=&quot;200px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;저렇게 부모 노드가 있고 자식 노드가 있으며 각 노드에 넘버링이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 노드들마다 접근하는 순서 및 방식에 따라 여러가지 개념들이 생기는데 &lt;b&gt;전위 순회&lt;/b&gt;, &lt;b&gt;중위 순회&lt;/b&gt;, &lt;b&gt;후위 순회&lt;/b&gt;가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;전위 순회는 1-2-4-5-3-6-7 이런 순으로 노드에 접근하며 순회한다.&lt;/li&gt;
  &lt;li&gt;중위 순회는 4-2-5-6-3-7-1 순으로 제일 왼쪽 끝 노드에 접근하고 중간 노드에 접근한 이후 다시 오른쪽 노드로 뻗어가는 방식으로 되어있다.&lt;/li&gt;
  &lt;li&gt;후위 순회는 4-5-2-6-7-3-1 순으로 제일 왼쪽 끝에서 오른쪽 끝 노드 순으로 접근하며 순회하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 이러한 노드를 재귀를 사용하여 구현한다고해서 연결리스트로 해야되나 어떻게 트리 구조를 만들지?라고 생각했었는데… 재귀를 한 함수에서 2번 호출하는 방법은 생각하지도 못했다…!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function DFS(n) {
  if(n &amp;gt; 7) return
  else {
    console.log(n);
    DFS(n * 2);
    DFS(n * 2 + 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-… 생각보다 너무 간단하다. 로직을 보는 순간 아 그렇게 되는구나 대박!! 이랬다👽&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS의 매개변수인 n _ 2와 n _ 2 + 1이 의아할 수 있는데 부모와 자식노드를 잘 보면 무조건 자식노드의 왼쪽은 부모노드의 _ 2, 오른쪽은 _ 2 + 1이라는 사실..&lt;/li&gt;
  &lt;li&gt;이것과 실행컨텍스트, 콜스텍의 개념으로 생각해보면 n _ 2를 매개변수로 가지고 있는 DFS함수는 그 안에서 또 DFS가 실행될텐데 그럼 또 그 안의 DFS함수 중 n _ 2를 매개변수로 가지고 있는 함수가 먼저 실행되는 것이 반복된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;계속 반복되다가 n &amp;gt; 7의 조건으로 종료되면 n * 2 + 1함수가 실행이 되어 아까와의 상황이 반복될 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;짚고 넘어가야될 부분은 console.log의 위치이다.&lt;/li&gt;
  &lt;li&gt;지금은 재귀 함수중 제일 위에 있기 때문에 함수를 깊게 들거가기 전 n값을 콘솔에 보여준다. 한차례 들어간 함수에서도 마찬가지..&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저 console.log가 DFS(n _ 2)와 DFS(n _ 2 ≠ 1)사이에 들어가게 되면 중위 순환이 되는 것이다. 제일 마지막에 있으면 후위 순환!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇듯 재귀함수의 호출과 종료를 이용한 DFS 이진트리 순환에 대해 알아보았다.(재밋당)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 14 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm.html</guid>
        
        <category>algorithm</category>
        
        <category>깊이우선탐색</category>
        
        <category>이진트리순회</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Refactorying2] Chapter 1 : 리팩터링 예시</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;chapter 1 리펙터링 : 첫번째 예시를 읽고..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-refactorying-2-시작&quot;&gt;Refactorying 2 시작!&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-chapter-1-리펙터링-첫번째-예시를-읽으면서&quot;&gt;Chapter 1: 리펙터링 첫번째 예시를 읽으면서..&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-테스트-코드를-작성하라&quot;&gt;테스트 코드를 작성하라!&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-프로그램에-새로운-기능을-추가하기-쉬운-형태로-리팩터링하자&quot;&gt;프로그램에 새로운 기능을 추가하기 쉬운 형태로 리팩터링하자!&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-사람이-이해하도록-작성하는-코드--수정을-간편하게-할-수-있게-고려한-코드&quot;&gt;사람이 이해하도록 작성하는 코드 &amp;amp; 수정을 간편하게 할 수 있게 고려한 코드&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며..&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-refactorying-2-시작&quot;&gt;📌 Refactorying 2 시작!&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;지금까지 리펙터링이라 생각했던 것은 전체적인 코드 컨벤션을 지키고 코드를 가독성있게 짜는 것이라고 생각했다. 하지만 가독성있는 코드란 도대체 무엇일까? 라는 의문이 들었다. 더러운 코드란 무엇일까? 무슨 의미인지 1도 모르겠는 변수명? 들여쓰기 내어쓰기? 줄바꿈?..🧐
좋은 코드를 위해 고민하는 훈련을 하고자 Refactorying을 읽기 시작했다.📚 충분한 고민과 함께 책을 완독하였을 떄 한층 더 성장해 있을 나를 꿈꾸며 열심히 달려야겠다!!🏃🏻&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-chapter-1-리펙터링-첫번째-예시를-읽으면서&quot;&gt;📌 Chapter 1: 리펙터링 첫번째 예시를 읽으면서..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;▶︎ 리펙터링 1장은 바로 어떻게 리펙터링하는 것인지 ‘방법’에 대한 글이 아닌 리펙터링의 ‘과정’을 보여주는 챕터였다. 하나의 함수를 기능마다 잘게 쪼개고, 변수를 선언하는 대신 가능한 변수를 인라인하고, 기능의 단계를 나누고, 얼마 전에 공부했던 OOP(객체 지향 프로그래밍)같이 클래스를 활용하여 다향성을 구현하는 등 여러가지 기법을 구사하는 과정을 보았다.&lt;/p&gt;

&lt;p&gt;▶︎ 물론 코드들이 한번에 이해되어 바로 적용할 수 있겠다!!는 아니지만(그렇다고 한다면 지금 여기 있을까..?) 리펙토링이라함은 서두에 언급한 것과 같이 단순히 컨벤션을 지키는 것에 그치는 것이 아니었다. 책 군데군데 명언?같은 글귀가 있었는데 리펙토링할 때 생각해야하는 중요한 사항인 것 같다.&lt;/p&gt;

&lt;h4 id=&quot;-테스트-코드를-작성하라&quot;&gt;🔥 테스트 코드를 작성하라!&lt;/h4&gt;

&lt;p&gt;▶︎ 책에서 틈만나면 나오는 문구이다. 오죽하면 저자가 “이제는 생략하겠습니다.”라고 언급하기까지… 리펙토링을 거쳐가는 과정에서 로직을 점검하기 위한 필수조건이라고 강조하는 것 같았다. (jest 빨리 익혀야게따…!)&lt;/p&gt;

&lt;h4 id=&quot;-프로그램에-새로운-기능을-추가하기-쉬운-형태로-리팩터링하자&quot;&gt;🔥 프로그램에 새로운 기능을 추가하기 쉬운 형태로 리팩터링하자!&lt;/h4&gt;

&lt;p&gt;▶︎ 당연히 이렇게 할 수 있다면 누가 이렇게 안하겠는가..? 당연한 이야기이지만 작은 규모의 IT회사 특성상 코드의 질보다 속도라는 이야기를 얼핏 들은 것 같다. 작업량이 많으니 당연한 이야기..
개발을 하는 누구나 양질의 코드를 짜내고 싶어할 것이라 생각한다.. 하지만 단순히 취미로 가져가는것이 아닌 ‘성과’를 내야하는 환경에서 항상 이런 태도를 이행하기는 쉽지 않을 것 같다. (상업적 코드라고 하나..?)
▶︎ 하지만 그렇다고 좋은 코드 생각하기를 그치지 않아야 한다. 환경에 타협하기보다는 틈틈히 개선해나가고 싶다 :)&lt;/p&gt;

&lt;h4 id=&quot;-사람이-이해하도록-작성하는-코드--수정을-간편하게-할-수-있게-고려한-코드&quot;&gt;🔥 사람이 이해하도록 작성하는 코드 &amp;amp; 수정을 간편하게 할 수 있게 고려한 코드&lt;/h4&gt;

&lt;p&gt;▶︎ 리펙터링의 제일된 목적이지 않을까? 맞게만 작성하면 컴퓨터는 알아서 잘 돌아간다. 하지만 사람은 그렇지 않다. 반복적인 코드를 줄이는 리펙터링을 하였다해도 사람이 못알아보면 말짱 도루묵이다.🐟&lt;/p&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며…&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;책을 읽으면서 의아했던 부분은 리팩터링을 진행하면서 점점 코드 길이가 늘어났다는 것이다. 개발을 처음 시작할 때 ‘간결한 코드가 좋은 코드’라는 근거없는 생각을 항상 하고 다녔다. ‘간결하니까 사람들이 잘 알아보지 않을까?’했다. 같은 맥락일 수 있지만 저자는 ‘명확한 코드’를 강조했다. 고쳐야할 곳을 쉽게 찾을 수 있고 오류없이 빠르게 수정할 수 있으려면 ‘명확’해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;단순히 코드를 길게 쪼개서 장황해지는 코드가 아니라 명확해지는 코드를 고민하며 책을 읽어야겠다. 책을 읽고 실제 코드에 적용하게 되는 날이 빨리 왔으면 좋겠다.👨🏻‍💻&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 13 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/page23-51.html</link>
        <guid isPermaLink="true">http://localhost:4000/book/page23-51.html</guid>
        
        <category>refactorying2</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Recursive Function(재귀 함수)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;삽입 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-recursive-function이란&quot;&gt;Recursive Function이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-다른-풀이&quot;&gt;다른 풀이&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-recursive-function이란&quot;&gt;📌 Recursive Function이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 한 함수 내에서 자기 자신을 다시 호출하는 방식을 가진 함수이다.&lt;/li&gt;
  &lt;li&gt;보통 재귀함수는 스택에 매개변수, 지역변수, 복기주소로 구성되어 있는 스택 프레임에 정보가 저장되기 때문에 일반 반복문보다 느릴 수 있다는 단점을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;개인적으로 느끼기에 재귀함수의 전체적인 흐름은 실행컨텍스트의 흐름으로 이해해도 될 것 같다고 생각했다. (물론 실행컨텍스트가 재귀함수를 설명하기 위한 개념은 아닐 것이지만..)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;1, 2, 3 순으로 나열하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;️-나의-풀이&quot;&gt;💁🏻‍♂️ 나의 풀이&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let initNum = 0;

function selfFunc(a) {
  if(initNum &amp;lt; a) {
    initNum += 1;
    console.log(initNum);
    selfFunc(a);
  } else {
    return;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;️-다른-풀이&quot;&gt;💁🏻‍♀️ 다른 풀이&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selfFunc(a) {
  if(a === 0) return;
  else {
    selfFunc(a - 1);
    console.log(a);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;훨씬 간단해보이지만 중요한 것은 그것이 아니다.(아니..중요할수도..ㅎ)&lt;/li&gt;
  &lt;li&gt;각각 console.log를 찍는 위치가 재귀함수를 다시 호출하기 전/후로 나뉘지만 결과값은 1, 2, 3으로 같다.&lt;/li&gt;
  &lt;li&gt;여기서 스택의 개념이 사용된다.&lt;/li&gt;
  &lt;li&gt;재귀함수는 또 다시 호출된 자기 자신의 함수가 끝나기 전까지는 스택에서 사라지지 않고 보류된다.&lt;/li&gt;
  &lt;li&gt;마치 실행컨텍스트에서 사용되는 콜스택 개념처럼!!&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 재귀함수는 스택의 개념이 중요하다!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-dfs.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-dfs.html</guid>
        
        <category>algorithm</category>
        
        <category>RecursiveFunction</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>10월 11일 월요일</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;10월 11일 월요일의 일상&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;-마지막-업뎃-이후&quot;&gt;📌 마지막 업뎃 이후..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;8월 22일 이후 운영하지 못했던 블로그.. 거의 2달이 다 되어가는 시간동안 역시나 많은 일이 있었다.🗓&lt;/p&gt;

&lt;p&gt;We-Record 프로젝트를 마무리했던 8월 22일 이후 본격적인 취준이 시작되었다. 지금까지 진행했던 코드들을 살펴보고, 면접 때 단골로 나오는 질문들을 서치하여 익히고.. 회사를 찾아보고.. 이런 시간들을 보냈다.&lt;/p&gt;

&lt;p&gt;결국 나는 모 스타트업에 취업하게 되었고 현재 2주차인 신입 개발자로 거듭났다.🎉&lt;/p&gt;

&lt;p&gt;취업하게 되면서 바뀔 줄 알았던 나의 삶은 생각보다 변한게 많이 없었다. 단지 이제부터는 개발에 대한 막중한 책임감을 가지며 ‘일’이라는 개념으로 바뀐 것이 제일 큰 변화인 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;-취업한-이후&quot;&gt;📌 취업한 이후..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;취업하고 2주정도 지난 지금은 회사에서 진행하는 프로젝트를 맡아 필요한 기술 스택을 공부하며 시간을 보냈다. 그러던 중 한가지 문제점?을 발견하게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;문제점&quot;&gt;문제점?🙃&lt;/h3&gt;

&lt;p&gt;개발자의 숙명?인 꾸준한 성장을 계속해서 하고 싶다고 생각했다. 당장 회사에 적용해야할 기술 스택 뿐 아니라 개인적으로 공부할 것들, 주변에서 사용하면 좋다고 하는 기술들을 공부하고 싶었다. 문제는 ‘방법’인데 생각보다 회사에서 ‘공부’라는 개념으로 시간을 내는 것이 쉽지 않았다.&lt;/p&gt;

&lt;p&gt;당연한 이야기이지만 취업하기 전에는 하루종일 공부의 명목으로 시간의 끊김없이 이어갈 수 있었지만, 이제는 아니었다. 해야할 것들은 분명히 많았고, 배우고 싶은 기술 스택 또한 많았다. 욕심이 너무 과한 탓이었을까..? 빨리빨리 모두 다 익히고 싶은 마음은 ‘조급함’을 일으켰다.&lt;/p&gt;

&lt;p&gt;최근에 동기에게 추천받은 리팩터링2 서적을 구매했는데 회사 프로젝트를 위해 필요한 스택을 공부하는 것에 당연히 시간을 할애해야했기 때문에 한번도 펼쳐보지 못했다..ㅠㅠ.. 하고 싶고, 해야한다는 강박이 나를 조급하게 만들었고 하기에 다 소화하지 못할 공부량을 무리하게 계획하여 진행하는 것을 반복했다. 그러면서 스스로를 깎아내리고 있었다.&lt;/p&gt;

&lt;h2 id=&quot;-정확한-방향과-전략적인-계획의-필요성&quot;&gt;🎯 정확한 방향과 전략적인 계획의 필요성&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이제부터는 취준생아니라 신입 개발자로서 지혜롭게 시간을 사용하는 방법을 고민해야할 것 같다. 퇴근하고 막연히 이것저것 공부하기에는 효율과 에너지 낭비가 심하다고 느꼈기 때문이다.&lt;/p&gt;

&lt;p&gt;성장하고 싶다는 좋은 동기로만 움직이는 것이 아니라 성장하기 위해 어떻게 계획하고 행동할까…고민하고 난 이후 나에게 필요한 것은 ‘얄팍하고 다양한 기술 스택의 욕심을 버릴 것’이었다.&lt;/p&gt;

&lt;p&gt;하루 24시간이 부족해 48시간이었으면 좋겠다는 말을 동기들과 농담삼아 이야기하곤 했다. 하지만 현실은 현실…! 내가 익혀야할 기술들에 우선순위를 매겨 ‘깊이’ 공부해야겠다는 결론에 이르렀다.
비록 시간이 오래걸리더라도 드릴다운 방식으로 철저하게, 차근차근, 꾸준히 학습하는 것이 지금 나에게 필요한 마인드셋이지 않을까 생각했다.&lt;/p&gt;

&lt;p&gt;이제는 누군가가 짜주는 커리큘럼은 존재하지 않는다. 스스로 부족한 것을 파악하고 꾸준히 개척해나가야 하는 시간이다..!
주기적으로 내 학습 방법을 셀프 점검을 하면서 성장해야겠다🌱
(물론 회사일도 열심히!!😋)&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/story/Daily_story.html</link>
        <guid isPermaLink="true">http://localhost:4000/story/Daily_story.html</guid>
        
        <category>Daily</category>
        
        
        <category>story</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Insertion Sort</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;삽입 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-insertion-sort란&quot;&gt;Insertion Sort란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-insertion-sort란&quot;&gt;📌 Insertion Sort란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;순서에 맞춰 하나의 요소를 기억한 후에 조건에 맞는 배열의 위치에 삽입시키는 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;버블 정렬과 비슷해보이지만 삽입 정렬의 핵심은 요소를 ‘기억’하는 것에 있다.&lt;/li&gt;
  &lt;li&gt;각각 옆을 비교하는 것을 요소의 개수만큼 비교해야하는 버블 정렬과 달리 삽입 정렬은 최선의 결과로 시간복잡도 O(n)을 가질 수 있는 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;하지만 다르게 표현하면 최악으로는 역시나 O(n&lt;sup&gt;2&lt;/sup&gt;)을 가질 수도 있다는 것으로 데이터의 상태에 따라 성능차이가 심한 알고리즘이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 배열을 오름차순으로 정렬하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (arr) =&amp;gt; {
  let answer = arr;

  function compareProps(arr, i) {
    if(arr[i] &amp;gt; arr[i + 1]) {
      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
      i--;
      compareProps(arr, i);
    }
  }

  for(let i = 0; i &amp;lt; answer.length; i++) {
    compareProps(answer, i);
  }

  return answer;
}

let arr = [11, 7, 5, 6, 10, 9];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 양 옆이 정렬 조건에 불일치한다면 바꿔주고 다시 바뀐 요소를 한번 더 바꿔주는 것이 삽입 정렬이라고 생각했다.&lt;/li&gt;
  &lt;li&gt;요소가 바뀌면 계속 체크를 해줘야 할 것 같아서 재귀문을 사용하여 코드를 구현해보았다.&lt;/li&gt;
  &lt;li&gt;가만히 생각해보니 삽입보다는 버블에 가까운 듯한데.. 그렇다고 버블처럼 시간복잡도를 항상 O(n&lt;sup&gt;2&lt;/sup&gt;)를 가지지는 않는것 같아서 무슨 정렬인지 잘 모르겠다…(삽입인가..?)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr2 = [11, 7, 5, 6, 10, 9];

const question2 = (arr) =&amp;gt; {
  let answer = arr;

  for(let i = 0; i &amp;lt; answer.length; i++) {
    let tmp = answer[i], j

    for(j = i -1; j &amp;gt;= 0; j--) {
      if(answer[j] &amp;gt; tmp) answer[j + 1] = answer[j];
      else break;
    }
    answer[j+1] = tmp;
    console.log(answer);
  }

  return answer;
}

question2(arr2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 코드가 정석적인 삽입 정렬이다.&lt;/li&gt;
  &lt;li&gt;처음에 요소를 기억한 후, 다음 for문에서 기억된 요소와 해당 요소를 비교한다.&lt;/li&gt;
  &lt;li&gt;비교한 후 바뀌어야한다면 한단계씩 순차적으로 조건에 만족할 때까지 비교하고 바꿔준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 지금보니까 1번째 코드와 2번째 코드의 차이로 ‘변수에 할당하는가’의 차이밖에 없는 것 같은데… 삽입에 가까운 것 같다!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 22 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-insertionSort.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-insertionSort.html</guid>
        
        <category>algorithm</category>
        
        <category>InsertionSort</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Bubble Sort</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;버블 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-bubble-sort버블-정렬란&quot;&gt;Bubble Sort(버블 정렬)란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-bubble-sort버블-정렬란&quot;&gt;📌 Bubble Sort(버블 정렬)란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;서로 인접한 두 요소를 검사하여 정렬하는 알고리즘&lt;/li&gt;
  &lt;li&gt;선택정렬과 마찬가지로 시간복잡도 측면에서 O(n&lt;sup&gt;2&lt;/sup&gt;)를 가진다.&lt;/li&gt;
  &lt;li&gt;단순하고 구현하기 어렵지 않지만, 많은 데이터를 다루게 된다면 상당히 비효율적인 정렬 방법이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 배열 내에서 오름차순으로 정렬하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [13, 5, 2, 7, 19, 20, 9, 17];

const question = arr =&amp;gt; {
    let answer = [];

    while(arr.length &amp;gt; 0) {
        for(let i = 0; i &amp;lt; arr.length; i++) {
            if(arr[i] &amp;lt; arr[i + 1]) {
                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
            }
        }
        answer.push(arr.pop());
    }

    return answer;
}

question(arr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이런 방법으로 처음에 구현했었는데 직관적으로 보기에는 정렬 순서가 내림차순 느낌이 나서 가독성에 좋지 않았던 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [13, 5, 2, 7, 19, 20, 9, 17];

const question = arr =&amp;gt; {
    let answer = arr;

    for(let i = 0; i &amp;lt; answer.length -1; i++) {
        for(let j = 0; j &amp;lt; answer.length - i - 1; j++) {
            if(answer[j] &amp;gt; answer[j + 1]) {
                [answer[j], answer[j + 1]] = [answer[j + 1], answer[j]];
            }
        }
    }

    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;가독성이 훨씬 좋아졌다. 그리고 전보다 불필요한 메서드를 사용하지 않아도 구현이 가능해졌다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 19 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-bubbleSort.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-bubbleSort.html</guid>
        
        <category>algorithm</category>
        
        <category>BubbleSort</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>Werecord project -v2👨🏻‍💻</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Werecord -v2 project 후기 및 피드백입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-we-record--v2&quot;&gt;We Record -v2?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-각-페이지-소개&quot;&gt;각 페이지 소개&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-initail-setting&quot;&gt;Initail Setting&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-global-component&quot;&gt;Global Component&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-landing-page&quot;&gt;Landing Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-main-page&quot;&gt;Main Page&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#1-실시간-타이머-기능&quot;&gt;1. 실시간 타이머 기능&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#2-스크린-캡쳐-기능&quot;&gt;2. 스크린 캡쳐 기능&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-my-page&quot;&gt;My Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-mate-page&quot;&gt;Mate Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-responsive-web-반응형웹&quot;&gt;Responsive Web(반응형 웹)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-error--fix&quot;&gt;Error &amp;amp; Fix&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며…&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-we-record--v2&quot;&gt;📌 We Record -v2?!?!&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://ksy4568.github.io/project/project-review-werecord.html&quot;&gt;💁🏻‍♂️ 버전1 - WeRecord 후기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://youtu.be/TtY8FGlqDuw&quot;&gt;💁🏻‍♂️ 버전1 - WeRecord 영상&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;팀원들과 함께 한 We Record project가 마무리 된지 어느덧 한달이 지나고 있는 것 같다..(시간이 진짜 빠르다..🚗) 함께했던 팀원들도 각자도생..?의 느낌으로 흩어져 자신만의 스타일, 방식대로 취업을 준비하는 시간을 보내게 될 것 같았다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;빠듯한 취업 준비로 We Record의 프로젝트는 우리의 코딩 성장의 양분이 되어 기억 속에 잊혀질 것만 같았지만,, 사람 일은 모르는 것!!⭐️ 그저 코딩이 재미있고, 배우고 싶은 기술 스택도 많았고, 무엇보다 서비스를 목적으로 처음 작업했던 프로젝트를 더욱 완성도 있는 서비스를 만드는 것에 마음이 갔다.
이런 나를 팀원분들과 멘토님께서 배려해주셔서 혼자 We Record -v2를 작업할 기회가 생기게 되었다!! 🔥 (두둔)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;약 2주 정도가 지난 지금 프로젝트는 생각보다 재미있었고 다른 동기들이 짰던 코드들을 보면서 어떻게 구현해야하는지 몰랐던 로직도 알게 되고, 내가 짰던 코드와 동기 코드를 비교하면서 어떤게 더 효율적일까 고민도 하면서 재밌고 알찬 시간을 보낸 것 같아 기분이 좋았다.😊
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제는 개인 프로젝트로 바뀌었지만 컨벤션과 trello를 활용하여 할일을 체크하고 기록을 남겨두어 스스로 피드백을 하고 싶었다. 컨벤션은 최대한 이전 프로젝트를 따라가고 trello를 활용하여 blocker와 백앤드분께 추가적으로 요청해야될 부분들을 티켓으로 만들어 보관했다.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;trello&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/trelloImg.png&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-각-페이지-소개&quot;&gt;📌 각 페이지 소개&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-initail-setting&quot;&gt;🌱 Initail Setting&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;개인 프로젝트로 바뀌면서 제일 먼저 손봤던 것은 초기세팅이었다. 반응형을 시작으로 폰트, 색상들이 필요할 때마다 master가 merge되다가 지쳐 결국 각자 컴포넌트에서 일일히 따로 선언했던 기억이 떠올랐기 때문이다.&lt;/li&gt;
  &lt;li&gt;1차 프로젝트 당시에 사용했던 초기세팅의 기억을 되살려 폰트 색상, 반응형 breakpoint 등등을 다시 작업했다.&lt;/li&gt;
  &lt;li&gt;초기 세팅에서 제일 신경썼던 기능은 background였다!! 페이지 뒤에 보이는 산같은 실루엣들이 옆으로 계속 움직이는 것과 시간에 따라 색상이 변하는 기능이었다.(와우!!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;morning&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/morning.png&quot; width=&quot;250px&quot; /&gt; 아침
&lt;img alt=&quot;afternoon&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/afternoon.png&quot; width=&quot;250px&quot; /&gt; 점심
&lt;img alt=&quot;evening&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/evening.png&quot; width=&quot;250px&quot; /&gt; 저녁
&lt;img alt=&quot;dawn&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/dawn.png&quot; width=&quot;250px&quot; /&gt; 새벽&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;어떻게 구현할까 고민하다가 global css에 dayjs를 import시키고 시간 값에 따라서 background를 지정해주어 간단하게 끝냈다! (styled component 짱이다!! 👍🏼)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;뒤에 동산같이 생긴 곡선이 옆으로 움직이는 로직은 동산 이미지에 animation을 주어 옆으로 무한히 움직이도록 코드를 짰는데.. 생각보다 과부하가 걸리는 듯한 느낌이라 추후에 request animation frame으로 구현해볼까 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-global-component&quot;&gt;🌱 Global Component&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;GNB와 footer도 조금 다시 손봐야했다. GNB와 footer의 양 옆 margin이 page마다 일정해야했기 때문이다.&lt;/li&gt;
  &lt;li&gt;또한 기존에 해당 페이지에 있으면 그 버튼이 안보이게 되었던 것과 다르게, 바뀐 GNB는 각 페이지에 있을 때 폰트 색상이 흰색으로 바뀌어야했다.&lt;/li&gt;
  &lt;li&gt;location.pathname을 사용해 조건부 랜더링으로 되어있던 코드를 styled component에 넘겨주어 유동적으로 바뀌도록 코드를 짰다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;GNB&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/GNB.png&quot; width=&quot;250px&quot; title=&quot;desktop&quot; /&gt; desktop
&lt;img alt=&quot;GNB&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/GNB2.png&quot; width=&quot;250px&quot; /&gt; mobile&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존의 modal도 다시 작업했다! 이제는 start를 눌렀을 때 또한 모달창이 떠야했고 모달 크기는 일정해야하지만 내부 컨텐츠 크기가 제각각이어서 내부에 padding을 주기보단 width와 height를 직접 설정해주는 방법으로 변경했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-landing-page&quot;&gt;🌱 Landing Page&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;수정하는데 조금 복잡했던 랜딩페이지..! 소셜 로그인을 구현안해본 나로서는 멀 건드리면 안되고 되는지.. 하나하나 손볼 때마다 조심스럽게 다뤘던 것 같다.&lt;/li&gt;
  &lt;li&gt;포인트는 -v1에서는 SignIn이 모달을 통해 이루어졌는데 -v2에서는 한 페이지 내에서 구현을 해야했다..!!&lt;/li&gt;
  &lt;li&gt;하나로 합치는 것까지는 어렵지 않았지만 처음보는 소셜로그인 코드를 보고 JWT를 방식에 대해 공부하면서 작업해서 시간이 조금 소요되었다.(나중에 JWT 포스팅해야지~)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;landing&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/landing.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-main-page&quot;&gt;🌱 Main Page&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;드디에 시간이 제일 많이 걸린 Main Page다..&lt;/li&gt;
  &lt;li&gt;딱 봐도 새로운 기능이 추가되었는데 바로 실시간 타이머기능, 스크린샷 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-실시간-타이머-기능&quot;&gt;1. 실시간 타이머 기능&lt;/h4&gt;

&lt;p&gt;&lt;img alt=&quot;timer&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/timer.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 없던 기능이라 고민을 많이 했다. 마이 페이지에도 실시간으로 근태 시간이 반영되는 기능이 있지만 그것은 시간만 따로 빼내어 랜더링 시킨 것이라면, 이 기능은 flipClock기능도 추가시켜야 했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;npm을 구석구석 찾다가 페이지 컨셉과 잘 맞을 것 같은 라이브러리를 찾았다. react-simple-flipClock이 바로 그것이지만 문제점이 하나 있었는데… 시간이 0으로 가는 타이머 기능만 있었고 정교한 스타일링을 지원을 하지 않았고,, pause를 눌러 멈추고 다시 가게하는 기능이 없었던 것.. 너무나 pure한 타이머였다. 👶🏻&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;결국 라이브러리를 뜯어 커스텀하기 시작했는데.. 생각보다 재미있네..?? 🤭&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리의 동작 방식을 살펴보니 초를 넘겨주면 내부에서 알아서 1초마다 transform이 일어나도록 코드가 짜여져 있었다. 그리고 0에 도달하면 타이머가 멈추는 방식이었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이것을 이용하여 벡앤드분께 지금까지 진행한 total time과 last stop time을 요청하여 코드를 짰다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;start를 눌렀을 때는 0부터 serinterval로 1씩 증가 &lt;br /&gt;&lt;/li&gt;
        &lt;li&gt;restart나 pause를 눌렀을 때는 백엔드로부터 total time을 초로 받아서 로직에 적용&lt;br /&gt;&lt;/li&gt;
        &lt;li&gt;start를 누른 상태에서 페이지를 나갔다가 다시 들어왔을 때도 계속 변하는 값을 기억하는 방법은 total시간에 (가장 나중에 누른 start시간 - 현재 시간)으로 계산했다.&lt;br /&gt;&lt;/li&gt;
        &lt;li&gt;문제점이 하나 있는데 백엔드 시간 데이터와 프론트 시간 데이터 간의 차이가 간혹 발생한다.. 이로 인해 1~2초 정도 오차가 나는 경우가 종종 발생하는데.. 시간 데이터는 한쪽에서 계산하는 것이 좀 더 안정적으로 보인다..ㅠ&lt;br /&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-스크린-캡쳐-기능&quot;&gt;2. 스크린 캡쳐 기능&lt;/h4&gt;

&lt;p&gt;&lt;img alt=&quot;screenCapture&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/snapShot.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것도 새로운 기능이라 신기하고 재미있었다 :)&lt;/li&gt;
  &lt;li&gt;html2canvas 라이브러리를 이용하여 적용했는데 처음에는 desktop영역을 지정하려 했었지만, desktop영역에는 없는 요소들도 추가되거나 desktop에는 있지만 screenCapture에는 보이지 않아야하는 요소들이 있었다.&lt;/li&gt;
  &lt;li&gt;결국 ScreenModal을 새로 만들어 그 modal를 capture하는 식으로 계획을 변경했다! 😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-my-page&quot;&gt;🌱 My Page&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;myPage&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/myPage.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이페이지는 전체적인 UI를 수정하는 것이 주 작업이었다.&lt;/li&gt;
  &lt;li&gt;앞서 소개한 랜딩 페이지와 마이 페이지를 수정하면서 느낀 것이 있다라면,, 다른 사람 코드도 내 코드처럼 보는 능력을 기르는 것!! 굉장히 중요한 능력인 것 같다고 생각되었다!🥸&lt;/li&gt;
  &lt;li&gt;기존의 highChart의 내부 코드를 수정해야하는 작업, 랜더링 시켜야하는 시간 데이터 코드 수정 작업을 제외하면 빠르게 작업한 페이지였던 것 같다. :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-mate-page&quot;&gt;🌱 Mate Page&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;matePage&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/matePage.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기수페이지 또한 빠르게 작업한 페이지였다.&lt;/li&gt;
  &lt;li&gt;전체적인 UI부분을 바꾸는 것이 주 작업이었다.&lt;/li&gt;
  &lt;li&gt;기수페이지는 나 혼자 작업하기에는 한계가 있었고 백엔드분께 추가적인 데이터를 요청드려야했다! (공손공손)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-responsive-web-반응형-웹&quot;&gt;🌱 Responsive Web (반응형 웹)&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;responsiveWeb&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/responsive.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;반응형은 최대 1440px, 모바일 1024px로 지정하여 적용하였다.&lt;/li&gt;
  &lt;li&gt;styled에 media를 적용하여 해당 breakPoint별로 변화가 있다면 각 component에 선언해주어야 하는 방식으로 코드를 짰다.&lt;/li&gt;
  &lt;li&gt;하지만 이 방법이 가독성이나 효율적인 코드인지는 다시 검토해보고 적용시킬 예정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-error--fix&quot;&gt;🌱 Error &amp;amp; Fix&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;나름 꼼꼼하게 코드를 짰다고 하더라도 초기에는 에러와 함께하는 것 같다…ㅠㅠ(디자인이나 문구도 조금씩 바뀌는 것들도 함께 고려..!) 생각지도 못했던 에러들을 접하면서 코드의 질을 높일 수 있는 고민을 해보는 시간을 가져야겠다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🔥 멘토님께서 확인해주신 Error &amp;amp; Fix &amp;amp; Design 수정&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;window.innerheight를 사용하여 화면 크기가 달라도 한 화면에 보여질 수 있도록&lt;/li&gt;
    &lt;li&gt;화면이 커져도 요소들이 창 가운데 있도록&lt;/li&gt;
    &lt;li&gt;요소들 dragEvent시 포인트 색상으로 변경&lt;/li&gt;
    &lt;li&gt;Screen Capture Modal 위, 아래에 페이지 이름, 넣기&lt;/li&gt;
    &lt;li&gt;다른 기수 페이지에 접근하기 위해 url을 바꾸면 에러가 나는 버그 수정&lt;/li&gt;
    &lt;li&gt;반응형 모바일일 때 ScreenCapture Modal이 desktop화면과 동일하도록 수정&lt;/li&gt;
    &lt;li&gt;반응형 모바일일 때 기수페이지 기수 등수를 누르면 z-index가 앞으로 나오도록 하는 이벤트 걸기 &lt;br /&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;(생각보다 버그보다는 디자인이 고칠 부분이 많은 것 같아서 괜히 뿌듯했다 :) )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;사실 아직 아쉬운 부분들도 남아있다. Redux를 사용해서 전역으로 state를 관리해보고 싶었고, typeScript를 사용해서 트렌드에 맞는 코드를 경험해보고 싶었다. 이런 바램과 달리 오늘 멘토님과 프로젝트 에러픽스를 마치면 바로 배포 진행해서 실제 서비스할 예정이라고 말씀해주셔서 왠지 모르게 신기했다. 실제 코딩을 통해 ‘개발’을 했다라는 것이 기분이 묘해졌다. 앞으로도 개발과 함께 삶을 살아간다는 것 또한 신기했다.👨🏻‍💻 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우여곡절이 많았던 WeRecord 프로젝트! 실제 서비스할 수 있도록 끝까지 함께했던 시간을 통해 많은 것들을 알아갔다. 마냥 코딩이 재미있어서, 새로운 알고리즘으로 문제를 해결하는 통쾌, 새로운 기술 스택으로 안정성 있는 코드를 구현하는 즐거움… 이런 것들이 전부였던 나에게(당연히 저 요소들도 중요하겠지만 🤗) ‘내 프로젝트, 내 코드’라는 애착이 생겼다. 더 효율적으로, 다른 사람들이 봐도 가독성있게, 무엇보다 실제 서비스를 받는 클라이언트를 위한 쾌적한 서비스환경을 만들고 싶은 마음이 생겼다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;가치를 만들고자 하는 가치관에서 ‘어떤 가치를 만들고 싶은지’에 대해 약간 가닥이 잡혀가는 것 같다. 특정 분야가 아니라 어느 분야에서도 실제 서비스를 받는 클라이언트가 만족할 수 있는 ‘개발’을 하고 싶다. 그런 개발자가 될 수 있도록 앞으로도 화이팅이다!! 💪🏻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 &lt;a href=&quot;https://github.com/wecode-bootcamp-korea/werecord-frontend&quot;&gt;We-Record Github repo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 17 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/project-review-werecord-v2.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/project-review-werecord-v2.html</guid>
        
        <category>project</category>
        
        <category>werecord</category>
        
        <category>React</category>
        
        <category>근태</category>
        
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Selection Sort</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;선택 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-selection-sort버블-정렬란&quot;&gt;Selection Sort(버블정렬)란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-selection-sort버블-정렬란&quot;&gt;📌 Selection Sort(버블 정렬)란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;입력 배열(정렬되지 않는 값들) 이외에 다른 추가 메모리가 필요하지 않다.&lt;/li&gt;
  &lt;li&gt;해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘&lt;/li&gt;
  &lt;li&gt;일반적으로 이중 for문을 사용하는 느낌이다. (첫번째 요소를 두번째 요소부터 차례대로 비교하여 조건이 충족하면 첫번째 요소와 조건에 맞는 요소를 바꾸고, 다음 두번째 요소를 세번째 요소부터 비교하는 작업을 반복하여 정렬한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 배열의 요소를 오름차순으로 정렬하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (arr) =&amp;gt; {
    let answer = arr;

    for(let i = 0; i &amp;lt; answer.length; i++) {
        let idx = i;

        for(let j = i + 1; j &amp;lt; answer.length; j++) {
            if(answer[idx] &amp;gt; answer[j]) idx = j;
        }

        [answer[i], answer[idx]] = [answer[idx], answer[i]];
    }

    return answer;
}

question([13, 5, 7, 3, 9, 16, 2]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 for문에서는 첫번째 요소를 지정해준다.&lt;/li&gt;
  &lt;li&gt;두번째 for문에서는 지정된 첫번째 요소와 두번째 이후부터의 요소들과 비교한다.&lt;/li&gt;
  &lt;li&gt;두번째 for문이 종료되면 첫번째 요소와 조건에 충족된 요소의 위치를 바꾸어준다.&lt;/li&gt;
  &lt;li&gt;이것을 첫번째 for문이 종료될 때까지 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🎈 시간복잡도 측면에서는 O(n&lt;sup&gt;2&lt;/sup&gt;)으로 느린 속도를 가진다.&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-selectionSort.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-selectionSort.html</guid>
        
        <category>algorithm</category>
        
        <category>SelectionSort</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Queue</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Queue 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-queue란&quot;&gt;Queue란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제요세푸스-순열&quot;&gt;사용 예제(요세푸스 순열)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-queue란&quot;&gt;📌 Queue란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 넣은 데이터를 먼저 나오게 하는 FIFO(First in First Out) 자료구조 형식이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FILO(First in Last Out) 형식인 Stack과 다르게 Queue는 한쪽에서는 삽입 연산, 다른 한쪽은 삭제 연산이 이루어지는 형식이다.&lt;/p&gt;

    &lt;p&gt;&lt;img alt=&quot;queue&quot; src=&quot;/assets/img/algorithm/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제요세푸스-순열&quot;&gt;📌 사용 예제(요세푸스 순열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;8명의 사람들을 원형으로 세우고 순서대로 돌아가면서 1부터 번호를 부르는데 3에 해당하는 사람은 제외시킨다.&lt;/li&gt;
  &lt;li&gt;제외가 되면 제외된 다음 사람부터 1을 부르고 마찬가지로 3에 해당되는 사람은 제외시키는 것을 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (n, k) =&amp;gt; {
    let answer;
    let queue = Array.from({length: n}, (v, i) =&amp;gt; i + 1); ----- (1)

    while(queue.length) {     -------(2)
        for(let i = 1; i &amp;lt; k; i++) queue.push(queue.shift());
        queue.shift();
        if(queue.length === 1) answer = queue.shift();
    }
    return answer;
}

question(8, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)에서 함수형 프로그래밍으로 1부터 8까지의 요소들을 갖는 배열을 만든다.(함수형 프로그래밍 공부해야겠다..🔥)&lt;/li&gt;
  &lt;li&gt;(2)에서 queue.length가 0이 될 때까지 반복문을 돌린다.&lt;/li&gt;
  &lt;li&gt;먼저 queue의 첫번째 요소, 두번째 요소를 for문을 사용하여 차례로 queue 배열 뒤에 쌓고 앞의 숫자는 제거한다.&lt;/li&gt;
  &lt;li&gt;그 다음 queue의 첫번째 요소가 되는 숫자는 처음 queue의 3번째 숫자였으므로 뒤에 넣지 않고 제거만 한다.&lt;/li&gt;
  &lt;li&gt;이것을 반복하여 마지막 queue의 요소가 1개가 남으면 그 요소를 answer에 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 정리하여 앞에 숫자가 조건에 만족하면 배열 마지막 요소로 push하고 shift를 사용하여 제거하지만, 조건에 만족하지 않으면 shift만 사용하여 제거함으로 최후에 남는 데이터를 찾을 수 있는 알고리즘이다.&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-queue.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-queue.html</guid>
        
        <category>algorithm</category>
        
        <category>Queue</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Stack</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Stack 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-stack이란&quot;&gt;Stack이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제배열&quot;&gt;사용 예제(배열)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-stack이란&quot;&gt;📌 Stack이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;‘쌓다’, ‘더미’ 라는 의미를 가진 알고리즘&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이름의 의미와 같이 한쪽으로만 열려있기 때문에 한쪽으로만 데이터를 받고 빼는 구조로 되어 있다. (후입선출)
&lt;img alt=&quot;&quot; src=&quot;/assets/img/algorithm/stack1.png&quot; width=&quot;400px&quot; /&gt; Last In First Out&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack의 구현 방법은 배열, 연결 리스트 2가지가 있다. (Stack이라고 해서 특별한 저장 공간을 가지는 array나 object가 있는 것이 아니라 stack이라는 자료구조 형식으로 알맞게 구현하는 것!)&lt;/li&gt;
  &lt;li&gt;각각 배열과 연결 리스트의 장단점이 있는데 &lt;br /&gt;
배열은 ‘데이터 접근 속도가 빠르기 때문에 데이터 양이 많으면 많을수록 효율이 좋지만, 데이터 삽입과 삭제에서는 비효율적’이다. &lt;br /&gt;
연결리스트는 ‘데이터 접근할 경우에는 연결되어 있는 노드를 따라 확인하며 접근하기 때문에 접근, 속도에서는 효율이 떨어지지만 데이터 삽입, 삭제는 배열보다 효율이 좋다’.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제배열&quot;&gt;📌 사용 예제(배열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;()의 짝이 맞는 경우는 true, 안맞으면 false&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let str = '(()()(())' // false

const question = (str) =&amp;gt; {
    let stack = [];

    for(let i of str) {
        if(i === '(') {
            stack.push(i);
        }
        else {
            if(stack.length === 0) {
                return false;
            } else {
                stack.pop();
            }
        }
    }
    if(stack.length &amp;gt; 0) return false
    else return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;stack이라는 배열을 만들고 난 후 ‘(‘가 있으면 stack에 push하고 ‘)’가 있으면 기존에 있는 ‘(‘를 pop하는 방식이다.&lt;/li&gt;
  &lt;li&gt;이렇듯 하나의 배열에 데이터를 순서대로 쌓고 순서대로 빼는 방식이 stack 자료구조이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 10 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-stack.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-stack.html</guid>
        
        <category>algorithm</category>
        
        <category>Stack</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Hash</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;임의의 길이의 데이터를 고정된 길이의 데이터로 변환시키는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-hash란&quot;&gt;Hash란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-hash란&quot;&gt;📌 Hash란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&quot; target=&quot;\_blank&quot;&gt;사전적 정의&lt;/a&gt;로 임의의 길이를 가지고 있는 데이터를 고정된 길이의 데이터로 변환시켜주는 자료 구조이다.&lt;/li&gt;
  &lt;li&gt;Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.&lt;/li&gt;
  &lt;li&gt;데이터를 추가/삭제 시 기존 데이터를 밀어내거나 당기는 작업이 없도록 하는 알고리즘을 이용하여 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. (&lt;a href=&quot;https://jroomstudio.tistory.com/10&quot; target=&quot;/\_blank&quot;&gt;출처&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 쉽게 설명하자면 식당 메뉴판에 정렬된 메뉴를 볼때는 순차적으로 위에서 아래로 훑는게 아니라 아예 메뉴 이름에 대한 값을 알고 있는 것이라고 비유할 수 있을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;array안에 있는 과일들 중 가장 많이 들어있는 과일을 찾으시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let fruits = ['사과', '바나나', '배', '사과', '사과', '배', '배', '사과', '사과']
const question = (fruits) =&amp;gt; {
    let answer;
    let hash = new Map();

    for(let i of fruits) {
        if(hash.has(i)) hash.set(i, hash.get(i) + 1);
        else hash.set(i, 1);
    }

    let max = 0;
    for(let [key, value] of hash) {
        if(value &amp;gt; max) {
            max = value;
            answer = key;
        }
    }
    return answer; // '사과'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for문을 사용한 것은 배열 안에 있는 요소들이 map을 사용한 hash 안에 있는지 없는지 탐색하기 위함이다.&lt;/li&gt;
  &lt;li&gt;키값에 대한 데이터를 저장할 때 배열의 특징이 아닌 객체같은 특징을 보여준다.(데이터를 추가시 밀어내거나 당기는 이벤트가 발생하지 않는 부분)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-hash.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-hash.html</guid>
        
        <category>algorithm</category>
        
        <category>Hash</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Sliding Window</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;배열에서 일정한 간격을 유지하면서 이동하며 탐색하는 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-sliding-window란&quot;&gt;Sliding Window란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-sliding-window란&quot;&gt;📌 Sliding Window란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;배열같은 형태를 띈 자료 구조에서 일정한 간격을 유지하면서 탐색하는 알고리즘 기법이다.&lt;/li&gt;
  &lt;li&gt;이중 for문보다 시간복잡도 측면에서 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;🎈 배열 안에서 연속되는 3개의 수의 합 중 가장 큰 합을 구하시오.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// For문을 사용했을 경우
const useFor = (m, arr) =&amp;gt; {
    let answer = 0;

    for(let i = 0; i &amp;lt; arr.length - m + 1; i++) {
        let sum = 0;

        for(let z = i; z &amp;lt; i + m; z++) {
            sum += arr[z];
            answer = Math.max(answer, sum);
        }
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문을 사용하게 되면 시간복잡도로 최대 O(N&lt;sup&gt;2&lt;/sup&gt;)가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const useSliderWindow = (m, arr) =&amp;gt; {
    let answer = 0;
    let sum = 0;

    for(let i = 0; i &amp;lt; m; i++) {
        sum += arr[i];
    }

    for(let i = m; i &amp;lt; arr.length; i++) {
        sum += arr[i] - arr[i - m];
        answer = Math.max(answer, sum);
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문과 달리 Slider Window는 배열의 처음과 끝을 &lt;b&gt;한번만&lt;/b&gt;탐색한다. (시간 효율이 좋다);&lt;/li&gt;
  &lt;li&gt;일정한 간격을 유지하기 때문에 범위의 앞과 뒤에서는 삭제와 삽입이 일어난다. (Deque 자료구조)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-slidingWindow.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-slidingWindow.html</guid>
        
        <category>algorithm</category>
        
        <category>TwoPointer</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[JavaScript] This</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This의 개념과 작동 원리입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-this란&quot;&gt;📌 This란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;this는 간단하게 말해서 &lt;b&gt;식별자가 바라봐야할 대상&lt;/b&gt;을 의미합니다.&lt;/li&gt;
  &lt;li&gt;이게 무슨 말이지?? 라고 할 수 있겠지만, this는 함수가 호출되어 실행 컨텍스트가 생성되면 결정됩니다.&lt;/li&gt;
  &lt;li&gt;이 때, this가 &lt;b&gt;전역에 있을 경우&lt;/b&gt;!! 실행 컨텍스트가 생성되면서 가지게 되는 Lexical Environment(환경 정보들을 모아 놓은 객체)를 가리키게 됩니다.&lt;/li&gt;
  &lt;li&gt;그래서 식별자가 바라봐야할 대상을 의미한다는 것은 this를 가지고 있는 함수가 호출되었을 때 해당 함수 호출 주체를 가리키게 되는 것인지, 함수 바깥의 전역을 가리키게 되는 것인지에 대한 현상들을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-갑자기-lexical-environment&quot;&gt;🎈 갑자기 Lexical Environment?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;갑자기 왜 Lexical Environment일까?? 다음 예시를 보면 이해가 될 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
console.log(window.a) // a = 1
console.log(this.a) // a = 1

window.a = 3
console.log(a) // a = 3
console.log(this.a) // a = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;앞서 언급했던 ‘this는 전역에 있을 때 Lexical Environment를 가리킨다’라는 의미를 설명해주는 코드라고 생각한다.&lt;/li&gt;
    &lt;li&gt;var로 a를 선언하게 되면 a라는 변수는 전역 컨텍스트의 Lexical Environment에 저장된다.&lt;/li&gt;
    &lt;li&gt;this가 가리키는 것 또한 Lexical Environment이기 때문에 this.a로 접근이 가능함과 동시에 수정도 가능했던 것이다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;=&amp;gt; 이와같이 this가 전역 내부에 있다면 전역 Lexical Environment를 참조하게 되지만, 만약 함수 내부에서 this를 실행시키면 그 this는 함수가 호출되었을 때 생성된 실행 컨텍스트 Lexical Environment를 가리키게 될것인가? 상황에 따라 다르다. 이제부터 그 상황을 알아보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;-함수-안의-this&quot;&gt;📌 함수 안의 This&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-함수와-메서드의-차이점&quot;&gt;🌱 함수와 메서드의 차이점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수와 메서드를 나눌 수 있는 기준점은 &lt;b&gt;독립성&lt;/b&gt;이다.&lt;/li&gt;
  &lt;li&gt;함수는 그 자체로 가지고 있는 동작을 수행하지만, 메서드는 자신을 호출하는 대상 객체에 관한 동작을 수행한다.&lt;/li&gt;
  &lt;li&gt;여기서 포인트는 그 자체로 가지고 있는 동작을 수행하는 것과 함께 자신을 호출하는 대상 객체에 관한 동작을 수행하는 것도 메소드이다.&lt;/li&gt;
  &lt;li&gt;쉽게말해서 함수 앞에 “.”! 이 점을 찍냐의 유무에 따라 함수인지 메소드인지 구별할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(a)
}

func(1);   ---- (1)

var obj = {
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)과 (2)는 그 자체로 사용될 수 있는 함수이다. 여기서 (1)은 자체적으로 선언하지만, (2)는 obj라는 호출 주체를 통해서 함수를 사용했다.&lt;/li&gt;
  &lt;li&gt;이 차이가 (1)은 함수, (2)는 메소드로 구분짓는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-그래서-함수랑-메소드가-this랑-무슨-상관&quot;&gt;🌱 그래서 함수랑 메소드가 this랑 무슨 상관??&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수 내부에 있는 this는 전역을 가리킨다.&lt;/li&gt;
  &lt;li&gt;호출 주체를 함께 명시한 함수(ex. obj.num)의 this는 호출 주체를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(this, a)
}

func(1);   ---- (1)

var obj = {
    b: 1,
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드에서 func의 console.log에 this만 추가시켰다.&lt;/li&gt;
  &lt;li&gt;(1)에서의 this는 전역을 가리키게 되지만, (2)에서는 obj를 가리키게 된다. ((2)의 값으로{b: 1, num: func()}이 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-this의-예외-케이스&quot;&gt;🌱 this의 예외 케이스&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;this가 포함된 함수를 다른 변수에 할당한 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = function() {
            console.log(this);
        }
        c();         --- (2)

        var self = this;
        var d = function () {
            console.log(self);
        }
        d();          ----- (3)
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)은 b가 obj를 호출 주체를 명시하며 호출했기 때문에 this는 obj를 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(2)는 c 자체가 호출 주체를 명시하지 않고 호출했기 때문에 전역을 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(3)은 this를 b의 함수 안에 선언한 변수에 할당했기 때문에 이 때는 this가 상위의 호출 주체를 가리키게 된다.(여기에서는 obj)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이러한 현상을 ES6의 화살표 함수를 통해서도 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = () =&amp;gt; {
            console.log(this);
        }
        c();
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;c에 있는 this는 c가 호출했다고 해서 전역을 가리키는 것이 아니라 화살표 함수를 사용했기 때문에 위와 같은 현상이 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 또, 콜백 함수, 생성자 함수 내부에서의 this는 위와 같이 동일한 현상이 일어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-call-apply-bind&quot;&gt;📌 call, apply, bind&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-call&quot;&gt;🌱 call&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;call은 첫번째 인자(임의의 객체)를 this로 바인딩하고 두번째 인자부터 함수에 사용되는 매개변수로 지정된다.&lt;/li&gt;
  &lt;li&gt;이때 앞서 이야기했던 this의 성질인 호출 주체가 있고 임의의 객체를 바인딩하지 않았다면 this는 호출 주체를 가리키게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var hello = function (a, b, c) {
    console.log(this, a, b, c);
}

hello('hi', 'hello', '안녕');
// -&amp;gt; Window hi hello 안녕

hello({name: syeon}, 'hi', 'hello', '안녕');
// -&amp;gt; {name: syeon} hi hello 안녕
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;즉 call로 부른 함수는 즉시 실행됨과 동시에 앞에 할당했던 객체를 바인딩하여 가져올 수 있는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-apply&quot;&gt;🌱 apply&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;apply는 call과 동일한 역할을 수행하지만 첫번째 인자인 임의의 객체 이후에는 호출된 함수의 매개변수들을 배열로 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;-call과-apply의-활용법--유사배열객체&quot;&gt;🎈 call과 apply의 활용법 : 유사배열객체&lt;/h4&gt;

  &lt;ul&gt;
    &lt;li&gt;유사 배열객체는 키값이 0부터 순차대로 양수인 객체에 적용된다. 이러한 특징을 가진 객체는 call과 apply를 사용하여 객체에 배열 메소드들을 사용할 수 있다.&lt;/li&gt;
    &lt;li&gt;하지만 가독성이 떨어지기 때문에 사용을 많이 하지는 않고 ES6 문법에 이러한 부분들을 해결할 메서드들이 도입되기 시작했기 때문에 그것들을 사용하면 더 좋을 것 같다!&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;-bind&quot;&gt;🌱 bind&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;bind는 call과 비슷하지만 바로 함수가 호출되는 call과 다르게 새로운 함수를 반환하기만 하는 메서드다.&lt;/li&gt;
  &lt;li&gt;bind로 함수와 임의의 객체를 묶어두어 변수에 할당하면, 후에 변수를 함수처럼 호출하면 묶어뒀던 객체가 바인딩된 함수를 호출할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/this.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/this.html</guid>
        
        <category>javascript</category>
        
        <category>CoreJavaScript</category>
        
        <category>this</category>
        
        <category>call</category>
        
        <category>apply</category>
        
        <category>bind</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[JavaScript] 실행 컨텍스트</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;실행 컨텍스트(Excution context)의 개념입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트란&quot;&gt;실행 컨텍스트란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트-동작-원리&quot;&gt;실행 컨텍스트 동작 원리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트의-구조&quot;&gt;실행 컨텍스트의 구조&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-호이스팅hoisting&quot;&gt;Hoisting&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-예제&quot;&gt;예제&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-scope&quot;&gt;Scope&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트란&quot;&gt;📌 실행 컨텍스트란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수, 함수, 매개 변수등 환경 정보들을 수집하여 모아놓은 객체&lt;/li&gt;
  &lt;li&gt;Variable Environment, Lexical Environment, thisBinding으로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트-동작-원리&quot;&gt;📌 실행 컨텍스트 동작 원리&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-사전에-알아야할-cs지식&quot;&gt;🌱 사전에 알아야할 CS지식&lt;/h3&gt;

&lt;h4 id=&quot;-stack&quot;&gt;○ Stack&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Stack은 출구가 하나뿐인 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 쌓아 저장했다면, 데이터를 꺼낼 때는 역순으로 꺼내야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/stack.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;-queue&quot;&gt;○ Queue&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Queue는 양쪽이 모두 열려있는 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 저장했다면, 순서대로 데이터를 꺼낼 수 있는 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-그래서-실행-컨텍스트는&quot;&gt;🌱 그래서 실행 컨텍스트는?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;실행할 코드에 필요한 환경 정보들을 모아 놓은 실행 컨텍스트는 일반적으로 함수가 호출될 때 구성된다.&lt;br /&gt;
(전역은 코드가 실행되는 즉시 전역 환경 정보들을 모아 놓는다.)&lt;/li&gt;
  &lt;li&gt;전역을 첫번째로, 함수가 호출되면 각각 콜스택에 쌓인다.&lt;br /&gt;
(이 때, 콜스택에 쌓이면 해당 변수나 함수를 할당하다가 또다른 실행컨텍스트가 생기면 할당하던 컨텍스트는 잠시 중지된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트의-구조&quot;&gt;📌 실행 컨텍스트의 구조&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 크게 3가지로 구성되어 있다. (ThisBinding은 다음에 공부..!)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Variable Environment &lt;br /&gt;
실행 컨텍스트가 환경 정보를 수집하는 최초의 값을 유지하며 담는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lexical Environment &lt;br /&gt;
Variable Envionment에 정보를 담은 후, Variable Environment를 토대로 Lexical Environment를 만든다. Lexical Environment는 Variable Environment와 다르게 환경 정보의 변경 값을 적용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Variable Environment와 Lexical Environment는 또 environmentRecord, outerEnvironmentReference로 구성되어 있다.&lt;/li&gt;
    &lt;li&gt;environmentRecord가 실행 컨텍스트의 환경 정보 수집하는 역할을 이행하는 역할을 맡고 있다&lt;/li&gt;
    &lt;li&gt;outerEnvironmentReference는 만약 해당 컨텍스트에서 참조해야하는 정보가 없을 경우 제일 근접한 상위 컨텍스트의 Lexical environment를 참조하는 역할을 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;-호이스팅hoisting&quot;&gt;🎈 호이스팅(Hoisting)?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;호이스팅은 선언한 변수들이 위치와 상관없이 제일 상단에 선언되어 변수나 함수를 호출할 수 있는 현상을 말한다.
실제로 코드가 제일 상단에 올라가는 것이 아니라, 코드가 실행되면 실행 컨텍스트가 만들어지고 환경 정보를 수집하는데 자바스크립트 엔진은 환경 정보로 수집한 변수명들을 먼저 알게 되는 것이다. 이 과정을 호이스팅이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-예제&quot;&gt;📌 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
function b() {
    function c() {
        console.log(a);
        var a = 1;
    }
    c();
    console.log(a);
}
b()
console.log(a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;전역 실행 컨텍스트가 형성되고 변수 a와 함수 b를 환경 정보에 저장했다. / 콜스택에 전역 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;변수 a에 1을 할당하고, b에 함수를 할당하고 함수를 호출한다. / 콜스택에 함수 b의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 b의 환경 정보로 변수 c에 함수가 할당되어 저장된다.&lt;/li&gt;
  &lt;li&gt;함수 b안에 함수 c가 호출되었다. / 콜스택에 함수 c의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 c안에 환경 정보로 a가 선언되어 호이스팅 되었다. / c안의 console은 호이스팅된 a를 가리키기 때문에 호이스팅으로 선언만 된 a를 undefined를 가진다.&lt;/li&gt;
  &lt;li&gt;함수 c의 실행 컨텍스트가 종료됨으로 b의 실행 컨텍스트로 넘어간다. / 함수 b의 console.log(a)는 해당 컨텍스트 안에 a가 없기 때문에, outerEnvironmentReference로 인해 a를 가지고 있는 제일 근접한 상위 컨텍스트의 Lexical Environment를 참조하려 한다. (정확히는 해당 컨텍스트가 실행되기 전 Lexical Environment를 참조한다.)&lt;/li&gt;
  &lt;li&gt;마침 전역에 a가 있으므로 함수 b의 console.log(a)는 1값을 가진다.&lt;/li&gt;
  &lt;li&gt;b의 실행 컨텍스트가 종료되고 전역 console.log(a)는 마지막 전역에 있는 a를 참조하여 1값을 가진다. / 전역 실행 컨텍스트가 완료되어 종료됨으로 콜스택에는 아무것도 남아있지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-scope&quot;&gt;🎈 Scope&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;scope는 쉽게 말해 변수의 유효 범위이다. 실행 컨텍스트와 가리키는 범위는 같지만, 스코프는 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정하는 것이 목적이다.
위의 예시에 있는 outerEnvironmentReference가 상위 Lexical Environment를 참조하게되는 연결점, 외부 실행 컨텍스트에서 내부 실행 컨텍스트에 저장된 변수들은 접근할 수 없는 것, 이러한 것들을 스코프 체인이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수나 함수같은 환경 정보들을 모아놓은 객체이다.&lt;/li&gt;
  &lt;li&gt;실행 컨텍스트의 정보들은 순서에 따라 콜스택 형태로 저장되고 호출된다.&lt;/li&gt;
  &lt;li&gt;호이스팅은 컨텍스트와 연관이 있으며, 코드가 실행되기 전 환경 정보를 저장하여 미리 변수명 등을 알게되는 자바스크립트 엔진에 의해 일어난다.&lt;/li&gt;
  &lt;li&gt;스코프는 실행 컨텍스트가 접근할 수 있는 변수나 함수들에게 순서를 부여하는 역할이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/excutionContext.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/excutionContext.html</guid>
        
        <category>javascript</category>
        
        <category>CoreJavaScript</category>
        
        <category>ExcutionContext</category>
        
        <category>LexicalEnvironment</category>
        
        <category>VariableEnvironment</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Two Pointer</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;1차원의 배열에서 2개의 포인터를 주어 풀어내는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-two-pointer란&quot;&gt;Two Poiner란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-two-pointer란&quot;&gt;📌 Two Pointer란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;의미 그대로 2개의 포인터를 가진다.&lt;/li&gt;
  &lt;li&gt;1차원 배열에 포인터를 2개를 두어 각각 포인터들을 사용해 순차적으로 비교할 수 있다.&lt;/li&gt;
  &lt;li&gt;이중 for문을 사용해도 되지만, 이중 for문은 시간복잡도가 O(N&lt;sup&gt;2&lt;/sup&gt;)이고 Two Pointer는 O(N)이어서 시간적으로 효율이 더 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 두 배열을 오름차순으로 합치는 알고리즘을 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr1 = [1, 3, 5];
let arr2 = [2, 3, 4, 6, 8];

const twoPointer = (arr1, arr2) =&amp;gt; {
   let answer = [];
   let i = z = 0;

    while(i &amp;lt; arr1.length &amp;amp; z &amp;lt; arr2.length) {
       if(arr1[i] &amp;lt; arr2[z]) {
           answer.push(arr1[i++]);
       }
       if(arr1[i] &amp;gt; arr2[z]) {
           answer.push(arr2[z++]);
       }
       if(arr1[i] === arr2[z]) {
        answer.push(arr1[i++], arr2[z++])
       }
   }

   while(i &amp;lt; arr1.length) answer.push(arr1[i++]);
   while(z &amp;lt; arr2.length) answer.push(arr2[z++]);

   return answer;
}

twoPointer(arr1, arr2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 concat으로 합친다음 sort으로 정렬해도 되는 문제라고 생각이 든다.&lt;/li&gt;
  &lt;li&gt;하지만 sort는 최악의 경우 O(N&lt;sup&gt;2&lt;/sup&gt;)이 될 수 있기 때문에 시간복잡도 측면에서는 효율이 좋지 못하다.&lt;/li&gt;
  &lt;li&gt;Two Pointer 알고리즘은 포인터가 배열의 끝에 다다르면 마무리되기 때문에 시간복잡도 측면에서 sort보다 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-toPointer.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-toPointer.html</guid>
        
        <category>algorithm</category>
        
        <category>TwoPointer</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[TypeScript] 기초 개념</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;TypeScript의 기본 타입 종류에 대한 포스트입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;목차&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-typescript란&quot;&gt;TypeScript란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-basic&quot;&gt;Basic&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-변수-지정&quot;&gt;변수 지정&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-변수-지정2&quot;&gt;변수 지정2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-typescript란&quot;&gt;📌 TypeScript란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 사용하는 JavaScript는 Runtime 언어, 즉 동적 언어이다.&lt;br /&gt;
동적 언어란 실행될 때 변수의 타입이 결정되기 때문에 사용자가 오류를 그대로 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만 TypeScript는 정적 언어이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정적 언어란 컴파일될 때 변수의 타입이 결정되기 때문에 실행 전에 오류를 볼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;언뜻보면 동적 언어가 자동으로 변수의 타입을 정해주기 때문에 정적 타입보다 동적 타입이 좋아보일 수 있지만…&lt;/li&gt;
  &lt;li&gt;개발자가 의도하지 않았던 동작까지 동적 언어가 처리할 가능성이 있기 때문에 정적 언어로 바꾸어주어 안전하게 코드를 관리하는 것이 선호되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이러한 이유로 TypeScript를 Project에 적용시키는 것이 증가하고 있는 추세이다.📈&lt;/p&gt;

&lt;h2 id=&quot;-basic&quot;&gt;📌 Basic&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-변수-지정&quot;&gt;🌱 변수 지정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 변수를 지정하는 것은 간단하다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const num = 1;
=&amp;gt; const num: number = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이런 식으로 변수옆에 변수가 무슨 타입의 데이터를 가지는지 명시해주는 것이다.&lt;br /&gt;
(Boolean, string, undefined, null 등이 있을 것이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-변수-지정2&quot;&gt;🌱 변수 지정2&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;일반적인 기본형 데이터 타입으로 보지 못했던 것들이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-unknown&quot;&gt;1. unknown&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: unknown = 0;
a = 'hello';
a = '2';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;아직 값이 정해지지 않았을 경우 unknown을 사용한다.&lt;/li&gt;
  &lt;li&gt;TypeScript에서 JavaScript의 라이브러리를 사용할 경우 간혹 사용되곤 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-any&quot;&gt;2. any&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: any = 0;
a = 'hello';
a = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;any도 unknown과 기능적으로는 비슷하지만 의미론적으로 다르다.&lt;/li&gt;
  &lt;li&gt;any는 표현 그대로 ‘아무거나 다 가능!’이다.&lt;/li&gt;
  &lt;li&gt;TypeScript 자체가 정적 언어인데 이러한 특성을 무너뜨리는(?) 특성으로 잘 사용되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-void&quot;&gt;3. void&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;void는 함수에서 아무것도 리턴되지 않는 경우를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function hello():void {
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;hello함수는 현재 아무것도 return하고 있지 않다..!&lt;/li&gt;
  &lt;li&gt;이럴 경우 함수의 값으로 void를 선언해주는데, void는 생략이 가능하다! 그래서 이 부분은 각 사마다의 컨벤션에 따라서!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-never&quot;&gt;4. never&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;never는 함수가 에러를 리턴하거나 리턴 값 자체를 내보내지 않는 경우(무한 루프)에 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function error(): never {
    throw new Error(message);
    while(true) {console.log('infinity loop')}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5-object&quot;&gt;5. object&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;object는 데이터 타입이 object일 경우에 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function obj(obj: object) {
}
obj({one: 1});
obj({two: 2});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addNum(num1: number, num2: number2): number {
    return num1 + num2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이렇게 각 함수의 매개변수에도 number로 선언해줄수 있고 함수에 대한 return값의 타입도 지정해 줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript의 함수에서는 지정된 매개변수를 일일히 선언해주지 않으면 에러가 일어난다.&lt;/li&gt;
  &lt;li&gt;때문에 만일 함수에 매개변수의 값을 넘겨주지 않고 싶을 때는 &lt;b&gt;Optional parameter&lt;/b&gt;로 지정해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function printName(firstName: string, lastName?: string): string {
    console.log(firstName);
    console.log(lastName);
}
printName(SuYeon, Kim);
printName(SuYeon)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이렇게 매개 변수 뒤에 ?를 붙여주면 그 매개변수는 전달해주지 않아도 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수의 매개변수에 전달되는 값이 없을 경우 default값도 지정해줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function greeting(message: string = 'hello') {
    console.log(message);
}
greeting();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수 매개변수의 타입이 일정할 때, 특정 개수가 지정되지 않고 여러개를 할당하고 싶으면 Rest parameter를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addNum(...numbers: number[]): number {
    return numbers.reduce((a, b) =&amp;gt; a + b);
}
console.log(addNum(1, 2)); // 3
console.log(addNum(1, 2, 3)); //6
console.log(addNum(1, 2, 3, 4, 5, 6, 7)); // 28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;array에서도 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const students: string[] = ['철수', '영희'];
const scores: Array&amp;lt;number&amp;gt; = [1, 2, 3];

function printArray(students: readonly string[]) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;보통 string[]로 할 수 있지만 Array&lt;number&gt;같이 선언할 수도 있다.&lt;/number&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 여기서 readonly는 선언 시, 생성자 내부에서만 값을 할당할 수 있다.(불변성을 가질 수 있다!)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript는 정적 언어이기 때문에 코드의 오류를 최소화하기 위한 목적을 가지고 사용한다.&lt;/li&gt;
  &lt;li&gt;각 변수의 데이터 값에 맞는 타입을 선언해주어야 한다.&lt;/li&gt;
  &lt;li&gt;함수에도 여러 가지 기능들을 활용하며 TypeScript를 사용하자!&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/basicType.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/basicType.html</guid>
        
        <category>typescript</category>
        
        <category>TypeScript</category>
        
        <category>basic</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[TypeScript] Alias Union Discriminated Intersection</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Alias Union Discriminated Intersection에 관한 포스트입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-alias&quot;&gt;Alias&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-union&quot;&gt;Union&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-discriminated&quot;&gt;Discriminatedd&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-alias&quot;&gt;📌 Alias&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 number, string같은 데이터를 각 타입에 맞게 선언해주었다면(ex.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const a:number = 1&lt;/code&gt;), Alias는 사용자가 직접 type을 만들어주는? 이라고 이해할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-type-alias&quot;&gt;1. Type Alias&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Greeting = string;
type Num = number;

const hi: Greeting = 'hi';
const hello: Greeting = 'hello';

// 객체에도 가능하다.
type Greeting = {
    time: number;
    greeting: string;
}
const obj: Greeting = {
    time: 8,
    greeting: 'hello'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-string-literal-types&quot;&gt;2. String Literal Types&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;위와 같이 타입을 지정해줄 수 있지만, 하나의 문자열을 지정해줄 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type name = 'suyeon';
let me: name;
me = 'suyeon'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-union&quot;&gt;📌 Union&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Union은 Alias의 확장판(?)의 느낌이다.&lt;/li&gt;
  &lt;li&gt;한가지 타입만 지정하는 String Literal Types와 달리 하나 이상의 데이터들을 지정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Direction = 'left' | 'right' | 'up' | 'down'
function go(direction: Direction) {
    console.log(direction);
}
go('up')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;저렇게 or연산자로 여러가지를 선언해주면 Direction이라는 Alias로 지정한 up, down, left, right라는 4가지의 데이터들을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-discriminated&quot;&gt;📌 Discriminated&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Discriminated는 복수의 타입에 공통된 메소드 등을 사용할 수 있도록 각 타입에 공통된 값을 넣어주는 것을 말한다.&lt;/li&gt;
  &lt;li&gt;아래의 예제에서는 각 타입마다 result를 넣음으로써 printLoginState 함수에서 state.result로 한번에 검사할 수 있게 되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type SuccessState = {
    result: 'success';
    response: {
        body: string;
    };
}
type FailState = {
    result: 'fail';
    reason: string;
}
type LoginState = SuccessState | FailState;
function printLoginState(state: LoginState) {
    if(state.result === 'success') {
        console.log(state.result);
    }
    if(state.result === 'fail') {
        console.log(state.result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-intersection&quot;&gt;📌 Intersection&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Intersection은 간단히 말해 type Alias를 합치는 것으로 연산자 &amp;amp;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type wecoder1 = {
    name1: 'sy';
    name2: 'ym';
    name5: 'dh';
}

type wecoder2 = {
    name3: 'ds';
    name4: 'mh';
}

function werecordTeam(person: wecorder1 &amp;amp; wecorder2) {
    console.log(person.name1, person.name2, person.name3, person.name4, person.name5);
}

werecordTeam({
    name1: 'sy',
    name2: 'ym',
    name3: 'ds',
    name4: 'mh',
    name5: 'dh',
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 29 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/alias.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/alias.html</guid>
        
        <category>typescript</category>
        
        <category>TypeScript</category>
        
        <category>Alias</category>
        
        <category>Union</category>
        
        <category>Discriminated</category>
        
        <category>Intersection</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[JavaScript] Data Type</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;[Core JavaScript] Data Type에 대한 개념와 작동 원리입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-data-type&quot;&gt;Data Type&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-data-할당-원리&quot;&gt;Data 할당 원리&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-가변성과-불변성&quot;&gt;가변성과 불변성&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-얕은-복사-깊은-복사&quot;&gt;얕은 복사와 깊은 복사&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-복사를-하는-이유&quot;&gt;복사를 하는 이유&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-그래서-얕은-복사-깊은-복사가-머야&quot;&gt;그래서 얕은 복사, 깊은 복사가 머야?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-data-type&quot;&gt;📌 Data Type&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScrip의 데이터 타입은 크게 기본형(primitive), 참조형(reference)으로 나뉜다.&lt;/li&gt;
  &lt;li&gt;기본형에는 String, Number, Boolean, Null, undefined, Symbol 등으로 나뉜다.&lt;/li&gt;
  &lt;li&gt;참조형에는 Object, Array, Function, Date 등으로 나뉜다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본형과 참조형은 가변성인지, 불변성인지에 따라 나뉘게 되는데, 가변성과 불변성을 이해하려면 약간의 컴퓨터 메모리에 대한 지식이 필요하다. (추후에 자세하게 공부할 것!)
=&amp;gt; 결론적으로 변수와 식별자는 메모리 고유의 주소값에 저장되고 그것을 참고하는 식으로 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;-data-할당-원리&quot;&gt;🌱 Data 할당 원리&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 6
let b = 'hello'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 형태로 변수가 선언되면 이 메모리들은 각각 컴퓨터 메모리에 이렇게 저장된다.
&lt;img src=&quot;/assets/img/javascript/dataType.png&quot; width=&quot;300px&quot; height=&quot;200px&quot; /&gt; (글씨 어떻할거야…💩)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;저 코드가 메모리에 영향을 끼치는 순서를 순서대로 나열하자면…&lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;변수명 a가 선언된다. -&amp;gt; 메모리 주소 1001번에 a가 저장된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;변수명 a에 6이 할당된다. -&amp;gt; 기존에는 undefined, 6은 곧바로 a의 주솟값인 1001에 저장되는 것이 아니라 새로운 주소 5001에 할당되고 1001에는 a의 값으로 5001주소가 참조된다. (a가 6을 가지고 있는 메모리 영역을 검색해서 찾는 원리)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;위의 순서가 변수 b에 똑같이 적용된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 변수 데이터가 기본형일 경우 이러한 원리로 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;위에서는 데이터 타입이 기본형이었다. &lt;br /&gt;
그렇다면 참조형 데이터는 기본형의 원리와는 다른가??&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;a는 객체로 할당했다. 이것은 다음과 같다. &lt;br /&gt;
&lt;img src=&quot;/assets/img/javascript/dataType2.png&quot; width=&quot;500px&quot; height=&quot;200px&quot; /&gt; (글씨 어떻게 할거냐고…💩)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;참조형은 기본형과는 다르게 객체 데이터에 대한 주소를 한번 더 참조한다.&lt;/li&gt;
  &lt;li&gt;a라는 변수명을 1001에 할당하고난 뒤에 값은 5001 주소에 저장하지만, 객체 안에 one, two의 변수명들은 따로 7001에 저장시킨다.&lt;/li&gt;
  &lt;li&gt;이것으로 그치는 것이 아니라 각각 one, two에 할당된 1, 2는 아까 기본형 데이터와 같이 다른 메모리 주소에 저장되고 one, two의 값은 그 주소가 할당된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이 기본형과 참조형의 데이터 저장 스타일이 각기 다르기 때문에 앞으로 여러 이슈들이 발생한다. (가변성과 불변성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-가변성과-불변성&quot;&gt;📌 가변성과 불변성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가변성과 불변성은 한마디로 정의하면 데이터 변환의 가능여부에 따라 나뉘는 것이 아니다.&lt;/li&gt;
  &lt;li&gt;데이터를 변환했을 때 원래 값이 해당 주소에서 다른 값으로 갱신되는지의 여부에 따라 달라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 1
let b = a
a = 2
console.log(a === b) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let c = {one: 1, two: 2}
let d = c
c.one = 3
console.log(c === d) // true..?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;기본형과 참조형의 개념을 모른다면 위의 코드에서 이상한 점을 느꼈을 것이다.&lt;/li&gt;
    &lt;li&gt;각 마지막 console에서 a와 b는 false가 맞는 것 같은데 c와 d는 왜 true일까??&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;이것이 불변성의 특징이다. a는 1 데이터의 주소를 할당받았고 b는 a의 1 데이터의 주소를 할당받았다.&lt;/li&gt;
  &lt;li&gt;그리고 a는 2로 다시 재할당받았는데…! 여기서!! 중요한 점은 b는 데이터의 주소가 변경되지 않았다는 것이다.&lt;/li&gt;
  &lt;li&gt;그렇다는 것은 b가 할당받고 있는 데이터의 주소에는 1이 있다는 것!! 1은 a가 2로 바뀌었다고 해서 사라지지 않았다!! ⭐️&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이것으로 기본형은 모두 불변성의 특징을 가지고 있다고 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;마찬가지로 c와 d또한 위와같은 플로우를 가진다.&lt;/li&gt;
  &lt;li&gt;하지만 c와 d는 한단계 더 깊게 들어간다. 위의 객체가 데이터 저장하는 원리에서 나온 것처럼 말이다.&lt;/li&gt;
  &lt;li&gt;즉, b와 c는 객체 전체에 대한 주소를 할당받고, 객체 전체에 대한 주소에서의 프로퍼티 요소은 하나하나 다른 데이터 영역에 저장되기 때문에 참조하는 데이터 범위를 할당받는다.&lt;/li&gt;
  &lt;li&gt;이 때!!! 객체 안에 프로퍼티들이 다른 데이터로 재할당받게 되는 경우!!(위에 c.one = 3같은…).. 이 경우는 위의 예시와는 다르게 참조하고 있는 범위 안의 데이터가 바뀌게 된다.&lt;/li&gt;
  &lt;li&gt;하지만 처음 c와 d의 주솟값은 변하지 않았기 때문에 c와 d는 일치로 나오는 것이다! (이 부분은 추후에 공부하기..!)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;만일 참조형 데이터 안에 또 참조형 데이터가 있다면..?&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: [1, 2, 3]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 경우는 조금 더 복잡할 뿐..! 위의 예시를 적용시키면 가능하다!&lt;/li&gt;
  &lt;li&gt;a의 변수와 함께 객체의 주소가 함께 할당된다. -&amp;gt; 객체의 주소에는 각 데이터들을 참조하는 영역을 할당받는다. -&amp;gt; two에서는 two라는 변수와 [1, 2, 3]을 담는 배열의 주소값을 할당받는다. -&amp;gt; 각 프로퍼티의 index가 이름이 되고 그에 대한 값으로 1, 2, 3이 각각 할당된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이러한 특징들로 보아 참조형 데이터는 프로퍼티 값들만 변경되었을 경우 데이터 주소는 변하지 않으므로 &lt;b&gt;‘가변’&lt;/b&gt;의 특징을 가지는 것이다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;참조형-데이터가-불변일-경우&quot;&gt;참조형 데이터가 불변일 경우?&lt;/h6&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: 2}
let b = a
let a = {three: 3, four: 4}
console.log(a === b) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이 경우에는 a가 three, four라는 프로퍼티를 가진 값들의 주소를 재할당받은 것이기 때문에 &lt;b&gt;‘불변’&lt;/b&gt;의 특징을 가진다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-얕은-복사-깊은-복사&quot;&gt;📌 얕은 복사, 깊은 복사&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-복사를-하는-이유&quot;&gt;🌱 복사를 하는 이유!&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;원본 데이터를 사용할 때 주의해야할 점이 있다. 바로 원본 데이터가 수정되는가 안되는가의 여부이다.&lt;/li&gt;
  &lt;li&gt;‘왜? 원본 데이터가 수정되면 안되는가?’에 의문이 들 수 있지만, 사실 간단한 이유이다.&lt;/li&gt;
  &lt;li&gt;원본 데이터를 한차례 수정하게 되었을 경우, 다음에 원본 데이터를 사용하려면 수정된 데이터를 감안하고 사용해야한다.&lt;/li&gt;
  &lt;li&gt;그렇게 누적이 되다보면 원본데이터에 무슨 데이터가 있는지 확실하게 알지 못하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 따라서 원본데이터는 자체로 불변성을 지니는 것이 좋다!&lt;/p&gt;

&lt;h3 id=&quot;-그래서-얕은-복사-깊은-복사가-머야&quot;&gt;🌱 그래서 얕은 복사, 깊은 복사가 머야?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;얕은 복사 : 객체 프로퍼티 안에 객체 프로퍼티가 있는 경우, 제일 상위의 객체만 복사되고 하위의 객체 프로퍼티는 원래 그대로의 주솟값을 가지는 것&lt;/li&gt;
  &lt;li&gt;깊은 복사 : 객체 프로퍼티 안에 있는 모든 경우의 값들을 새로운 주소에 할당하는 것&lt;br /&gt;
객체 프로퍼티 내부에 하위 객체가 값으로 지정되어 있는 경우 위와 같은 가변성을 띈 객체로 되기 때문에 일일히 불변성을 가진 객체로 만들어주어야한다. (&lt;a href=&quot;#-가변성과-불변성&quot;&gt;가변성과 불변성&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 얕은 복사, 깊은 복사에 대한 코드소개는 생략한다. 대신 불변 객체를 만들어주는 라이브러리를 소개로 마치려 한다.(immer.js, immutable.js, baobab.js)&lt;/p&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 타입에는 기본형, 참조형이 있다.&lt;/li&gt;
  &lt;li&gt;기본형은 자체로 불변성을 띄지만, 참조형은 상황에 따라 불변성을 띌 수도 가변성을 띌 수도 있다.&lt;/li&gt;
  &lt;li&gt;참조형 데이터를 불변 객체로 만들기 위해서는 그에 맞는 함수를 구현하거나 라이브러리(immer.js, immutable.js, baobab.js 등)을 사용해야 한다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 28 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/dataType.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/dataType.html</guid>
        
        <category>javascript</category>
        
        <category>CoreJavaScript</category>
        
        <category>DataType</category>
        
        <category>mutable</category>
        
        <category>immutable</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>[Algorithm] Brute Force</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;알고리즘 완전 탐색 브루트 포스의 개념과 원리, 간단한 사용 예제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-brute-force란&quot;&gt;Brute Force란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제-javascript&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리하자면&quot;&gt;정리하자면!&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-brute-force란&quot;&gt;📌 Brute Force란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Brute Force의 Brute는 짐승, 난폭한,,이란 뜻과 Force가 만나 난폭한 힘.. 이런 느낌인 자료탐색방법인데 간단히 말하면 “너가 멀 좋아할지 몰라서 일단 다 준비해봤어..”이거다. 🤪&lt;/li&gt;
    &lt;li&gt;Brute Force의 자료구조의 종류로는 2가지(선형구조 - 배열, 연결리스트 등, 비선형구조 - DFS, BFS)가 있다!! &lt;br /&gt;(다음엔 자료구조도 공부해보아야겠다!!)&lt;/li&gt;
    &lt;li&gt;주어진 값을 구하기 위해서 모든 경우를 탐색하기 때문에 시간복잡도는 경우가 늘어날 때마다 기하급수적으로 늘어난다. &lt;br /&gt; 일반적으로 컴퓨터는 1초에 평균 1억번 정도의 연산이 가능하기 때문에 1000억번의 연산을 수행한다면 &lt;b&gt;17분&lt;/b&gt;이 소요된다./&lt;/li&gt;
    &lt;li&gt;시간적인 측면에서는 비효율적이지만, 사용하기 쉽고 모든 경우를 탐색하기 때문에 &lt;b&gt;100%&lt;/b&gt; 답을 찾는 것이 가능하다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-사용-예제-javascript&quot;&gt;📌 사용 예제 (JavaScript)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 소수를 찾는 문제로 Brute Force를 알아보자! &lt;br /&gt; (자료구조는 배열을 사용하여 진행!)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = arr =&amp;gt; {
   let answer = []

   for(let i of arr) {     --- (1)
       let s = []
       for(let z = 1; z &amp;lt;= i; z++) {    --- (2)
           if(i % z === 0) s.push(z);
       }
       if(s.length === 2) answer.push(s[s.length - 1])
   }
   return answer
}

question([3, 2, 4, 6, 9, 11, 129, 127])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;효율적인 코드인지는 잘 모르겠지만.. 간단하게 살펴보면!&lt;/li&gt;
  &lt;li&gt;(1)번과 (2)으로 의도한 것은 (1)번으로 arr에 있는 값을 하나씩 하위 for문으로 전달해주고, (2)에서는 (1)에서 받은 숫자 i를 1부터 i번까지 전부 탐색한다.&lt;/li&gt;
  &lt;li&gt;i와 i 아래의 모든 값들을 %로 구해서 0이 나오면 만들어 놓은 배열에 저장시키고, 하위 for문이 끝나면 배열의 요소를 검사해 length가 2개이면 answer 배열에 넣어서 return한다. (소수는 1과 자신만 약수로 가지기 때문!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-정리하자면&quot;&gt;📌 정리하자면!&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Brute Force(완전탐색)은 모든 경우의 수를 탐색한다.&lt;/li&gt;
  &lt;li&gt;답은 확실하지만, 시간적인 소요가 크다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 26 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devlog/algorithm-bruteForce.html</link>
        <guid isPermaLink="true">http://localhost:4000/devlog/algorithm-bruteForce.html</guid>
        
        <category>algorithm</category>
        
        <category>BruteForce</category>
        
        <category>완전탐색</category>
        
        
        <category>devlog</category>
        
      </item>
    
      <item>
        <title>Werecord project 🔥</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;A-Z까지 모두 경험했던 We-record 프로젝트!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-a-z까지&quot;&gt;A-Z까지&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-위대한-첫걸음-&quot;&gt;위대한(?) 첫걸음&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-we-record의-탄생-&quot;&gt;we-record의 탄생&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-blocker벌써&quot;&gt;Blocker…(벌써…?)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-중간-점검&quot;&gt;중간 점검&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-본격적인-개발&quot;&gt;본격적인 개발&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-내가-맡은-task&quot;&gt;내가 맡은 Task&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-각-페이지-소개&quot;&gt;각 페이지 소개&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-예상치-못한-감사&quot;&gt;예상치 못한 감사&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-error--fix&quot;&gt;Error &amp;amp; Fix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-끝-그리고-시작&quot;&gt;끝 그리고 시작&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-a-z까지&quot;&gt;📌 A-Z까지…&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;🚌 기간 : 6월 8일 ~ 7월 16일 &lt;br /&gt;
👥 Front-end : 3명, Back-end : 2명
💻 사용된 기술 스택 : React Hooks, React Router, Styled-Component, KAKAO social login, RESTful API&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-위대한-첫걸음-&quot;&gt;🌱 위대한(?) 첫걸음 👣&lt;/h3&gt;

&lt;p&gt;2차 프로젝트 이후 기업협업과 개인 프로젝트.. 둘중 하나를 택하는 기로에 놓였고, 당연히 기업협업으로 가게 될 것이라는 생각과는 다르게 한번 더 팀으로 프로젝트를 진행하게 되었다..😳&lt;/p&gt;

&lt;p&gt;처음에는 갑작스럽게 팀 프로젝트로 바뀌어서 당황했지만, 이내 곧 마음을 다잡고 1달이라는 시간동안 어떻게 해야 알차게 보낼지 팀원들과 머리를 싸매고..(지끈..🤮) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for(let i = 0; i &amp;lt; MAX.SAFE.INTEGER; i++) {return 고민}&lt;/code&gt;을 거듭했다. (탈모 생길거 가틈)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-we-record의-탄생-&quot;&gt;🌱 we-record의 탄생 👶🏻&lt;/h3&gt;

&lt;p&gt;그동안 배운 코딩을 사용해서 무엇을 만들어야할지… 처음으로 ‘무언가를 스스로 만든다’라는 고민을 해보았던 것 같다. 사이트를 모티브로 한 2번의 프로젝트 때와 달리 신선한 고민으로 다가왔지만, 첫 시작은 막막하기도 해서 내심 걱정이 들었다… 하지만 이런 걱정은 기우였을까?? 우려했던 것과는 달리 우리 팀은 제대로 해보겠다는 의지가 불타오르고 있었다🔥&lt;/p&gt;

&lt;p&gt;프로젝트 포인트는 ‘우리 주변에 무언가가 필요했던 상황이 있었나??’를 중점으로 고민했던 것 같다. 그러던 중 마침 기업협업을 나갔던 동기분 한분이 회사 근태 사이트를 구현한다는 소식을 접하게 되면서.. “어라?? 나도 위코드에 있었을 때 출석부 필요했는데…” 생각으로 이어지고 팀원분들의 다양한 의견을 종합해본 결과!! Werecord가 탄생하게 되었다!! (두둔!🥁)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-planing.png&quot; alt=&quot;werecord&quot; /&gt; - 기획기획..끄적끄적…
&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-planing2.jpg&quot; alt=&quot;werecord&quot; /&gt; - 팀원들 머리 속 깊숙히 박혀있는 아이디어 한톨까지 뽑아낸 결과물..! (feat.동기분들 응원 🙈)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-blocker벌써&quot;&gt;🌱 Blocker…(벌써..?)&lt;/h3&gt;

&lt;p&gt;기획까지 너무 좋았다. 사실은 걱정도 잠시, 이것저것 아이디어를 가지고 페이지를 기획하는 과정은 생각보다 재미있었다. 그렇게 분명한 사이트의 목적에 어울리는 여러 아이디어를 뽑았다.&lt;/p&gt;

&lt;p&gt;개발사전에 한번 내뱉은 말은 책임을 져야 한다..라는 말이 있었나..? 아무튼 재미있게, 그리고 진지하게 기획을 마치고 난 이후 우리는 ‘우리가 기획한 프로젝트’를 만들어야했다. ‘아 너무 재미있겠다~~’라고 외쳤던 나에게 다가온 하나의 큰 산… Design…&lt;/p&gt;

&lt;p&gt;나름 전체적인 페이지의 구도를 본다고 생각했지만 이건 좀.. 다른 문제였다. 우리의 아이디어를 페이지에 어떻게 녹여내야할까???의 고민… 주변에 디자인을 전공한 친구들도 없고… 나에게는 다꾸(다꾸 = 다이어리 꾸미기ㅋ) 경력 2년차 여자친구에게 물어보는게 전부였다.&lt;/p&gt;

&lt;p&gt;심호흡을 하고, 마음을 가다듬고 figma를 열었다.
&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-design.png&quot; alt=&quot;werecord&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사전에 노트로 끄적였던 UI를 하나하나 정성스래 잡으면서 작업했다. (세부적인 디자인에 신경써주신 다꾸인(?) 팀원 다*님 고생많으셨습니다👍🏼)&lt;/p&gt;

&lt;p&gt;당연히~ 여러 우여곡절 끝에 만들어진 디자인이지만 그 과정을 여기에 다 거론할 수 없을 것 같아 이쯤에서 넘어가는게 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;(이렇게 기획과 디자인으로만 꼬박 2주라는 시간을 소요했다..)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-중간-점검&quot;&gt;🌱 중간 점검&lt;/h3&gt;

&lt;p&gt;“처음하는 기획, 처음하는 디자인” 등 그동안 배웠던 개발 스택과는 거리가 조금 먼 친구들이지만, 이러한 과정을 직접 경험함으로 느끼는 바가 컸다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생각했던 것과는 달리 기획이 수시로 바뀌어서 정말정말정말 “프로젝트의 중심”을 잘 잡아야한다는..&lt;/li&gt;
  &lt;li&gt;그렇다고 기획의 기능적인 부분만 신경쓰는 것이 아니라 항상 “사용자 편의를 고려”해서 개발해야 한다는..&lt;/li&gt;
  &lt;li&gt;앞으로 현업에서 웹 디자이너와 어떻게 소통해야할지 생각해보는..&lt;/li&gt;
  &lt;li&gt;필수적으로 팀원들과 정기 + 수시로 “소통”해서 프로젝트 방향성을 명확하게 잡아야하는..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등등등 최대한 실제 현업에서 고민해볼 수 있는 사항들을 접하고 싶었는데.. 아마 현업에서도 이러한 고민들을 할 수 있을 것이라 생각해서 괜히 기분이 좋았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-본격적인-개발&quot;&gt;📌 본격적인 개발!&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-내가-맡은-task&quot;&gt;🌱 내가 맡은 Task&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;기수 페이지&lt;/li&gt;
  &lt;li&gt;메인페이지&lt;/li&gt;
  &lt;li&gt;공용 모달 컴포넌트 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;팀원들과 페이지 단위로 task를 분담했다. 물론 각 페이지마다 공통으로 들어갈 컴포넌트가 있다면 재사용할 계획이었지만 각 페이지별로 구현되는 UI가 다 달라서 공용으로 사용되는 컴포넌트가 많지 않았다.&lt;/p&gt;

&lt;p&gt;각 페이지마다 Comment가 추가로 랜더되야하는 것들은 모달을 사용하여 랜더링시키는 것으로 이야기를 나누었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-각-페이지-소개&quot;&gt;🌱 각 페이지 소개&lt;/h3&gt;

&lt;h4 id=&quot;--기수페이지&quot;&gt;- 기수페이지&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-batch.gif&quot; alt=&quot;werecord&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;어려운 코드는 아니지만 이것저것 다양한 데이터를 받고 랜더링 시키는 것이 포인트이다.&lt;/li&gt;
    &lt;li&gt;slider 라이브러리 slick를 사용하여 같은 기수 동기들의 간단한 프로필을 볼 수 있다.&lt;/li&gt;
    &lt;li&gt;오늘 하루 start버튼을 누른 동기는 해당 프로필카드 이름 우측에 빨간 점이 파란 점으로 바뀌게 구현하였다.&lt;/li&gt;
    &lt;li&gt;지박령 순위 단상은 div로 만들고 annimation을 주어 심심하지 않게 구현하였다.&lt;/li&gt;
    &lt;li&gt;모달은 createPotal을 사용하여 전역으로 관리할 수 있게 설계하였다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-batchCode.png&quot; alt=&quot;werecord&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CREAM 프로젝트 모달과는 달리 closet을 활용하여 모달창 바깥에 onClick은 blur처리가 되도록 구현하였다.&lt;/li&gt;
  &lt;li&gt;또한 모달이 필요한 컴포넌트마다 on/off를 동작하게 하는 함수를 선언하는게 아니라 모달 내부에서 해당 모달에 대한 on/off를 컨트롤할 수 있게끔 구현하여 코드를 최소화하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;--메인페이지&quot;&gt;- 메인페이지&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-main.gif&quot; alt=&quot;werecord&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;현재 시간은 setInterval로 구현하여 실시간으로 변경된 시간이 랜더링 되도록 구현하였다.&lt;/li&gt;
    &lt;li&gt;여기서 Blocker를 만나게 되는데.. setInterval로 Main 컴포넌트를 지속적으로 랜더링시키는 것이 다른 함수들 또한 컴포넌트 내에 생성하여 호출하는 것이 서로 엮여 에러를 일으켰다.&lt;/li&gt;
    &lt;li&gt;따라서 다른 함수들은 랜더가 지속적으로 일어나도 초기 함수값을 가진 상태를 유지하여 랜더링 최적화를 진행하는 것이 효율적이라 판단하였다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-mainCode.png&quot; alt=&quot;werecord&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;useMemo, useCallback을 사용하여 함수로 호출된 값을 기억하여 추가적인 랜더링 시에도 새로운 함수로 만들어지지 않도록 구현하였다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;useMemo는 이미 함수로 호출된 값을, useCallback은 Callback함수로 전달할 함수들을 대상으로 React 최적화 hook을 사용했는데 추가적으로 두가지의 사용법에 대해 공부해야할 것 같다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;조금 더 코드를 간소화하여 구현하는 방법이 있을 것 같은데 React랜더링 최적화에 대해 더 공부하여 리팩토링해야할 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-예상치-못한-감사&quot;&gt;🌱 예상치 못한 감사&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로젝트를 진행하던 도중 Wecode의 멘티들을 대상으로 하는 프로젝트를 진행한다는 소문이 돌았던 것 같다. 그렇게 된 것일까.. 멘토님들께서 잘하면 실제로 Wecode 프로그램으로 사용해도 될 것 같다는 엄!청!난! 말씀을 해주셨다!!🤩&lt;/p&gt;

&lt;p&gt;팀원들끼리만 기획하고 남을 것 같던 프로젝트가 실제 서비스될 수도 있다는 생각에 정말 신기했다!
이후로 디자인부분과 기획적인 부분을 멘토님들과 회의를 통해 수정하고 추가하고 보완하게 되었다 :)&lt;/p&gt;

&lt;p&gt;그렇게해서 프로젝트에 새롭게 멘토페이지가 추가되었다!! 멘토페이지는 멘티뿐만 아니라 멘토님들도 가입하여 멘티들을 확인할 수 있는 페이지였다.&lt;/p&gt;

&lt;p&gt;그렇게 werecord 프로젝트는 시즌 2를 맞이하게 되었다!!!🔥&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-error--fix&quot;&gt;📌 Error &amp;amp; Fix&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;앞서 보여진 디자인이나 코드들은 사실 저 당시에 완성되었던 것들이 아니었다. 디자인도 조금 더 투박했고 코드 또한 버그들이 난무했다.&lt;/p&gt;

&lt;p&gt;멘토님께서 werecord 프로젝트를 실제로 사용하는 것을 긍정적으로 검토하시고 난 이후 새로운 숙제를 주셨다..!😂 바로 멘토님들께서 찾으신 에러들, 찌그러지는 UI들을 고치는 일이었다.&lt;/p&gt;

&lt;p&gt;팀원들끼리 모의로 테스트해 보았을 때 꽤나 자신만만했던 것 같다. ‘여기에 버그가 도대체 어디있지?’ 나름 버그를 수정하면서 작업했기에 버그따위.. 없을거라 생각했다. 게다가 규모도 작은 프로젝트이니 더 그렇게 생각했던 것 같다.. 하지만…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-25-werecord/werecord-errorfix.png&quot; alt=&quot;werecord&quot; /&gt; - 엥..?&lt;/p&gt;

&lt;p&gt;버그만 있지는 않고 새로운 페이지들과 기능도 추가되었지만 예상보다 전체적으로 보완되고 수정될 부분들이 있었다는 것이 놀라웠다. (그리고 물론 저게 다가 아니다…ㅎ)&lt;/p&gt;

&lt;p&gt;새롭게 기획에 추가된 Restart버튼과 pause버튼를 구현하게 됨으로 전체적인 데이터 구조를 다시 잡아야했다. 물론 프론트쪽에서는 받는 데이터에 따라서 랜더링만 시켜주면 되겠지만.. 백엔드에서 좀 고생하셨던 것 같다.ㅠㅠ&lt;/p&gt;

&lt;h2 id=&quot;-끝-그리고-시작&quot;&gt;📌 끝 그리고 시작&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;7월 2일부로 공식적인 wecode 커리큘럼이 마무리 되었다. 하지만 여기서 끝날 줄 알았던가… 멘토님께서 2주정도 추가로 디자이너를 붙여주시면 프로젝트를 이어할 마음이 있는지 여쭤보셨다..!
당연히 werecord 프로젝트에 애착이 있던 나와 팀원들… Yes!!를 외쳤던 기억이 난다.😏&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;현재(7월 25일) 여러가지 상황들이 맞물려 프로젝트 기간이 계속 딜레이 되다가 드디어 새로운 디자인 시안이 나오게 되었다. 그런데 생각과는 달리 팀원들과 같이 만들었던 모습은 온데간데 없고 새로운(?) 웹 페이지가 있었다..ㅠㅠ (고생해서 만든건데ㅠㅠ)&lt;/p&gt;

&lt;p&gt;그런데 역시 디자이너는 디자이너인가.. 휠씬 모던하고 보기 좋아서 조금 씁쓸..ㅎ
기능적인 부분도 원래 기획과는 다르게 추가된 것들도 있었고 삭제된 것들도 있었다.
(역시 개발은 클라이언트가 왕이지.. 라는 벌써부터 현업 마인드로 생각하는 것 같아 웃펐다 😂)&lt;/p&gt;

&lt;p&gt;최종으로 수정된 기안들을 우리가 마음대로 쓸 수 있을까 조심스럽게 염려하기도 하고.. 이렇게 우리가 기획하고 디자인하고 개발까지 이어졌던 프로젝트를 남기고 싶었다.&lt;/p&gt;

&lt;p&gt;기회가된다면 최종 기획에 따라 만들어진 웹페이지와 현재 페이지를 비교하고 싶기도 하다!! 리팩토링은 당연히 해야되고!! Werecord 2편에서 다시 만나길…&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/project-review-werecord.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/project-review-werecord.html</guid>
        
        <category>project</category>
        
        <category>werecord</category>
        
        <category>React</category>
        
        <category>근태</category>
        
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>2차 프로젝트 회고 (CREAM)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Wecode 부트캠프에서 진행한 프로젝트 CREAM에 대한 회고록입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-근황&quot;&gt;근황&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-project-cream&quot;&gt;Project CREAM&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#1-기획하는-단계&quot;&gt;기획하는 단계&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-프로젝트-설명&quot;&gt;프로젝트 설명&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며…&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-근황&quot;&gt;📌 근황…&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;2차 프로젝트를 마무리하고 약 한달 반이 지났다. 그동안은 Velog를 이용해왔지만 ‘나만의 블로그를 만들어서 운영하고 싶다..’라는 단순하고도 어리석은(?) 생각으로 github를 이용한 블로깅을 해야지..해야지.. 했던게 지금까지 이어져 왔다.😂&lt;/p&gt;

&lt;p&gt;Wecode 부트캠프를 수료하고 난 이후에 개인적으로 공부하는 기술 스택들을 블로깅하고 싶은 마음에 마음 단단히(?) 먹고 몇일동안 고군분토한 결과… 드디어!! 블로그가 만들어졌다!!🎉
이제 부지런히 밀린 블로깅을 하는 일만 남았다..!&lt;/p&gt;

&lt;h2 id=&quot;-project-cream&quot;&gt;📌 Project CREAM&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;🚌 기간 : 5월 24일 ~ 6월 04일 &lt;br /&gt;
👥 Front-end : 3명, Back-end : 2명
💻 사용된 기술 스택 : React Hooks, React Router, Styled-Component, KAKAO social login, RESTful API&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;팀원들과 함께 신발 경매 사이트 Kream을 모티브로 하여 개발을 진행 &lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;사람들과의 거래 및 경매라는 플로우를 중심으로 한 개발을 목표로 선정&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-기획하는-단계&quot;&gt;1. 기획하는 단계🚶&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;-서비스-파악하기&quot;&gt;🌱 서비스 파악하기&lt;/h4&gt;

&lt;p&gt;CREAM의 특징은 물품 구매자와 판매자 모두 서비스를 이용하는 이용자들이 될 수 있다는 것이다. 그렇기 때문에 서비스를 이용하는 회원들은 물품을 판매하게 되면 물품 값을 받아야하고 구매를 하게 되면 물품 값을 내야했다.&lt;/p&gt;

&lt;p&gt;프로젝트이기 때문에 실제 화폐가 아닌 팀원끼리 사용할 수 있는 가상 활페로 대체하고, 대략적인 플로우를 생각해보았다.&lt;/p&gt;

&lt;p&gt;Kream은 경매로 물품에 대해 입찰만 할 수 있는 것이 아니라 상품에 대한 즉시 구매도 가능했다.
물품에 대한 채결 거래 내역이 실시간으로 갱신되는 것도 chart를 통해서 확인할 수 있었는데, 경매 입찰 거래가와 즉시 구매가, 즉시 판매가에 대한 연결성을 파악해야했다.&lt;/p&gt;

&lt;p&gt;얼마 지나지 않아서 즉시 구매가는 판매 입찰로 나온 물품 중 가장 싼 판매 희망가가 즉시 구매가로 책정이 되고, 즉시 판매가는 구매 입찰에 나온 물품 중 가장 비싼 구매 희망가로 책정된다는 것을 발견하였다.&lt;/p&gt;

&lt;p&gt;또한 구매 입찰을 진행할 때, 만약 구매 입찰가가 즉시 구매가보다 높다면 자동으로 즉시 구매가로 넘어가주어야 했고, 마찬가지로 판매 입찰을 진행할 때, 만약 판매 입찰가가 즉시 판매가보다 낮으면 자동으로 즉시 판매가로 넘어가주어야 했다.&lt;/p&gt;

&lt;p&gt;이러한 거래 플로우를 각 하나의 물품에 대한 여러가지의 사이즈를 고려하여 데이터를 처리해야했기 때문에 생각보다 복잡했고, 팀원들과 의논하며 구현에 집중할 기능들을 하나 둘씩 정리하였다.&lt;/p&gt;

&lt;h4 id=&quot;-내가-맡은-기능&quot;&gt;🌱 내가 맡은 기능&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;제품 상세 페이지 (chart.js 라이브러리 사용, 무한 스크롤 구현)&lt;/li&gt;
  &lt;li&gt;팀원들과 함께 사용할 공용 Modal 구현&lt;/li&gt;
  &lt;li&gt;URLSearchParams를 사용하여 백엔드에서 받는 데이터 필터링 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-프로젝트-설명&quot;&gt;2. 프로젝트 설명🙈&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;-modal&quot;&gt;🌱 Modal&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;WIKEA 프로젝트 때 팀원이셨던 분께서 공용 모달로 만드셨던 기억을 떠올려 스스로 구현해보았다.&lt;/li&gt;
  &lt;li&gt;가장 큰 모달창만 구현을 하고 모달 내부에 들어갈 데이터 요소들은 하위 컴포넌트로 구현하기로 기획하였다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여기서 등장하는 모달들은 내부에 있는 데이터만 다르고 모두 같은 컴포넌트로 구현하였다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-modal.gif&quot; alt=&quot;modal&quot; /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-modalCode.png&quot; alt=&quot;modalCode&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;간단해보이는 modal이다. 모달의 on/off를 상위 컴포넌트의 state로 관리해주고, 내부 데이터들을 children으로 받아서 랜더링시켜준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;-chart--infinity-scroll&quot;&gt;🌱 Chart &amp;amp; Infinity scroll&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;처음 입문한 라이브러리인 Chart.js이다. Chart.js 자체의 기능은 어렵지 않았지만… 설치하는 부분에서 꼬박 하루가 걸렸다..😂 아무리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install chart.js&lt;/code&gt;를 실행해서 chart를 설치해도… 일부 기능들이 동작하지 않았다..&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;원인은 chart.js의 버전이었다. chart.js를 사용하는 다른 사람들의 소스코드를 계속보다가 문득 package.json은 어떻지??라는 생각에 살펴보게 되었는데, 다른 사람들은 2.9.3버전의 chart.js를 사용하고 있었고, 나는 최신 버전으로 보이는 chart.js를 사용하고 있었다. 혹시나 하는 마음에 chart.js를 다운그래이드하여 다시 설치해본 결과…!! 드디어!! chart.js의 option으로 관리되는 기능들이 동작하였다..!! 그때의 감격.. (그 이후 package.json의 존재 이유를 알게 되었다는….)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-chart.gif&quot; alt=&quot;chartGif&quot; /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-chartCode.png&quot; alt=&quot;chartCode&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;무한 스크롤은 보통 백엔드와 소통하여 offset과 limit를 사용한 무한 스크롤을 구현하는 경우가 일반적인 것 같다. 하지만 백앤드와 소통해서 구현하기에는 메인 기능이 아니라 여겼기 때문에 백엔드로부터 오는 result값은 다 받고 이벤트가 발생할 때마다 result의 범위를 slice를 통해 넓혀나가는 방법을 택했다. (랜더링 최적화에는 좋지 않은 것 같아 리팩토링이 필요한 로직이라 생각한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-infinity1.png&quot; alt=&quot;infinityScroll&quot; /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-infinity2.png&quot; alt=&quot;infinityScroll&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;-filter&quot;&gt;🌱 Filter&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;입찰 거래 내역에는 가격별, 사이즈별로 오름차순 내림차순 기능이 구현되어 있다.&lt;/li&gt;
  &lt;li&gt;처음에는 데이터 영역을 다루는 것 자체가 백엔드의 역할이라는 회의 결과로 인해 백앤드분께서 일일히 해당 엔드포인트를 만들어주셨다. 그래서 URLSearchParams를 가지고 각 해당 엔드포인드로 이동하게끔 만들었다.&lt;/li&gt;
  &lt;li&gt;하지만 오히려 이것은 버튼을 누를 때마다 불필요한 통신을 실행하기에 오버 엔지니어링이라 느꼈다. 프론트에서 자체적으로 간단하게 필터링할 수 있는 부분인 것 같아 효율적인 운용을 위해 리팩토링해야할 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-filter.gif&quot; alt=&quot;filter&quot; /&gt;
&lt;img src=&quot;/assets/img/project/2021-07-24-cream/2021-07-24-cream-filterCode.png&quot; alt=&quot;filterCode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며..&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;현재 글을 적고 있는 시점은 이미 1달 반이라는 시간이 지났지만 아직까지 팀원들과 프로젝트를 진행했던 기억은 생생하다. 이번 프로젝트의 제일 Blocker는 chart.js의 버전의 차이로 인한 버그인 것 같다.&lt;/li&gt;
  &lt;li&gt;하루종일 ‘왜 동작을 안하지?’ 라는 생각을 수십번도 넘게 했던… 비록 버전 넘버 바꿔주고 npm install하니까 금방 해결될 문제였지만, 현업에서 이런 Blocker를 만나면 어떻게 효율적으로 대처할 것인가에 대해 많이 생각해보았던 것 같다.&lt;/li&gt;
  &lt;li&gt;이 프로젝트를 진행하면서 로직을 통한 문제 해결능력도 중요하지만, 필요한 시점에 적절한 문구를 사용하여 서치하는 능력 또한 중요하다는 것을 느끼는 프로젝트인 것 같다!! :)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 24 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/project-review-cream.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/project-review-cream.html</guid>
        
        <category>project</category>
        
        <category>Kream</category>
        
        <category>React</category>
        
        <category>경매</category>
        
        
        <category>project</category>
        
      </item>
    
  </channel>
</rss>