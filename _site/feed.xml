<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2022-07-11T10:28:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Syeon</title><subtitle>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</subtitle><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><entry><title type="html">[Algorithm] 백준 1541문제</title><link href="http://localhost:4000/devlog/baekjoon-1541.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1541문제" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1541</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1541.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1541 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.
그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.
괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
55-50+40 / -35
10+20+30+40 / 100
0009 - 0009 / 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String input = br.readLine();

        // + 만 있는 경우
        if (!input.contains(&quot;-&quot;) &amp;amp;&amp;amp; input.contains(&quot;+&quot;)) {
            String[] indexes = input.split(&quot;\\+&quot;);

            int result = 0;
            for (int i = 0; i &amp;lt; indexes.length; i++) {
                result += Integer.parseInt(indexes[i]);
            }

            System.out.println(result);
        } else if (input.contains(&quot;-&quot;) &amp;amp;&amp;amp; !input.contains(&quot;+&quot;)) {
            // - 만 있는 경우
            String[] indexes = input.split(&quot;-&quot;);

            int result = Integer.parseInt(indexes[0]);
            for (int i = 1; i &amp;lt; indexes.length; i++) {
                result -= Integer.parseInt(indexes[i]);
            }

            System.out.println(result);
        } else if (input.contains(&quot;-&quot;) &amp;amp;&amp;amp; input.contains(&quot;+&quot;)) {
            // 두개 다 있는 경우
            String[] minusList = input.split(&quot;-&quot;);

            int result = 0;
            // first Value
            if (minusList[0].contains(&quot;+&quot;)) {
                String[] firstList = minusList[0].split(&quot;\\+&quot;);

                for (int i = 0; i &amp;lt; firstList.length; i++) {
                    result += Integer.parseInt(firstList[i]);
                }
            } else {
                result = Integer.parseInt(minusList[0]);
            }

            for (int i = 1; i &amp;lt; minusList.length; i++) {
                if (minusList[i].contains(&quot;+&quot;)) {
                    String[] indexValues = minusList[i].split(&quot;\\+&quot;);

                    for (int x = 0; x &amp;lt; indexValues.length; x++) {
                        result -= Integer.parseInt(indexValues[x]);
                    }
                } else {
                    result -= Integer.parseInt(minusList[i]);
                }
            }

            System.out.println(result);
        } else {
            System.out.println(Integer.parseInt(input));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이번 문제는 생각보다 쉬웠다. (정답률 50%이니 당연한건가..?)&lt;/li&gt;
  &lt;li&gt;임의의 괄호를 추가하여 식이 최솟값이 되려면 -를 기준으로 +하여 한꺼번에 빼면 된다고 생각하였다.&lt;/li&gt;
  &lt;li&gt;그래서 식에 +만 있는 경우, -만 있는 경우, +,-만 있는 경우 3가지로 나누어 코드를 설계하였다.&lt;/li&gt;
  &lt;li&gt;+만 있으면 + split하여 값을 모두 더하면 끝!&lt;/li&gt;
  &lt;li&gt;-만 있으면 처음 값만 양수로 지정하고 나머지를 모두 빼면 끝!&lt;/li&gt;
  &lt;li&gt;+, -가 모두 있으면 먼저 -를 기준으로 split한다. 그리고 각 index에 +가 있는 경우 값을 더해주고 아니면 그대로 둔다.&lt;/li&gt;
  &lt;li&gt;그리고 index 0을 양수로 두고 나머지를 모두 빼면 최솟값을 구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;처음에 NumberFormat 에러가 발생하기에 이게 머지라는 생각을 했다.&lt;/li&gt;
  &lt;li&gt;Integer.parseInt 할 때, 안의 값에 숫자 이외에 다른 타입의 문자가 섞여있으면 발생하는 에러였다.&lt;/li&gt;
  &lt;li&gt;그래서 +, -가 모두 있을 때는 index 하나하나에 문자들이 섞여있는지 모두 검사해주어 해결하였다. (다행히 시간초과는 아니었다.)!!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1541 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 4796문제</title><link href="http://localhost:4000/devlog/baekjoon-4796.html" rel="alternate" type="text/html" title="[Algorithm] 백준 4796문제" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-4796</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-4796.html">&lt;blockquote&gt;
  &lt;p&gt;백준 4796 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;등산가 김강산은 가족들과 함께 캠핑을 떠났다. 하지만, 캠핑장에는 다음과 같은 경고문이 쓰여 있었다.
캠핑장은 연속하는 20일 중 10일동안만 사용할 수 있습니다.
강산이는 이제 막 28일 휴가를 시작했다. 이번 휴가 기간 동안 강산이는 캠핑장을 며칠동안 사용할 수 있을까?
강산이는 조금 더 일반화해서 문제를 풀려고 한다.
캠핑장을 연속하는 P일 중, L일동안만 사용할 수 있다. 강산이는 이제 막 V일짜리 휴가를 시작했다. 강산이가 캠핑장을 최대 며칠동안 사용할 수 있을까? (1 &amp;lt; L &amp;lt; P &amp;lt; V)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
5 8 20 / Case 1: 14
5 8 17 / Case 2: 11
0 0 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int count = 1;

        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        while(true) {
            StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

            int L = Integer.parseInt(st.nextToken());
            int P = Integer.parseInt(st.nextToken());
            int V = Integer.parseInt(st.nextToken());

            if (L == 0 &amp;amp;&amp;amp; P == 0 &amp;amp;&amp;amp; V == 0) {
                break;
            }

            int result = ((V / P) * L) + (V % P);

            list.add(&quot;Case &quot; + count + &quot;: &quot; + result);
            count++;
        }

        list.forEach(System.out::println);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음 문제를 봤을 때 ‘어? 이거 쉬운데 왜 정답률이 30%대지??’ 라는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;막상 백준에서 제시해준 test case들을 기준으로 식을 세워 코드를 짰다. 그리고 제출을 한 결과..Fail..😂 그럼그렇지..&lt;/li&gt;
  &lt;li&gt;그런데 아무리 생각해봐도 저기에서 예외 케이스가 먼지 도통 알 수가 없었다..그저 빨리 풀고 싶었을 뿐..&lt;/li&gt;
  &lt;li&gt;조급한 마음에 다른 사람들이 썼던 풀이법을 살짝 봤는데.. 머리를 한대 맞은 느낌이었다.&lt;/li&gt;
  &lt;li&gt;V % P가 L보다 클 경우가 있다는 것… 예를 들어 5 8 15 케이스이다.&lt;/li&gt;
  &lt;li&gt;15 % 8 * 5는 문제없이 5이다. 여기서 내가 만든 코드를 넣으면 15 % 8 = 7 =&amp;gt; 5 + 7이 되는데.. 이 문제에서는 한번 연속된 값을 더할때는 분명 5(L)을 넘으면 안되는데… 중얼거리며 바로 수정하니 정답…&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int result = ((V / P) * L) + (V % P);

    =&amp;gt;

    int result1 = (V / P) * L;
    int result2;
    if (V % P &amp;gt; L) {
        result2 = L;
    } else {
        result2 = V % P;
    }

    int result = result1 + result2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;누가 그랬던 것 같은데..? 개발은 겸손해야한다고..&lt;/li&gt;
  &lt;li&gt;더 문제에 대해 고민해볼 수 있었지만, 깊이 생각하고 싶지 않고 내 코드가 왜 이상이 있지? 라고 생각했던 것이 이번 문제의 오답의 요인이 되었던 것 같다.&lt;/li&gt;
  &lt;li&gt;주어진 테스트 케이스 뿐아니라 다양한 상황에서 예외를 가질 수 있는 테스트 케이스가 있을 수 있고 이런 케이스들을 잘 찾아내는 능력도 중요하겠구나 라는 생각도 들었다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 4796 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1946문제</title><link href="http://localhost:4000/devlog/baekjoon-1946.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1946문제" /><published>2022-07-08T00:00:00+09:00</published><updated>2022-07-08T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1946</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1946.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1946 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(br.readLine());

        while(T-- &amp;gt; 0) {

            int N = Integer.parseInt(br.readLine());

            int[][] list = new int[N][2];

            for(int i = 0; i &amp;lt; N; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
                list[i][0] = Integer.parseInt(st.nextToken());
                list[i][1] = Integer.parseInt(st.nextToken());
            }

            Arrays.sort(list, (o1, o2) -&amp;gt; {
                return o1[0] - o2[0];
            });

            int count = 0;
            int pivot = list[0][1];

            for(int i = 1; i &amp;lt; N; i++) {
                if(pivot &amp;lt; list[i][1]) {
                    count++;
                } else {
                    pivot = list[i][1];
                }
            }

            System.out.println(N - count);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2일에 걸쳐 푼 문제…😂&lt;/li&gt;
  &lt;li&gt;어제는 생각을 쥐어짜내도 풀어지지가 않던데..(배탈나서 그런가..) 오늘은 앉아서 문제를 보자마자 술술 풀렸다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사실 술술 풀리기보다는 array sort만 오름차순으로 바꿨을뿐인데 풀이 방법이 생각났다…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;처음에는 이중 for문으로 하나하나 비교해서 값을 찾을까 했지만.. 아니나 다를까 시간초과가 떳다..&lt;/li&gt;
  &lt;li&gt;다른 자료구조를 사용해야하나 어떻게 해야하나 문제를 읽고 읽어서 요구하는 것을 파악하는데 시간이 좀 걸린 것 같다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이번 문제는 알고리즘이나 자료구조의 사용법보다 풀이 전략을 잘 세우는 것이 중요한 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 서류심사 기준으로 sorting을 한다. 1순위부터 n순위까지 sorting을 하면 면접 순위만 비교하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;서류 1순위가 면접 4순위라면, 그 다음 서류 2순위는 📌무조건!! 면접 4순위보다 높아야한다.&lt;/li&gt;
  &lt;li&gt;서류 2순위가 면접 4순위보다 낮은 순위라면 서류 1순위보다 두개 다 낮기 때문에 탈락되기 때문..!&lt;/li&gt;
  &lt;li&gt;이런 식으로 서류 1순위의 면접 순위를 pivot으로 정하고 서류 2순위가 서류 1순위보다 면접 순위가 높으면 pivot은 서류 2순의의 면접 순위로 재할당한다.&lt;/li&gt;
  &lt;li&gt;이렇게 비교하면 전체 count는 탈락한 사람들의 숫자가 나올텐데 여기서 전체(N) - 탈락인원(pivot)을 하면 값을 구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1946 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 13458문제</title><link href="http://localhost:4000/devlog/baekjoon-13458.html" rel="alternate" type="text/html" title="[Algorithm] 백준 13458문제" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-13458</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-13458.html">&lt;blockquote&gt;
  &lt;p&gt;백준 13458 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
1
1
1 1 / 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3
3 4 5
2 2 / 7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
1000000 1000000 1000000 1000000 1000000
5 7 / 714290&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
10 9 10 9 10
7 20 / 10&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
10 9 10 9 10
7 2 / 13&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        int[] place = new int[N];

        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
        for (int i = 0; i &amp;lt; place.length; i++) {
            place[i] = Integer.parseInt(st.nextToken());
        }

        StringTokenizer person = new StringTokenizer(br.readLine(), &quot; &quot;);
        int B = Integer.parseInt(person.nextToken());
        int C = Integer.parseInt(person.nextToken());

        int count = 0;

        for (int i = 0; i &amp;lt; place.length; i++) {
            // 총감독관 counting
            int remain = place[i] - B;
            count++;

            // 부감독관 counting
            // remain 이 0 이하일 경우
            if (remain &amp;lt;= 0) {
                continue;
            }

            // remain 이 C 보다 작을 경우
            if (remain &amp;lt;= C) {
                count++;
                continue;
            }

            // remain 이 C 보다 클 경우
            if (remain &amp;gt; C) {
                if(remain % C == 0) {
                    count += remain / C;
                } else {
                    count += (remain / C) + 1;
                }
            }
        }

        System.out.println(count);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;각 시험장마다 총감독관은 1명씩 무조건 필요하므로 총감독관의 감독가능 학생 수를 뺀 나머지 값을 부감독관 감독 가능 수로 나누어 count한다.&lt;/li&gt;
  &lt;li&gt;총감독관 무조건 한명 =&amp;gt; (total 학생 - 총감독 가능 인원 = a) -&amp;gt; a / 부감독 가능 인원 -&amp;gt; 만약 a와 부감독 가능 인원의 나눈 값에 나머지가 있다면 count + 1 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    long count = 0;

    int[] place = new int[N];
    for(int i = 0; i &amp;lt; N; i++) {
        place[i] = sc.nextInt();
    }

    int B = sc.nextInt();
    int C = sc.nextInt();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 문제는 쉬운 것 같은데 왜 정답률이 20%인지 잘 몰랐다.&lt;/li&gt;
  &lt;li&gt;막상 풀어보니 풀이 방법은 맞는 것 같은데 계속 틀리는 이유가 무엇인지 모르겠다..&lt;/li&gt;
  &lt;li&gt;IDE로 풀어보았을 때 테스트 코드는 모두 통과했지만 백준에서는 계속 제출하자마자 틀렸다는 문구가 나왔다…&lt;/li&gt;
  &lt;li&gt;혹시나 싶어서 BufferedReader 대신 Scanner를 사용해보았는데 성공.. (차이가 머지..?)&lt;/li&gt;
  &lt;li&gt;일단 Scanner 사용방법을 알게 되어 좋긴했지만.. 소요된 시간이 아깝..ㅠ&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 13458 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 2217문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-2217.html" rel="alternate" type="text/html" title="[Algorithm] 백준 2217문제 (Greedy)" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-2217</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-2217.html">&lt;blockquote&gt;
  &lt;p&gt;백준 2217 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
2
10
15 / 20&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        ArrayList&amp;lt;Integer&amp;gt; ropes = new ArrayList&amp;lt;&amp;gt;();

        for(int i = 0; i &amp;lt; N; i++) {
            int rope = Integer.parseInt(br.readLine());

            ropes.add(rope);
        }

        ropes.sort((o1, o2) -&amp;gt; {
            return o1 - o2;
        });

        int result = 0;

        for (int i = 0; i &amp;lt; ropes.size(); i++) {
            int curWeight = ropes.get(i) * N;

            result = Math.max(result, curWeight);
            N--;
        }

        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;처음에는 주어진 ropes들을 Des sorting하여 제일 앞에 있는 rope에 N을 곱하여 최대 중량을 구하는 문제라고 생각했다. 하지만 그렇게 간단한..?(너무 간단한가..?) 문제는 아니었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ropes에 많은 좋은 rope들이 있더라도 index 0에 있는 줄의 최대 중량이 1이라면 1 * N밖에 되지 않는 최대 중량이 될 것이다.&lt;/li&gt;
  &lt;li&gt;그래서 로프가 N–일 때 그에 맞는 최대 중량이 다 다를 것이고 값도 규칙성을 가지지 않기 때문에 하나하나 Math.max하여 비교한 값을 return 하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;처음으로 다른 분들의 코드와 비슷했다. (뿌듯)&lt;/li&gt;
  &lt;li&gt;문제의 난이도가 쉽다고 하지만 이것을 기점으로 더 알고리즘 성장을 이뤄내고 싶다🔥&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 2217 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 11000문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-11000.html" rel="alternate" type="text/html" title="[Algorithm] 백준 11000문제 (Greedy)" /><published>2022-07-04T00:00:00+09:00</published><updated>2022-07-04T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-11000</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-11000.html">&lt;blockquote&gt;
  &lt;p&gt;백준 11000 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.
김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.
참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
3
1 3
2 4
3 5 / 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        while(N-- &amp;gt; 0) {
            ArrayList&amp;lt;Integer&amp;gt; classes = new ArrayList&amp;lt;&amp;gt;();

            StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
            int startClass = Integer.parseInt(st.nextToken());
            int endClass = Integer.parseInt(st.nextToken());

            classes.add(startClass);
            classes.add(endClass);

            list.add(classes);
        }

        list.sort((o1, o2) -&amp;gt; {
          if(o1.get(1) == o2.get(1)) {
            return o1.get(1) - o2.get(1);
          }

          return o1.get(0) - o2.get(0);
        });


        // 시간초과
//        ArrayList&amp;lt;Integer&amp;gt; endList = new ArrayList&amp;lt;&amp;gt;();
//        endList.add(list.get(0).get(1));
//
//        for (int i = 1; i &amp;lt; list.size(); i++) {
//            boolean isChanged = false;
//
//            for (int x = 0; x &amp;lt; endList.size(); x++) {
//
//                if (list.get(i).get(0) &amp;gt;= endList.get(x)) {
//                    endList.set(x, list.get(i).get(1));
//                    isChanged = true;
//                    break;
//                }
//            }
//
//            if(!isChanged) {
//                endList.add(list.get(i).get(1));
//            }
//        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;저번에 풀었던 회의실 문제랑 비슷한 문제라고 생각했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 강의 시간들을 잘 정렬하는 것이 이 문제의 키포인트 중 하나이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;강의 시간을 정렬할 때 기본적으로 시작시간 기준으로 오름차순으로 정렬하되, 만약 시작시간이 같을 경우 끝나는 시간을 오름차순으로 정렬한다.&lt;/li&gt;
  &lt;li&gt;이렇게 시간을 정렬하고나면 시간을 for문으로 각각 비교하였을 때 오름차순 순으로 시간들을 비교할 수 있어서 이중, 삼중으로 비교하고 값을 할당하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;그렇게 최소한의 비교를 위해 전체 시간 정렬 list와 끝나는 시간 list를 만들어 비교하려고 했..으나.. 계속 ‘시간초과’가 발생하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;();
    pq.add(list.get(0).get(1));

    for (int i = 1; i &amp;lt; list.size(); i++) {
        if(pq.peek() &amp;lt;= list.get(i).get(0)) {
            pq.poll();
        }

        pq.add(list.get(i).get(1));
    }

    System.out.println(pq.size());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;로직이 잘못된 것인지, for loop 하나로 해결할 수 있는 방법이 있는지 계속 고민했지만 결국 해결하지 못했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하루 이틀 고민해봤지만 무엇이 문제인지 알수가 없어서 결국 다른 사람들이 어떻게 풀이하였는지 참고하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;참고해보니 접근법은 비슷했다. 다만, 이 접근법을 통해 더 효율적인 방안을 사용하는 것…&lt;/li&gt;
  &lt;li&gt;Java로 알고리즘 문제들을 풀이할 때 지금까지 알고리즘 방법에서 막혔었다면.. 이번에는 자료구조에 실패의 요인이 있었다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ArrayList는 get 메소드 경우 O(1)로 복잡하지 않지만, add, remove 등의 메소드는 O(n)의 시간이 소요된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그럴 때 사용하는 자료구조가 우선순위 큐(최대 / 최소 힙)이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우선순위 큐는 시간복잡도가 O(logN)으로 이 문제에서 요구하는 각 시간들을 비교할 때 최적의 자료구조라고 생각되었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자료구조를 ArrayList에서 PrioityQueue로 바꾸니 정답이었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이번 문제를 통해 각 문제마다 접근할 수 있는 것이 알고리즘뿐 아니라 자료구조에 대해 고민해보게 되었다… 점점 고려할 사항들이 많아지니 언제 한번 문제 접근 방법에 대해 고민해보는 시간을 가져야겠다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 11000 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1783문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-1783.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1783문제 (Greedy)" /><published>2022-07-01T00:00:00+09:00</published><updated>2022-07-01T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1783</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1783.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1783 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2칸 위로, 1칸 오른쪽
1칸 위로, 2칸 오른쪽
1칸 아래로, 2칸 오른쪽
2칸 아래로, 1칸 오른쪽
병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;100 50 =&amp;gt; 48
1 1 =&amp;gt; 1
17 5 =&amp;gt; 4
2 4 =&amp;gt; 2
20 4 =&amp;gt; 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int count = 1;
        int moveM = 1;

        // 최대 칸이 4이상일 최소 경우의 수
        if (N &amp;gt;= 3 &amp;amp;&amp;amp; M &amp;gt;= 7) {
            count = 5;
            moveM = 7;

            while (M &amp;gt;= moveM + 1) {
                moveM++;
                count++;
            }

            System.out.println(count);
        } else {
            // 최대 칸이 4미만이며, 말이 위 아래로 왔다갔다할 수 있는 경우
            // 세로칸이 3칸일 경우 오른쪽으로 1씩 이동 가능
            if (N &amp;gt; 2) {
                while (M &amp;gt;= moveM + 1) {
                    count++;
                    moveM++;
                }

                System.out.println(Math.min(count, 4));
                return;
            }

            // 세로칸이 2칸일 경우 오른쪽으로 2씩 이동 가능
            if (N &amp;gt; 1) {
                while (M &amp;gt;= moveM + 2) {
                    count++;
                    moveM += 2;
                }

                System.out.println(Math.min(count, 4));
                return;
            }

            System.out.println(count);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;문제에서 체스말이 움직일 수 있는 방법은 4가지이지만, 제약을 기준으로 코드를 설계하는 것이 좋을 것 같다고 판단했다.&lt;/li&gt;
  &lt;li&gt;체스말이 최대 4번 이상 움직일 수 있으면 무조건 4가지 이동방법을 다 사용해야하는 제약을 통해 알 수 있는 것이 있다.&lt;/li&gt;
  &lt;li&gt;체스말의 이동 방법의 특징은 상하로는 언제든지 움직일 수 있지만, 좌우로는 무조건 오른쪽으로 이동한다는 특징이다.&lt;/li&gt;
  &lt;li&gt;이 특징을 활용하여 세로칸이 3이상, 가로칸이 7이상인 경우 위에서 언급한 제약사항을 적용한다.&lt;/li&gt;
  &lt;li&gt;제약사항에 적용되지 않는 상황일 때는 각 세로칸에서(2 or 1) 가로칸으로 움직일 수 있는 상황을 구한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        if(N == 1) { System.out.println(1); }

        if(N == 2) {
            int result = Math.min(4, 1 + ((M - 1) / 2));
            System.out.println(result);
        }

        if(N &amp;gt;= 3) {
            if(M &amp;gt;= 7) {
                System.out.println(5 + (M - 7));
            } else {
                System.out.println(Math.min(4, M));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;특징을 다시 잘 살펴보면, 세로칸이 1일 경우, 2일 경우, 3이상일 경우로 나누어 코드를 단축시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;세로가 1일 경우에는 당연히 움직이지 못하기 때문에 (1, 1)하나로 return 1&lt;/li&gt;
  &lt;li&gt;세로가 2일 경우에는 체스말이 상하로 1씩밖에 움직이지 못하기 때문에 오른쪽으로 무조건 2씩 이동해야한다.&lt;/li&gt;
  &lt;li&gt;세로가 3 이상일 경우에는 제약 사항을 적용해야한다.&lt;/li&gt;
  &lt;li&gt;즉, 세로가 3이상이면서 가로가 7이상이면 4가지 방식을 다 적용한 이후의 좌표 (3, 7)부터 오른쪽으로 가능한 한 움직인다.&lt;/li&gt;
  &lt;li&gt;가로가 7 미만이면 제약사항을 적용시키지 못하므로 무조건 최대값은 4가 된다. (4 이상이려면 제약사항을 적용해야하므로)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇기 때문에 상하로는 계속 움직일 수 있지만 가로로는 4와 M 중 최소값을 return하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코드를 설계할 때 문제를 잘 파악하여, 기준점을 잘 세우는 것이 중요할 것 같다.&lt;/li&gt;
  &lt;li&gt;문제를 잘 파악하는 능력을 길러야겠다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1783 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 10610문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-10610.html" rel="alternate" type="text/html" title="[Algorithm] 백준 10610문제 (Greedy)" /><published>2022-06-30T00:00:00+09:00</published><updated>2022-06-30T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-10610</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-10610.html">&lt;blockquote&gt;
  &lt;p&gt;백준 10610 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.
미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Thirty10610 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String fullText = br.readLine();
        int N = fullText.length();

        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; N; i++) {
            list.add(Integer.parseInt(fullText.substring(i, i + 1)));
        }

        list.sort((o1, o2) -&amp;gt; o2 - o1);

        StringBuilder sb = new StringBuilder();
        list.forEach(sb::append);

        String value = sb.toString();

        Integer finalValue = Integer.parseInt(value);

        if(finalValue % 30 != 0) {
            System.out.println(-1);
        } else {
            System.out.println(finalValue);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;30의 배수에 대한 특징을 살펴보아 10의 자리의 수 특성에 따라 뒤에 무조건 0이 있어야하는 것,&lt;/li&gt;
  &lt;li&gt;또한 각 자리의 숫자를 모두 더한 값이 3의 배수여야했다. (수학적으로 알아볼 필요가 있을 것 같…)&lt;/li&gt;
  &lt;li&gt;이러한 특징들을 고려하여 알고리즘을 만들었으나…IDE에서는 자가 테스트로 통과되었지만 백준에서는 계속 NumberFormat 에러가 발생하였다..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String fullText = br.readLine();
        int N = fullText.length();

        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int total = 0;

        for (int i = 0; i &amp;lt; N; i++) {
            int parseInt = Integer.parseInt(fullText.substring(i, i + 1));

            list.add(parseInt);
            total += parseInt;
        }

        if(total % 3 != 0 || !list.contains(0)) {
            System.out.println(-1);
            return;
        }

        list.sort((o1, o2) -&amp;gt; o2 - o1);

        list.forEach(System.out::print);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제를 다시 잘 읽어보니 N은 10^5 개의 숫자들이라고 한다.&lt;/li&gt;
  &lt;li&gt;사실 저게 무슨 의미인지 아직 이해가 잘 가지 않지만, 다른 분들의 설명을 들은 결과 N의 결과를 Integer는 물론이거니와 Long으로도 형변환할 수 없다는 것이었다…&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 어떻게 풀어내지 고민했는데 각각 값들을 System.out.print하면 하나로 보이지 않을까 해서 해봤는데.. 통과!!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;문제들을 풀어보니 여러가지 고려사항들이 하나씩 늘어가기 시작한다. 시간/공간 복잡도, 주어지는 input을 어떻게 찰떡같이 받아내서 output으로 내보낼 수 있을지.. 등등..&lt;/li&gt;
  &lt;li&gt;이번 풀이에서 소요된 시간이 1000ms이 걸렸는데 다른 사람들은 100~200ms으로 푼 사람들도 있었다.&lt;/li&gt;
  &lt;li&gt;문제 접근 방식은 같지만 loop를 유발하는 메소드, BufferedReader, StringBuffer 같은 API 활용이 시간을 더 단축시킬 수 있다는 생각에 이러한 툴들을 적재적소에 사용하는 것이 중요할 것 같다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 10610 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 2875문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-2875.html" rel="alternate" type="text/html" title="[Algorithm] 백준 2875문제 (Greedy)" /><published>2022-06-29T00:00:00+09:00</published><updated>2022-06-29T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-2875</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-2875.html">&lt;blockquote&gt;
  &lt;p&gt;백준 2875 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;백준대학교에서는 대회에 나갈 때 2명의 여학생과 1명의 남학생이 팀을 결성해서 나가는 것이 원칙이다. (왜인지는 총장님께 여쭈어보는 것이 좋겠다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;백준대학교는 뛰어난 인재들이 많아 올해에도 N명의 여학생과 M명의 남학생이 팀원을 찾고 있다. 대회에 참여하려는 학생들 중 K명은 반드시 인턴쉽 프로그램에 참여해야 한다. 인턴쉽에 참여하는 학생은 대회에 참여하지 못한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;백준대학교에서는 뛰어난 인재들이 많기 때문에, 많은 팀을 만드는 것이 최선이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러분은 여학생의 수 N, 남학생의 수 M, 인턴쉽에 참여해야하는 인원 K가 주어질 때 만들 수 있는 최대의 팀 수를 구하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input
6 3 2 =&amp;gt; 2
2 1 1 =&amp;gt; 0
6 10 3 =&amp;gt; 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        Integer N = Integer.parseInt(st.nextToken());
        Integer M = Integer.parseInt(st.nextToken());
        Integer K = Integer.parseInt(st.nextToken());

        int teamCount;

        while(K != 0) {
            if(N &amp;gt;= M * 2) {
                N--;
                K--;
                continue;
            }

            if(N &amp;lt; M * 2) {
                M--;
                K--;
                continue;
            }
        }

        if(N &amp;gt;= M * 2) {
            teamCount = M;
            System.out.println(teamCount);
            return;
        }

        if(N &amp;lt; M * 2) {
            teamCount = N / 2;
            System.out.println(teamCount);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;N은 2때 M은 1이 필요하다. 즉 N이 M의 2배보다 많으면 N에서 인턴쉽을 보내고 그렇지 않은 경우에는 M에서 인턴쉽을 보낸다.&lt;/li&gt;
  &lt;li&gt;while문으로 인턴쉽 인원이 다 보내질 때까지 반복하다가 K가 0이 되면, N과 M을 비교하여 teamCount를 할당한다.&lt;/li&gt;
  &lt;li&gt;N이 M의 2배보다 많으면 M을 기준으로 teamCount가 만들어지고 반대 경우에는 N이 기준이 되어 teamCount를 만들어 output한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while(N &amp;gt;= 2 &amp;amp;&amp;amp; M &amp;gt;= 1 &amp;amp;&amp;amp; N + M &amp;gt;= K + 3) {
    N -= 2;
    M--;
    teamCount++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 풀이로 문제를 해결하고 난 이후에 그리디를 제대로 활용하지 않은것 같은 느낌이 들어 다른 사람들의 풀이를 참고하였다.&lt;/li&gt;
  &lt;li&gt;나의 풀이는 K의 상태에 focus를 맞췄지만 다른 사람들의 풀이는 teamCount가 focus된 느낌이었다.&lt;/li&gt;
  &lt;li&gt;속도측면에서는 비슷비슷한 것 같았다. (나의 풀이 132ms, 다른 사람 풀이 136ms)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 2875 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1931문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-1931.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1931문제 (Greedy)" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1931</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1931.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1931 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;input &lt;br /&gt;
11 &lt;br /&gt;
1 4 &lt;br /&gt;
3 5 &lt;br /&gt;
0 6 &lt;br /&gt;
5 7 &lt;br /&gt;
3 8 &lt;br /&gt;
5 9 &lt;br /&gt;
6 10 &lt;br /&gt;
8 11 &lt;br /&gt;
8 12 &lt;br /&gt;
2 13 &lt;br /&gt;
12 14 &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MeetingRoom1931 {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        // 각 받은 string token 이중 array 로 형변환
        for(int i = 0; i &amp;lt; N; i++) {
            String el = br.readLine();

            StringTokenizer st = new StringTokenizer(el, &quot; &quot;);
            ArrayList&amp;lt;Integer&amp;gt; timeList = new ArrayList&amp;lt;Integer&amp;gt;();

            timeList.add(Integer.parseInt(st.nextToken()));
            timeList.add(Integer.parseInt(st.nextToken()));

            list.add(timeList);
        }

        Collections.sort(list, (ArrayList&amp;lt;Integer&amp;gt; a, ArrayList&amp;lt;Integer&amp;gt; b) -&amp;gt; (a.get(1) - a.get(0)) - (b.get(1) - b.get(0)));

        int count = 0;

        for(int i = 0; i &amp;lt; N; i++) {
            boolean[] times = new boolean[24];
            int curCount = 1;

            for(int x = list.get(i).get(0); x &amp;lt; list.get(i).get(1); x++) {
                times[x] = true;
            }

            for(int y = 0; y &amp;lt; N; y++) {
                int leftPivot = list.get(y).get(0);
                int rightPivot = list.get(y).get(1);

                boolean hasTime = false;

                for(int z = leftPivot; z &amp;lt; rightPivot; z++) {
                    if(times[z]) {
                        hasTime = true;
                        break;
                    }
                }

                if(!hasTime) {
                    for(int z = leftPivot; z &amp;lt; rightPivot; z++) {
                        times[z] = true;
                    }
                    curCount++;
                }
            }

            count = Math.max(count, curCount);
        }

        System.out.println(count);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위에는 없지만 전에 풀던 것과 마찬가지로 quickSort를 직접 구현하여 풀어보았다.&lt;/li&gt;
  &lt;li&gt;처음에는 quickSort의 문제라기보다 sorting한 이후의 로직의 문제인 줄 알았다.&lt;/li&gt;
  &lt;li&gt;다른 IDE로는 값이 잘 출력되었지만, 백준에서는 계속 시간초과가 나왔다.&lt;/li&gt;
  &lt;li&gt;sorting 이후의 로직을 최대한 간결하게 하려고 했지만 이중, 삼중 for문이 반필수적으로 들어갔다. (처음 sorting할 때의 기준은 각 node마다의 (끝나는 시간 - 시작하는 시간)의 값을 기준으로 오름차순 정렬하였다.)&lt;/li&gt;
  &lt;li&gt;sorting된 시간을 비교하려면 추가적인 자료구조 및 O(n)을 초과하는 로직이 필수적이었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sorting할 때 기준을 끝나는 시간에 맞추어 sorting한다. (끝나는 시간이 같다면 시작 시간을 기준으로 오름차순 정렬한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws IOException {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int N = Integer.parseInt(br.readLine());

    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    for(int i = 0; i &amp;lt; N; i++) {
        String el = br.readLine();

        StringTokenizer st = new StringTokenizer(el, &quot; &quot;);
        ArrayList&amp;lt;Integer&amp;gt; timeList = new ArrayList&amp;lt;Integer&amp;gt;();

        timeList.add(Integer.parseInt(st.nextToken()));
        timeList.add(Integer.parseInt(st.nextToken()));

        list.add(timeList);
    }

    Collections.sort(list, new Comparator&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;() {
        @Override
        public int compare(ArrayList&amp;lt;Integer&amp;gt; o1, ArrayList&amp;lt;Integer&amp;gt; o2) {
            if(o1.get(1) == o2.get(1)) {
                return o1.get(0) - o2.get(0);
            } else {
                return o1.get(1) - o2.get(1);
            }
        }
    });

    int count = 0;

    int end = 0;

    for(int i = 0; i &amp;lt; N; i++) {
        if(list.get(i).get(0) &amp;gt;= end) {
            count++;
            end = list.get(i).get(1);
        }
    }

    System.out.println(count);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Collections.sort 하나만으로 for문을 하나만 들려서 정답을 도출할 수 있게 되었다.&lt;/li&gt;
  &lt;li&gt;무작정 알고리즘을 사용하는 것보다 어떻게 알고리즘을 사용해야하는지에 대한 고민이 중요하다고 생각되었다.&lt;/li&gt;
  &lt;li&gt;추가로 시간복잡도, 공간복잡도도 함께 고려하여 사전에 설계하는 습관을 들여야겠다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1931 Greedy Algorithm 문제입니다.</summary></entry></feed>