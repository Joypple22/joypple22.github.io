<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2021-08-17T12:17:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Syeon</title><subtitle>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</subtitle><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><entry><title type="html">[Algorithm] Queue</title><link href="http://localhost:4000/devlog/algorithm-queue.html" rel="alternate" type="text/html" title="[Algorithm] Queue" /><published>2021-08-15T00:00:00+09:00</published><updated>2021-08-15T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-queue</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-queue.html">&lt;blockquote&gt;
  &lt;p&gt;Queue 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-queue란&quot;&gt;📌 Queue란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 넣은 데이터를 먼저 나오게 하는 FIFO(First in First Out) 자료구조 형식이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FILO(First in Last Out) 형식인 Stack과 다르게 Queue는 한쪽에서는 삽입 연산, 다른 한쪽은 삭제 연산이 이루어지는 형식이다.&lt;/p&gt;

    &lt;p&gt;&lt;img alt=&quot;queue&quot; src=&quot;/assets/img/algorithm/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제요세푸스-순열&quot;&gt;📌 사용 예제(요세푸스 순열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;8명의 사람들을 원형으로 세우고 순서대로 돌아가면서 1부터 번호를 부르는데 3에 해당하는 사람은 제외시킨다.&lt;/li&gt;
  &lt;li&gt;제외가 되면 제외된 다음 사람부터 1을 부르고 마찬가지로 3에 해당되는 사람은 제외시키는 것을 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (n, k) =&amp;gt; {
    let answer;
    let queue = Array.from({length: n}, (v, i) =&amp;gt; i + 1); ----- (1)

    while(queue.length) {     -------(2)
        for(let i = 1; i &amp;lt; k; i++) queue.push(queue.shift());
        queue.shift();
        if(queue.length === 1) answer = queue.shift();
    }
    return answer;
}

question(8, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)에서 함수형 프로그래밍으로 1부터 8까지의 요소들을 갖는 배열을 만든다.(함수형 프로그래밍 공부해야겠다..🔥)&lt;/li&gt;
  &lt;li&gt;(2)에서 queue.length가 0이 될 때까지 반복문을 돌린다.&lt;/li&gt;
  &lt;li&gt;먼저 queue의 첫번째 요소, 두번째 요소를 for문을 사용하여 차례로 queue 배열 뒤에 쌓고 앞의 숫자는 제거한다.&lt;/li&gt;
  &lt;li&gt;그 다음 queue의 첫번째 요소가 되는 숫자는 처음 queue의 3번째 숫자였으므로 뒤에 넣지 않고 제거만 한다.&lt;/li&gt;
  &lt;li&gt;이것을 반복하여 마지막 queue의 요소가 1개가 남으면 그 요소를 answer에 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 정리하여 앞에 숫자가 조건에 만족하면 배열 마지막 요소로 push하고 shift를 사용하여 제거하지만, 조건에 만족하지 않으면 shift만 사용하여 제거함으로 최후에 남는 데이터를 찾을 수 있는 알고리즘이다.&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Queue" /><summary type="html">Queue 자료구조를 활용한 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Stack</title><link href="http://localhost:4000/devlog/algorithm-stack.html" rel="alternate" type="text/html" title="[Algorithm] Stack" /><published>2021-08-10T00:00:00+09:00</published><updated>2021-08-10T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-stack</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-stack.html">&lt;blockquote&gt;
  &lt;p&gt;Stack 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-stack이란&quot;&gt;Stack이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제배열&quot;&gt;사용 예제(배열)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-stack이란&quot;&gt;📌 Stack이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;‘쌓다’, ‘더미’ 라는 의미를 가진 알고리즘&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이름의 의미와 같이 한쪽으로만 열려있기 때문에 한쪽으로만 데이터를 받고 빼는 구조로 되어 있다. (후입선출)
&lt;img alt=&quot;&quot; src=&quot;/assets/img/algorithm/stack1.png&quot; width=&quot;400px&quot; /&gt; Last In First Out&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack의 구현 방법은 배열, 연결 리스트 2가지가 있다. (Stack이라고 해서 특별한 저장 공간을 가지는 array나 object가 있는 것이 아니라 stack이라는 자료구조 형식으로 알맞게 구현하는 것!)&lt;/li&gt;
  &lt;li&gt;각각 배열과 연결 리스트의 장단점이 있는데 &lt;br /&gt;
배열은 ‘데이터 접근 속도가 빠르기 때문에 데이터 양이 많으면 많을수록 효율이 좋지만, 데이터 삽입과 삭제에서는 비효율적’이다. &lt;br /&gt;
연결리스트는 ‘데이터 접근할 경우에는 연결되어 있는 노드를 따라 확인하며 접근하기 때문에 접근, 속도에서는 효율이 떨어지지만 데이터 삽입, 삭제는 배열보다 효율이 좋다’.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제배열&quot;&gt;📌 사용 예제(배열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;()의 짝이 맞는 경우는 true, 안맞으면 false&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let str = '(()()(())' // false

const question = (str) =&amp;gt; {
    let stack = [];

    for(let i of str) {
        if(i === '(') {
            stack.push(i);
        }
        else {
            if(stack.length === 0) {
                return false;
            } else {
                stack.pop();
            }
        }
    }
    if(stack.length &amp;gt; 0) return false
    else return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;stack이라는 배열을 만들고 난 후 ‘(‘가 있으면 stack에 push하고 ‘)’가 있으면 기존에 있는 ‘(‘를 pop하는 방식이다.&lt;/li&gt;
  &lt;li&gt;이렇듯 하나의 배열에 데이터를 순서대로 쌓고 순서대로 빼는 방식이 stack 자료구조이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Stack" /><summary type="html">Stack 자료구조를 활용한 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Hash</title><link href="http://localhost:4000/devlog/algorithm-hash.html" rel="alternate" type="text/html" title="[Algorithm] Hash" /><published>2021-08-06T00:00:00+09:00</published><updated>2021-08-06T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-hash</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-hash.html">&lt;blockquote&gt;
  &lt;p&gt;임의의 길이의 데이터를 고정된 길이의 데이터로 변환시키는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-hash란&quot;&gt;Hash란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-hash란&quot;&gt;📌 Hash란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&quot; target=&quot;\_blank&quot;&gt;사전적 정의&lt;/a&gt;로 임의의 길이를 가지고 있는 데이터를 고정된 길이의 데이터로 변환시켜주는 자료 구조이다.&lt;/li&gt;
  &lt;li&gt;Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.&lt;/li&gt;
  &lt;li&gt;데이터를 추가/삭제 시 기존 데이터를 밀어내거나 당기는 작업이 없도록 하는 알고리즘을 이용하여 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. (&lt;a href=&quot;https://jroomstudio.tistory.com/10&quot; target=&quot;/\_blank&quot;&gt;출처&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 쉽게 설명하자면 식당 메뉴판에 정렬된 메뉴를 볼때는 순차적으로 위에서 아래로 훑는게 아니라 아예 메뉴 이름에 대한 값을 알고 있는 것이라고 비유할 수 있을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;-사용-예시&quot;&gt;📌 사용 예시&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;array안에 있는 과일들 중 가장 많이 들어있는 과일을 찾으시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let fruits = ['사과', '바나나', '배', '사과', '사과', '배', '배', '사과', '사과']
const question = (fruits) =&amp;gt; {
    let answer;
    let hash = new Map();

    for(let i of fruits) {
        if(hash.has(i)) hash.set(i, hash.get(i) + 1);
        else hash.set(i, 1);
    }

    let max = 0;
    for(let [key, value] of hash) {
        if(value &amp;gt; max) {
            max = value;
            answer = key;
        }
    }
    return answer; // '사과'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for문을 사용한 것은 배열 안에 있는 요소들이 map을 사용한 hash 안에 있는지 없는지 탐색하기 위함이다.&lt;/li&gt;
  &lt;li&gt;키값에 대한 데이터를 저장할 때 배열의 특징이 아닌 객체같은 특징을 보여준다.(데이터를 추가시 밀어내거나 당기는 이벤트가 발생하지 않는 부분)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Hash" /><summary type="html">임의의 길이의 데이터를 고정된 길이의 데이터로 변환시키는 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Sliding Window</title><link href="http://localhost:4000/devlog/algorithm-slidingWindow.html" rel="alternate" type="text/html" title="[Algorithm] Sliding Window" /><published>2021-08-05T00:00:00+09:00</published><updated>2021-08-05T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-slidingWindow</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-slidingWindow.html">&lt;blockquote&gt;
  &lt;p&gt;배열에서 일정한 간격을 유지하면서 이동하며 탐색하는 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-sliding-window란&quot;&gt;Sliding Window란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-sliding-window란&quot;&gt;📌 Sliding Window란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;배열같은 형태를 띈 자료 구조에서 일정한 간격을 유지하면서 탐색하는 알고리즘 기법이다.&lt;/li&gt;
  &lt;li&gt;이중 for문보다 시간복잡도 측면에서 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;🎈 배열 안에서 연속되는 3개의 수의 합 중 가장 큰 합을 구하시오.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// For문을 사용했을 경우
const useFor = (m, arr) =&amp;gt; {
    let answer = 0;

    for(let i = 0; i &amp;lt; arr.length - m + 1; i++) {
        let sum = 0;

        for(let z = i; z &amp;lt; i + m; z++) {
            sum += arr[z];
            answer = Math.max(answer, sum);
        }
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문을 사용하게 되면 시간복잡도로 최대 O(N&lt;sup&gt;2&lt;/sup&gt;)가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const useSliderWindow = (m, arr) =&amp;gt; {
    let answer = 0;
    let sum = 0;

    for(let i = 0; i &amp;lt; m; i++) {
        sum += arr[i];
    }

    for(let i = m; i &amp;lt; arr.length; i++) {
        sum += arr[i] - arr[i - m];
        answer = Math.max(answer, sum);
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문과 달리 Slider Window는 배열의 처음과 끝을 &lt;b&gt;한번만&lt;/b&gt;탐색한다. (시간 효율이 좋다);&lt;/li&gt;
  &lt;li&gt;일정한 간격을 유지하기 때문에 범위의 앞과 뒤에서는 삭제와 삽입이 일어난다. (Deque 자료구조)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="TwoPointer" /><summary type="html">배열에서 일정한 간격을 유지하면서 이동하며 탐색하는 알고리즘</summary></entry><entry><title type="html">[JavaScript] This</title><link href="http://localhost:4000/devlog/this.html" rel="alternate" type="text/html" title="[JavaScript] This" /><published>2021-08-03T00:00:00+09:00</published><updated>2021-08-03T00:00:00+09:00</updated><id>http://localhost:4000/devlog/this</id><content type="html" xml:base="http://localhost:4000/devlog/this.html">&lt;blockquote&gt;
  &lt;p&gt;This의 개념과 작동 원리입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-this란&quot;&gt;📌 This란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;this는 간단하게 말해서 &lt;b&gt;식별자가 바라봐야할 대상&lt;/b&gt;을 의미합니다.&lt;/li&gt;
  &lt;li&gt;이게 무슨 말이지?? 라고 할 수 있겠지만, this는 함수가 호출되어 실행 컨텍스트가 생성되면 결정됩니다.&lt;/li&gt;
  &lt;li&gt;이 때, this가 &lt;b&gt;전역에 있을 경우&lt;/b&gt;!! 실행 컨텍스트가 생성되면서 가지게 되는 Lexical Environment(환경 정보들을 모아 놓은 객체)를 가리키게 됩니다.&lt;/li&gt;
  &lt;li&gt;그래서 식별자가 바라봐야할 대상을 의미한다는 것은 this를 가지고 있는 함수가 호출되었을 때 해당 함수 호출 주체를 가리키게 되는 것인지, 함수 바깥의 전역을 가리키게 되는 것인지에 대한 현상들을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-갑자기-lexical-environment&quot;&gt;🎈 갑자기 Lexical Environment?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;갑자기 왜 Lexical Environment일까?? 다음 예시를 보면 이해가 될 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
console.log(window.a) // a = 1
console.log(this.a) // a = 1

window.a = 3
console.log(a) // a = 3
console.log(this.a) // a = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;앞서 언급했던 ‘this는 전역에 있을 때 Lexical Environment를 가리킨다’라는 의미를 설명해주는 코드라고 생각한다.&lt;/li&gt;
    &lt;li&gt;var로 a를 선언하게 되면 a라는 변수는 전역 컨텍스트의 Lexical Environment에 저장된다.&lt;/li&gt;
    &lt;li&gt;this가 가리키는 것 또한 Lexical Environment이기 때문에 this.a로 접근이 가능함과 동시에 수정도 가능했던 것이다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;=&amp;gt; 이와같이 this가 전역 내부에 있다면 전역 Lexical Environment를 참조하게 되지만, 만약 함수 내부에서 this를 실행시키면 그 this는 함수가 호출되었을 때 생성된 실행 컨텍스트 Lexical Environment를 가리키게 될것인가? 상황에 따라 다르다. 이제부터 그 상황을 알아보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;-함수-안의-this&quot;&gt;📌 함수 안의 This&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-함수와-메서드의-차이점&quot;&gt;🌱 함수와 메서드의 차이점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수와 메서드를 나눌 수 있는 기준점은 &lt;b&gt;독립성&lt;/b&gt;이다.&lt;/li&gt;
  &lt;li&gt;함수는 그 자체로 가지고 있는 동작을 수행하지만, 메서드는 자신을 호출하는 대상 객체에 관한 동작을 수행한다.&lt;/li&gt;
  &lt;li&gt;여기서 포인트는 그 자체로 가지고 있는 동작을 수행하는 것과 함께 자신을 호출하는 대상 객체에 관한 동작을 수행하는 것도 메소드이다.&lt;/li&gt;
  &lt;li&gt;쉽게말해서 함수 앞에 “.”! 이 점을 찍냐의 유무에 따라 함수인지 메소드인지 구별할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(a)
}

func(1);   ---- (1)

var obj = {
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)과 (2)는 그 자체로 사용될 수 있는 함수이다. 여기서 (1)은 자체적으로 선언하지만, (2)는 obj라는 호출 주체를 통해서 함수를 사용했다.&lt;/li&gt;
  &lt;li&gt;이 차이가 (1)은 함수, (2)는 메소드로 구분짓는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-그래서-함수랑-메소드가-this랑-무슨-상관&quot;&gt;🌱 그래서 함수랑 메소드가 this랑 무슨 상관??&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수 내부에 있는 this는 전역을 가리킨다.&lt;/li&gt;
  &lt;li&gt;호출 주체를 함께 명시한 함수(ex. obj.num)의 this는 호출 주체를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(this, a)
}

func(1);   ---- (1)

var obj = {
    b: 1,
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드에서 func의 console.log에 this만 추가시켰다.&lt;/li&gt;
  &lt;li&gt;(1)에서의 this는 전역을 가리키게 되지만, (2)에서는 obj를 가리키게 된다. ((2)의 값으로{b: 1, num: func()}이 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-this의-예외-케이스&quot;&gt;🌱 this의 예외 케이스&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;this가 포함된 함수를 다른 변수에 할당한 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = function() {
            console.log(this);
        }
        c();         --- (2)

        var self = this;
        var d = function () {
            console.log(self);
        }
        d();          ----- (3)
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)은 b가 obj를 호출 주체를 명시하며 호출했기 때문에 this는 obj를 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(2)는 c 자체가 호출 주체를 명시하지 않고 호출했기 때문에 전역을 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(3)은 this를 b의 함수 안에 선언한 변수에 할당했기 때문에 이 때는 this가 상위의 호출 주체를 가리키게 된다.(여기에서는 obj)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이러한 현상을 ES6의 화살표 함수를 통해서도 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = () =&amp;gt; {
            console.log(this);
        }
        c();
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;c에 있는 this는 c가 호출했다고 해서 전역을 가리키는 것이 아니라 화살표 함수를 사용했기 때문에 위와 같은 현상이 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 또, 콜백 함수, 생성자 함수 내부에서의 this는 위와 같이 동일한 현상이 일어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;(apply, call, bind 추가 포스팅 예정)&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="javascript" /><category term="CoreJavaScript" /><category term="this" /><category term="call" /><category term="apply" /><category term="bind" /><summary type="html">This의 개념과 작동 원리입니다.</summary></entry><entry><title type="html">[JavaScript] 실행 컨텍스트</title><link href="http://localhost:4000/devlog/excutionContext.html" rel="alternate" type="text/html" title="[JavaScript] 실행 컨텍스트" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>http://localhost:4000/devlog/excutionContext</id><content type="html" xml:base="http://localhost:4000/devlog/excutionContext.html">&lt;blockquote&gt;
  &lt;p&gt;실행 컨텍스트(Excution context)의 개념입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트란&quot;&gt;실행 컨텍스트란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트-동작-원리&quot;&gt;실행 컨텍스트 동작 원리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트의-구조&quot;&gt;실행 컨텍스트의 구조&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-호이스팅hoisting&quot;&gt;Hoisting&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-예제&quot;&gt;예제&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-scope&quot;&gt;Scope&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트란&quot;&gt;📌 실행 컨텍스트란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수, 함수, 매개 변수등 환경 정보들을 수집하여 모아놓은 객체&lt;/li&gt;
  &lt;li&gt;Variable Environment, Lexical Environment, thisBinding으로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트-동작-원리&quot;&gt;📌 실행 컨텍스트 동작 원리&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-사전에-알아야할-cs지식&quot;&gt;🌱 사전에 알아야할 CS지식&lt;/h3&gt;

&lt;h4 id=&quot;-stack&quot;&gt;○ Stack&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Stack은 출구가 하나뿐인 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 쌓아 저장했다면, 데이터를 꺼낼 때는 역순으로 꺼내야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/stack.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;-queue&quot;&gt;○ Queue&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Queue는 양쪽이 모두 열려있는 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 저장했다면, 순서대로 데이터를 꺼낼 수 있는 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-그래서-실행-컨텍스트는&quot;&gt;🌱 그래서 실행 컨텍스트는?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;실행할 코드에 필요한 환경 정보들을 모아 놓은 실행 컨텍스트는 일반적으로 함수가 호출될 때 구성된다.&lt;br /&gt;
(전역은 코드가 실행되는 즉시 전역 환경 정보들을 모아 놓는다.)&lt;/li&gt;
  &lt;li&gt;전역을 첫번째로, 함수가 호출되면 각각 콜스택에 쌓인다.&lt;br /&gt;
(이 때, 콜스택에 쌓이면 해당 변수나 함수를 할당하다가 또다른 실행컨텍스트가 생기면 할당하던 컨텍스트는 잠시 중지된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트의-구조&quot;&gt;📌 실행 컨텍스트의 구조&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 크게 3가지로 구성되어 있다. (ThisBinding은 다음에 공부..!)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Variable Environment &lt;br /&gt;
실행 컨텍스트가 환경 정보를 수집하는 최초의 값을 유지하며 담는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lexical Environment &lt;br /&gt;
Variable Envionment에 정보를 담은 후, Variable Environment를 토대로 Lexical Environment를 만든다. Lexical Environment는 Variable Environment와 다르게 환경 정보의 변경 값을 적용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Variable Environment와 Lexical Environment는 또 environmentRecord, outerEnvironmentReference로 구성되어 있다.&lt;/li&gt;
    &lt;li&gt;environmentRecord가 실행 컨텍스트의 환경 정보 수집하는 역할을 이행하는 역할을 맡고 있다&lt;/li&gt;
    &lt;li&gt;outerEnvironmentReference는 만약 해당 컨텍스트에서 참조해야하는 정보가 없을 경우 제일 근접한 상위 컨텍스트의 Lexical environment를 참조하는 역할을 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;-호이스팅hoisting&quot;&gt;🎈 호이스팅(Hoisting)?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;호이스팅은 선언한 변수들이 위치와 상관없이 제일 상단에 선언되어 변수나 함수를 호출할 수 있는 현상을 말한다.
실제로 코드가 제일 상단에 올라가는 것이 아니라, 코드가 실행되면 실행 컨텍스트가 만들어지고 환경 정보를 수집하는데 자바스크립트 엔진은 환경 정보로 수집한 변수명들을 먼저 알게 되는 것이다. 이 과정을 호이스팅이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-예제&quot;&gt;📌 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
function b() {
    function c() {
        console.log(a);
        var a = 1;
    }
    c();
    console.log(a);
}
b()
console.log(a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;전역 실행 컨텍스트가 형성되고 변수 a와 함수 b를 환경 정보에 저장했다. / 콜스택에 전역 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;변수 a에 1을 할당하고, b에 함수를 할당하고 함수를 호출한다. / 콜스택에 함수 b의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 b의 환경 정보로 변수 c에 함수가 할당되어 저장된다.&lt;/li&gt;
  &lt;li&gt;함수 b안에 함수 c가 호출되었다. / 콜스택에 함수 c의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 c안에 환경 정보로 a가 선언되어 호이스팅 되었다. / c안의 console은 호이스팅된 a를 가리키기 때문에 호이스팅으로 선언만 된 a를 undefined를 가진다.&lt;/li&gt;
  &lt;li&gt;함수 c의 실행 컨텍스트가 종료됨으로 b의 실행 컨텍스트로 넘어간다. / 함수 b의 console.log(a)는 해당 컨텍스트 안에 a가 없기 때문에, outerEnvironmentReference로 인해 a를 가지고 있는 제일 근접한 상위 컨텍스트의 Lexical Environment를 참조하려 한다. (정확히는 해당 컨텍스트가 실행되기 전 Lexical Environment를 참조한다.)&lt;/li&gt;
  &lt;li&gt;마침 전역에 a가 있으므로 함수 b의 console.log(a)는 1값을 가진다.&lt;/li&gt;
  &lt;li&gt;b의 실행 컨텍스트가 종료되고 전역 console.log(a)는 마지막 전역에 있는 a를 참조하여 1값을 가진다. / 전역 실행 컨텍스트가 완료되어 종료됨으로 콜스택에는 아무것도 남아있지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-scope&quot;&gt;🎈 Scope&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;scope는 쉽게 말해 변수의 유효 범위이다. 실행 컨텍스트와 가리키는 범위는 같지만, 스코프는 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정하는 것이 목적이다.
위의 예시에 있는 outerEnvironmentReference가 상위 Lexical Environment를 참조하게되는 연결점, 외부 실행 컨텍스트에서 내부 실행 컨텍스트에 저장된 변수들은 접근할 수 없는 것, 이러한 것들을 스코프 체인이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수나 함수같은 환경 정보들을 모아놓은 객체이다.&lt;/li&gt;
  &lt;li&gt;실행 컨텍스트의 정보들은 순서에 따라 콜스택 형태로 저장되고 호출된다.&lt;/li&gt;
  &lt;li&gt;호이스팅은 컨텍스트와 연관이 있으며, 코드가 실행되기 전 환경 정보를 저장하여 미리 변수명 등을 알게되는 자바스크립트 엔진에 의해 일어난다.&lt;/li&gt;
  &lt;li&gt;스코프는 실행 컨텍스트가 접근할 수 있는 변수나 함수들에게 순서를 부여하는 역할이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="javascript" /><category term="CoreJavaScript" /><category term="ExcutionContext" /><category term="LexicalEnvironment" /><category term="VariableEnvironment" /><summary type="html">실행 컨텍스트(Excution context)의 개념입니다.</summary></entry><entry><title type="html">[Algorithm] Two Pointer</title><link href="http://localhost:4000/devlog/algorithm-toPointer.html" rel="alternate" type="text/html" title="[Algorithm] Two Pointer" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-toPointer</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-toPointer.html">&lt;blockquote&gt;
  &lt;p&gt;1차원의 배열에서 2개의 포인터를 주어 풀어내는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-two-pointer란&quot;&gt;Two Poiner란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-two-pointer란&quot;&gt;📌 Two Pointer란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;의미 그대로 2개의 포인터를 가진다.&lt;/li&gt;
  &lt;li&gt;1차원 배열에 포인터를 2개를 두어 각각 포인터들을 사용해 순차적으로 비교할 수 있다.&lt;/li&gt;
  &lt;li&gt;이중 for문을 사용해도 되지만, 이중 for문은 시간복잡도가 O(N&lt;sup&gt;2&lt;/sup&gt;)이고 Two Pointer는 O(N)이어서 시간적으로 효율이 더 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 두 배열을 오름차순으로 합치는 알고리즘을 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr1 = [1, 3, 5];
let arr2 = [2, 3, 4, 6, 8];

const twoPointer = (arr1, arr2) =&amp;gt; {
   let answer = [];
   let i = z = 0;

    while(i &amp;lt; arr1.length &amp;amp; z &amp;lt; arr2.length) {
       if(arr1[i] &amp;lt; arr2[z]) {
           answer.push(arr1[i++]);
       }
       if(arr1[i] &amp;gt; arr2[z]) {
           answer.push(arr2[z++]);
       }
       if(arr1[i] === arr2[z]) {
        answer.push(arr1[i++], arr2[z++])
       }
   }

   while(i &amp;lt; arr1.length) answer.push(arr1[i++]);
   while(z &amp;lt; arr2.length) answer.push(arr2[z++]);

   return answer;
}

twoPointer(arr1, arr2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 concat으로 합친다음 sort으로 정렬해도 되는 문제라고 생각이 든다.&lt;/li&gt;
  &lt;li&gt;하지만 sort는 최악의 경우 O(N&lt;sup&gt;2&lt;/sup&gt;)이 될 수 있기 때문에 시간복잡도 측면에서는 효율이 좋지 못하다.&lt;/li&gt;
  &lt;li&gt;Two Pointer 알고리즘은 포인터가 배열의 끝에 다다르면 마무리되기 때문에 시간복잡도 측면에서 sort보다 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="TwoPointer" /><summary type="html">1차원의 배열에서 2개의 포인터를 주어 풀어내는 알고리즘입니다.</summary></entry><entry><title type="html">[TypeScript] 기초 개념</title><link href="http://localhost:4000/devlog/basicType.html" rel="alternate" type="text/html" title="[TypeScript] 기초 개념" /><published>2021-07-29T00:00:00+09:00</published><updated>2021-07-29T00:00:00+09:00</updated><id>http://localhost:4000/devlog/basicType</id><content type="html" xml:base="http://localhost:4000/devlog/basicType.html">&lt;blockquote&gt;
  &lt;p&gt;TypeScript의 기본 타입 종류에 대한 포스트입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;목차&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-typescript란&quot;&gt;TypeScript란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-basic&quot;&gt;Basic&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-변수-지정&quot;&gt;변수 지정&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-변수-지정2&quot;&gt;변수 지정2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-typescript란&quot;&gt;📌 TypeScript란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 사용하는 JavaScript는 Runtime 언어, 즉 동적 언어이다.&lt;br /&gt;
동적 언어란 실행될 때 변수의 타입이 결정되기 때문에 사용자가 오류를 그대로 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만 TypeScript는 정적 언어이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정적 언어란 컴파일될 때 변수의 타입이 결정되기 때문에 실행 전에 오류를 볼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;언뜻보면 동적 언어가 자동으로 변수의 타입을 정해주기 때문에 정적 타입보다 동적 타입이 좋아보일 수 있지만…&lt;/li&gt;
  &lt;li&gt;개발자가 의도하지 않았던 동작까지 동적 언어가 처리할 가능성이 있기 때문에 정적 언어로 바꾸어주어 안전하게 코드를 관리하는 것이 선호되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이러한 이유로 TypeScript를 Project에 적용시키는 것이 증가하고 있는 추세이다.📈&lt;/p&gt;

&lt;h2 id=&quot;-basic&quot;&gt;📌 Basic&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-변수-지정&quot;&gt;🌱 변수 지정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 변수를 지정하는 것은 간단하다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const num = 1;
=&amp;gt; const num: number = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이런 식으로 변수옆에 변수가 무슨 타입의 데이터를 가지는지 명시해주는 것이다.&lt;br /&gt;
(Boolean, string, undefined, null 등이 있을 것이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-변수-지정2&quot;&gt;🌱 변수 지정2&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;일반적인 기본형 데이터 타입으로 보지 못했던 것들이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-unknown&quot;&gt;1. unknown&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: unknown = 0;
a = 'hello';
a = '2';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;아직 값이 정해지지 않았을 경우 unknown을 사용한다.&lt;/li&gt;
  &lt;li&gt;TypeScript에서 JavaScript의 라이브러리를 사용할 경우 간혹 사용되곤 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-any&quot;&gt;2. any&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: any = 0;
a = 'hello';
a = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;any도 unknown과 기능적으로는 비슷하지만 의미론적으로 다르다.&lt;/li&gt;
  &lt;li&gt;any는 표현 그대로 ‘아무거나 다 가능!’이다.&lt;/li&gt;
  &lt;li&gt;TypeScript 자체가 정적 언어인데 이러한 특성을 무너뜨리는(?) 특성으로 잘 사용되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-void&quot;&gt;3. void&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;void는 함수에서 아무것도 리턴되지 않는 경우를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function hello():void {
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;hello함수는 현재 아무것도 return하고 있지 않다..!&lt;/li&gt;
  &lt;li&gt;이럴 경우 함수의 값으로 void를 선언해주는데, void는 생략이 가능하다! 그래서 이 부분은 각 사마다의 컨벤션에 따라서!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-never&quot;&gt;4. never&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;never는 함수가 에러를 리턴하거나 리턴 값 자체를 내보내지 않는 경우(무한 루프)에 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function error(): never {
    throw new Error(message);
    while(true) {console.log('infinity loop')}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5-object&quot;&gt;5. object&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;object는 데이터 타입이 object일 경우에 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function obj(obj: object) {
}
obj({one: 1});
obj({two: 2});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addNum(num1: number, num2: number2): number {
    return num1 + num2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이렇게 각 함수의 매개변수에도 number로 선언해줄수 있고 함수에 대한 return값의 타입도 지정해 줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript의 함수에서는 지정된 매개변수를 일일히 선언해주지 않으면 에러가 일어난다.&lt;/li&gt;
  &lt;li&gt;때문에 만일 함수에 매개변수의 값을 넘겨주지 않고 싶을 때는 &lt;b&gt;Optional parameter&lt;/b&gt;로 지정해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function printName(firstName: string, lastName?: string): string {
    console.log(firstName);
    console.log(lastName);
}
printName(SuYeon, Kim);
printName(SuYeon)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이렇게 매개 변수 뒤에 ?를 붙여주면 그 매개변수는 전달해주지 않아도 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수의 매개변수에 전달되는 값이 없을 경우 default값도 지정해줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function greeting(message: string = 'hello') {
    console.log(message);
}
greeting();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수 매개변수의 타입이 일정할 때, 특정 개수가 지정되지 않고 여러개를 할당하고 싶으면 Rest parameter를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addNum(...numbers: number[]): number {
    return numbers.reduce((a, b) =&amp;gt; a + b);
}
console.log(addNum(1, 2)); // 3
console.log(addNum(1, 2, 3)); //6
console.log(addNum(1, 2, 3, 4, 5, 6, 7)); // 28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;array에서도 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const students: string[] = ['철수', '영희'];
const scores: Array&amp;lt;number&amp;gt; = [1, 2, 3];

function printArray(students: readonly string[]) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;보통 string[]로 할 수 있지만 Array&lt;number&gt;같이 선언할 수도 있다.&lt;/number&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 여기서 readonly는 선언 시, 생성자 내부에서만 값을 할당할 수 있다.(불변성을 가질 수 있다!)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript는 정적 언어이기 때문에 코드의 오류를 최소화하기 위한 목적을 가지고 사용한다.&lt;/li&gt;
  &lt;li&gt;각 변수의 데이터 값에 맞는 타입을 선언해주어야 한다.&lt;/li&gt;
  &lt;li&gt;함수에도 여러 가지 기능들을 활용하며 TypeScript를 사용하자!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="typescript" /><category term="TypeScript" /><category term="basic" /><summary type="html">TypeScript의 기본 타입 종류에 대한 포스트입니다.</summary></entry><entry><title type="html">[TypeScript] Alias Union Discriminated Intersection</title><link href="http://localhost:4000/devlog/alias.html" rel="alternate" type="text/html" title="[TypeScript] Alias Union Discriminated Intersection" /><published>2021-07-29T00:00:00+09:00</published><updated>2021-07-29T00:00:00+09:00</updated><id>http://localhost:4000/devlog/alias</id><content type="html" xml:base="http://localhost:4000/devlog/alias.html">&lt;blockquote&gt;
  &lt;p&gt;Alias Union Discriminated Intersection에 관한 포스트입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-alias&quot;&gt;Alias&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-union&quot;&gt;Union&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-discriminated&quot;&gt;Discriminatedd&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-alias&quot;&gt;📌 Alias&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 number, string같은 데이터를 각 타입에 맞게 선언해주었다면(ex.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const a:number = 1&lt;/code&gt;), Alias는 사용자가 직접 type을 만들어주는? 이라고 이해할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-type-alias&quot;&gt;1. Type Alias&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Greeting = string;
type Num = number;

const hi: Greeting = 'hi';
const hello: Greeting = 'hello';

// 객체에도 가능하다.
type Greeting = {
    time: number;
    greeting: string;
}
const obj: Greeting = {
    time: 8,
    greeting: 'hello'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-string-literal-types&quot;&gt;2. String Literal Types&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;위와 같이 타입을 지정해줄 수 있지만, 하나의 문자열을 지정해줄 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type name = 'suyeon';
let me: name;
me = 'suyeon'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-union&quot;&gt;📌 Union&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Union은 Alias의 확장판(?)의 느낌이다.&lt;/li&gt;
  &lt;li&gt;한가지 타입만 지정하는 String Literal Types와 달리 하나 이상의 데이터들을 지정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Direction = 'left' | 'right' | 'up' | 'down'
function go(direction: Direction) {
    console.log(direction);
}
go('up')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;저렇게 or연산자로 여러가지를 선언해주면 Direction이라는 Alias로 지정한 up, down, left, right라는 4가지의 데이터들을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-discriminated&quot;&gt;📌 Discriminated&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;일반적인 String Literal Property가 있는 경우 Discriminated라 말한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type SuccessState = {
    result: 'success';
    response: {
        body: string;
    };
}
type FailState = {
    result: 'fail';
    reason: string;
}
type LoginState = SuccessState | FailState;
function printLoginState(state: LoginState) {
    if(state.result === 'success') {
        console.log(state.result);
    }
    if(state.result === 'fail') {
        console.log(state.result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-intersection&quot;&gt;📌 Intersection&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Intersection은 간단히 말해 Alias를 합치는 것으로 연산자 &amp;amp;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type wecoder1 = {
    name1: 'sy';
    name2: 'ym';
    name5: 'dh';
}

type wecoder2 = {
    name3: 'ds';
    name4: 'mh';
}

function werecordTeam(person: wecorder1 &amp;amp; wecorder2) {
    console.log(person.name1, person.name2, person.name3, person.name4, person.name5);
}

werecordTeam({
    name1: 'sy',
    name2: 'ym',
    name3: 'ds',
    name4: 'mh',
    name5: 'dh',
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="typescript" /><category term="TypeScript" /><category term="Alias" /><category term="Union" /><category term="Discriminated" /><category term="Intersection" /><summary type="html">Alias Union Discriminated Intersection에 관한 포스트입니다.</summary></entry><entry><title type="html">[JavaScript] Data Type</title><link href="http://localhost:4000/devlog/dataType.html" rel="alternate" type="text/html" title="[JavaScript] Data Type" /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>http://localhost:4000/devlog/dataType</id><content type="html" xml:base="http://localhost:4000/devlog/dataType.html">&lt;blockquote&gt;
  &lt;p&gt;[Core JavaScript] Data Type에 대한 개념와 작동 원리입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-data-type&quot;&gt;Data Type&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-data-할당-원리&quot;&gt;Data 할당 원리&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-가변성과-불변성&quot;&gt;가변성과 불변성&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-얕은-복사-깊은-복사&quot;&gt;얕은 복사와 깊은 복사&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-복사를-하는-이유&quot;&gt;복사를 하는 이유&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-그래서-얕은-복사-깊은-복사가-머야&quot;&gt;그래서 얕은 복사, 깊은 복사가 머야?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-data-type&quot;&gt;📌 Data Type&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScrip의 데이터 타입은 크게 기본형(primitive), 참조형(reference)으로 나뉜다.&lt;/li&gt;
  &lt;li&gt;기본형에는 String, Number, Boolean, Null, undefined, Symbol 등으로 나뉜다.&lt;/li&gt;
  &lt;li&gt;참조형에는 Object, Array, Function, Date 등으로 나뉜다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본형과 참조형은 가변성인지, 불변성인지에 따라 나뉘게 되는데, 가변성과 불변성을 이해하려면 약간의 컴퓨터 메모리에 대한 지식이 필요하다. (추후에 자세하게 공부할 것!)
=&amp;gt; 결론적으로 변수와 식별자는 메모리 고유의 주소값에 저장되고 그것을 참고하는 식으로 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;-data-할당-원리&quot;&gt;🌱 Data 할당 원리&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 6
let b = 'hello'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 형태로 변수가 선언되면 이 메모리들은 각각 컴퓨터 메모리에 이렇게 저장된다.
&lt;img src=&quot;/assets/img/javascript/dataType.png&quot; width=&quot;300px&quot; height=&quot;200px&quot; /&gt; (글씨 어떻할거야…💩)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;저 코드가 메모리에 영향을 끼치는 순서를 순서대로 나열하자면…&lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;변수명 a가 선언된다. -&amp;gt; 메모리 주소 1001번에 a가 저장된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;변수명 a에 6이 할당된다. -&amp;gt; 기존에는 undefined, 6은 곧바로 a의 주솟값인 1001에 저장되는 것이 아니라 새로운 주소 5001에 할당되고 1001에는 a의 값으로 5001주소가 참조된다. (a가 6을 가지고 있는 메모리 영역을 검색해서 찾는 원리)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;위의 순서가 변수 b에 똑같이 적용된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 변수 데이터가 기본형일 경우 이러한 원리로 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;위에서는 데이터 타입이 기본형이었다. &lt;br /&gt;
그렇다면 참조형 데이터는 기본형의 원리와는 다른가??&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;a는 객체로 할당했다. 이것은 다음과 같다. &lt;br /&gt;
&lt;img src=&quot;/assets/img/javascript/dataType2.png&quot; width=&quot;500px&quot; height=&quot;200px&quot; /&gt; (글씨 어떻게 할거냐고…💩)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;참조형은 기본형과는 다르게 객체 데이터에 대한 주소를 한번 더 참조한다.&lt;/li&gt;
  &lt;li&gt;a라는 변수명을 1001에 할당하고난 뒤에 값은 5001 주소에 저장하지만, 객체 안에 one, two의 변수명들은 따로 7001에 저장시킨다.&lt;/li&gt;
  &lt;li&gt;이것으로 그치는 것이 아니라 각각 one, two에 할당된 1, 2는 아까 기본형 데이터와 같이 다른 메모리 주소에 저장되고 one, two의 값은 그 주소가 할당된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이 기본형과 참조형의 데이터 저장 스타일이 각기 다르기 때문에 앞으로 여러 이슈들이 발생한다. (가변성과 불변성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-가변성과-불변성&quot;&gt;📌 가변성과 불변성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가변성과 불변성은 한마디로 정의하면 데이터 변환의 가능여부에 따라 나뉘는 것이 아니다.&lt;/li&gt;
  &lt;li&gt;데이터를 변환했을 때 원래 값이 해당 주소에서 다른 값으로 갱신되는지의 여부에 따라 달라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 1
let b = a
a = 2
console.log(a === b) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let c = {one: 1, two: 2}
let d = c
c.one = 3
console.log(c === d) // true..?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;기본형과 참조형의 개념을 모른다면 위의 코드에서 이상한 점을 느꼈을 것이다.&lt;/li&gt;
    &lt;li&gt;각 마지막 console에서 a와 b는 false가 맞는 것 같은데 c와 d는 왜 true일까??&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;이것이 불변성의 특징이다. a는 1 데이터의 주소를 할당받았고 b는 a의 1 데이터의 주소를 할당받았다.&lt;/li&gt;
  &lt;li&gt;그리고 a는 2로 다시 재할당받았는데…! 여기서!! 중요한 점은 b는 데이터의 주소가 변경되지 않았다는 것이다.&lt;/li&gt;
  &lt;li&gt;그렇다는 것은 b가 할당받고 있는 데이터의 주소에는 1이 있다는 것!! 1은 a가 2로 바뀌었다고 해서 사라지지 않았다!! ⭐️&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이것으로 기본형은 모두 불변성의 특징을 가지고 있다고 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;마찬가지로 c와 d또한 위와같은 플로우를 가진다.&lt;/li&gt;
  &lt;li&gt;하지만 c와 d는 한단계 더 깊게 들어간다. 위의 객체가 데이터 저장하는 원리에서 나온 것처럼 말이다.&lt;/li&gt;
  &lt;li&gt;즉, b와 c는 객체 전체에 대한 주소를 할당받고, 객체 전체에 대한 주소에서의 프로퍼티 요소은 하나하나 다른 데이터 영역에 저장되기 때문에 참조하는 데이터 범위를 할당받는다.&lt;/li&gt;
  &lt;li&gt;이 때!!! 객체 안에 프로퍼티들이 다른 데이터로 재할당받게 되는 경우!!(위에 c.one = 3같은…).. 이 경우는 위의 예시와는 다르게 참조하고 있는 범위 안의 데이터가 바뀌게 된다.&lt;/li&gt;
  &lt;li&gt;하지만 처음 c와 d의 주솟값은 변하지 않았기 때문에 c와 d는 일치로 나오는 것이다! (이 부분은 추후에 공부하기..!)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;만일 참조형 데이터 안에 또 참조형 데이터가 있다면..?&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: [1, 2, 3]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 경우는 조금 더 복잡할 뿐..! 위의 예시를 적용시키면 가능하다!&lt;/li&gt;
  &lt;li&gt;a의 변수와 함께 객체의 주소가 함께 할당된다. -&amp;gt; 객체의 주소에는 각 데이터들을 참조하는 영역을 할당받는다. -&amp;gt; two에서는 two라는 변수와 [1, 2, 3]을 담는 배열의 주소값을 할당받는다. -&amp;gt; 각 프로퍼티의 index가 이름이 되고 그에 대한 값으로 1, 2, 3이 각각 할당된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이러한 특징들로 보아 참조형 데이터는 프로퍼티 값들만 변경되었을 경우 데이터 주소는 변하지 않으므로 &lt;b&gt;‘가변’&lt;/b&gt;의 특징을 가지는 것이다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;참조형-데이터가-불변일-경우&quot;&gt;참조형 데이터가 불변일 경우?&lt;/h6&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = {one: 1, two: 2}
let b = a
let a = {three: 3, four: 4}
console.log(a === b) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 이 경우에는 a가 three, four라는 프로퍼티를 가진 값들의 주소를 재할당받은 것이기 때문에 &lt;b&gt;‘불변’&lt;/b&gt;의 특징을 가진다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-얕은-복사-깊은-복사&quot;&gt;📌 얕은 복사, 깊은 복사&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-복사를-하는-이유&quot;&gt;🌱 복사를 하는 이유!&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;원본 데이터를 사용할 때 주의해야할 점이 있다. 바로 원본 데이터가 수정되는가 안되는가의 여부이다.&lt;/li&gt;
  &lt;li&gt;‘왜? 원본 데이터가 수정되면 안되는가?’에 의문이 들 수 있지만, 사실 간단한 이유이다.&lt;/li&gt;
  &lt;li&gt;원본 데이터를 한차례 수정하게 되었을 경우, 다음에 원본 데이터를 사용하려면 수정된 데이터를 감안하고 사용해야한다.&lt;/li&gt;
  &lt;li&gt;그렇게 누적이 되다보면 원본데이터에 무슨 데이터가 있는지 확실하게 알지 못하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 따라서 원본데이터는 자체로 불변성을 지니는 것이 좋다!&lt;/p&gt;

&lt;h3 id=&quot;-그래서-얕은-복사-깊은-복사가-머야&quot;&gt;🌱 그래서 얕은 복사, 깊은 복사가 머야?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;얕은 복사 : 객체 프로퍼티 안에 객체 프로퍼티가 있는 경우, 제일 상위의 객체만 복사되고 하위의 객체 프로퍼티는 원래 그대로의 주솟값을 가지는 것&lt;/li&gt;
  &lt;li&gt;깊은 복사 : 객체 프로퍼티 안에 있는 모든 경우의 값들을 새로운 주소에 할당하는 것&lt;br /&gt;
객체 프로퍼티 내부에 하위 객체가 값으로 지정되어 있는 경우 위와 같은 가변성을 띈 객체로 되기 때문에 일일히 불변성을 가진 객체로 만들어주어야한다. (&lt;a href=&quot;#-가변성과-불변성&quot;&gt;가변성과 불변성&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 얕은 복사, 깊은 복사에 대한 코드소개는 생략한다. 대신 불변 객체를 만들어주는 라이브러리를 소개로 마치려 한다.(immer.js, immutable.js, baobab.js)&lt;/p&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 타입에는 기본형, 참조형이 있다.&lt;/li&gt;
  &lt;li&gt;기본형은 자체로 불변성을 띄지만, 참조형은 상황에 따라 불변성을 띌 수도 가변성을 띌 수도 있다.&lt;/li&gt;
  &lt;li&gt;참조형 데이터를 불변 객체로 만들기 위해서는 그에 맞는 함수를 구현하거나 라이브러리(immer.js, immutable.js, baobab.js 등)을 사용해야 한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="javascript" /><category term="CoreJavaScript" /><category term="DataType" /><category term="mutable" /><category term="immutable" /><summary type="html">[Core JavaScript] Data Type에 대한 개념와 작동 원리입니다.</summary></entry></feed>