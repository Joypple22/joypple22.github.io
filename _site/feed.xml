<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2022-02-13T11:28:43+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Syeon</title><subtitle>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</subtitle><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><entry><title type="html">[TIL] React study</title><link href="http://localhost:4000/devlog/TIL.html" rel="alternate" type="text/html" title="[TIL] React study" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/devlog/TIL</id><content type="html" xml:base="http://localhost:4000/devlog/TIL.html">&lt;blockquote&gt;
  &lt;p&gt;실행 컨텍스트(Excution context)의 개념입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-1-search-input과-btn&quot;&gt;Search Input과 Btn&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-2-memo-usecallback&quot;&gt;memo, useCallback&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-컴포넌트-역할분담mvc&quot;&gt;컴포넌트 역할분담(MVC)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-search-input과-btn&quot;&gt;📌 Search Input과 Btn&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;searchInput과 Btn이 API Call 등 같은 기능을 수행하는 역할을 맡고 있다면 각각 요소들에게 다른 이벤트를 적용하는 것이 아니라 from으로 묶고 onSubmit 이벤트를 걸어 놓는 방법도 있다.&lt;/p&gt;

    &lt;p&gt;(before)
&lt;img src=&quot;/assets/img/react/2022-02-13-2.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;(after)
&lt;img src=&quot;/assets/img/react/2022-02-13-1.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-memo-usecallback&quot;&gt;📌 memo, useCallback&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;memo가 컴포넌트에 사용되면 해당 컴포넌트가 받고 있는 prop의 값이 변경되었을 경우에만 리랜더링이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;useCallback은 useEffect와 비슷하게 의존성 배열에 할당된 값이 변할 때만 재생성되어 랜더링이 일어날 때마다 재생성되는 것을 막는다.&lt;/li&gt;
  &lt;li&gt;하지만 useCallback으로 할당한 변수를 prop으로 내리고 한번 더 내리게되면 useCallback의 성격을 잃어버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-컴포넌트-역할분담mvc&quot;&gt;📌 컴포넌트 역할분담(MVC)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MVC 디자인 패턴을 살짝 적용시키면 모델, 뷰, 컨트롤러를 분리시켜 하나의 컴포넌트가 맡는 역할을 잘게 쪼개어 분담시키는 것이 중요하다. Test 코드를 짤 때나 재사용성, 유지보수하기에 효과적인 기술이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;API 통신을 하는 여러가지 비즈니스 로직을 Class로 묶어두면 공통으로 사용할 수 있는 헤더나 매개변수를 일일히 할당하지 않고 사용할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/react/2022-02-13-3.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="react" /><summary type="html">실행 컨텍스트(Excution context)의 개념입니다.</summary></entry><entry><title type="html">[Algorithm] 프로그래머스 Level 1 - 모의고사</title><link href="http://localhost:4000/devlog/algorithm.html" rel="alternate" type="text/html" title="[Algorithm] 프로그래머스 Level 1 - 모의고사" /><published>2021-11-04T00:00:00+09:00</published><updated>2021-11-04T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm.html">&lt;blockquote&gt;
  &lt;p&gt;프로그래머스 Level 1 모의고사 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-다른-사람-코드를-참고한-리펙터링&quot;&gt;다른 사람 코드를 참고한 리펙터링&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.&lt;/p&gt;

  &lt;p&gt;1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, …&lt;/p&gt;

  &lt;p&gt;1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.&lt;/p&gt;

  &lt;p&gt;제한 조건
시험은 최대 10,000 문제로 구성되어있습니다.
문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution(answers) {
    let correct = {
        1: 0,
        2: 0,
        3: 0
    }

    let one = [1, 2, 3, 4, 5];
    let two = [2, 1, 2, 3, 2, 4, 2, 5];
    let three = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];

    for(let i = 0; i &amp;lt; answers.length; i++) {
        if(answers[i] === one[i % 5]) {
            correct[1] += 1;
        }
        if(answers[i] === two[i % 8]) {
            correct[2] += 1;
        }
        if(answers[i] === three[i % 10]) {
            correct[3] += 1;
        }
    }

    let answer = Object.entries(correct).sort((a, b) =&amp;gt; b[1] - a[1]);
    let return1 = [];

    function DFS() {
      for(let i = 0; i &amp;lt; answer.length; i++) {
        if(i === answer.length - 1) {
            return return1.push(parseInt(answer[i][0]));
        }
        if(answer[i][1] &amp;gt; answer[i + 1][1]) {
          return return1.push(parseInt(answer[i][0]));
        }
        if(answer[i][1] === answer[i + 1][1]) {
          return1.push(parseInt(answer[i][0]));
        }
      }
    }
    DFS();
    return return1.sort((a, b) =&amp;gt; a - b);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;참…. 봤을 때부터 드럽다…&lt;/li&gt;
  &lt;li&gt;어찌 어찌 풀기는 했지만… 메소드를 어거지로 붙여서 완성시킨 느낌이 강하게 든다…ㅠ&lt;/li&gt;
  &lt;li&gt;이 코드로 의도한 바는 다음과 같다.&lt;/li&gt;
  &lt;li&gt;먼저 사람1, 사람2, 사람3에 대한 답안 패턴을 array에 담는다.&lt;/li&gt;
  &lt;li&gt;문제의 정답이 담겨져 있는 array의 index는 문제의 번호라고 할 수 있을 것 같다. 각 문제의 번호는 각 사람들이 찍은 정답 패턴의 index와 동일할 것이다.&lt;/li&gt;
  &lt;li&gt;사람들이 찍은 정답 패턴은 0 ~ x까지 정해졌기 때문에 문제 번호가 x를 넘어가면 다시 index 0부터 시작된다.&lt;/li&gt;
  &lt;li&gt;이것을 통해 사람들이 찍은 정답 패턴의 나머지를 반복시켜 각 문제 번호의 정답과 비교할 수 있다.&lt;/li&gt;
  &lt;li&gt;정답을 비교하면서 문제의 정답과 사람들의 정답이 일치하면 사람들 정답에 해당되는 correct의 키값을 +1 시켜준다.&lt;/li&gt;
  &lt;li&gt;키값을 비교하기 위해 Object.entries를 사용하여 array로 만들고 DFS라는 함수를 통해 각 사람들의 숫자를 비교해준다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비교한 값들을 return1 배열에 push하고 return한다…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;참…너무 복잡하다.. 부끄럽지만 DFS라고 해놓고 재귀함수도 안썼다..(쓸 것 같았는데…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-다른-사람-코드를-참고한-리펙터링&quot;&gt;📌 다른 사람 코드를 참고한 리펙터링&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution (answers) {
  let answer = [];

  let one = [1, 2, 3, 4, 5];
  let two = [2, 1, 2, 3, 2, 4, 2, 5];
  let three = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];

  let oneCorrect = answers.filter((a, i) =&amp;gt; a === one[i % one.length]).length;
  let twoCorrect = answers.filter((a, i) =&amp;gt; a === two[i % two.length]).length;
  let threeCorrect = answers.filter((a, i) =&amp;gt; a === three[i % three.length]).length;

  let max = Math.max(oneCorrect, twoCorrect, threeCorrect);

  max === oneCorrect &amp;amp;&amp;amp; answer.push(1);
  max === twoCorrect &amp;amp;&amp;amp; answer.push(2);
  max === threeCorrect &amp;amp;&amp;amp; answer.push(3);

  return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;와우… 완전 깔끔하다..!&lt;/li&gt;
  &lt;li&gt;코드가 무엇을 하는건지 명확하게 파악할 수 있어서 더욱 보기 좋은 것 같다.&lt;/li&gt;
  &lt;li&gt;첫번째로 one, two, three를 통해 각 사람들의 정답 패턴을 지정해준다.&lt;/li&gt;
  &lt;li&gt;각 사람들의 정답패턴과 문제 정답을 filter 메소드를 통해서 걸러준다..! (filter로 return된 array의 length는 당연히 각 사람들의 정답을 맞춘 개수일 것..!)&lt;/li&gt;
  &lt;li&gt;각 사람들 중에서 제일 높은 수를 찾아준다..! Math.max가 3개의 수도 가능한 것인지 이제 알았다..!(알았으면 뻘짓안하고 진작 사용했을텐데..)&lt;/li&gt;
  &lt;li&gt;제일 높은 수와 각 사람들의 정답 개수가 일치하면 answer에 push해준다! (순서대로 1, 2, 3선언해주었기 때문에 굳이 sort가 필요없다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며…&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;아직은 알고리즘을 많이 풀어보지 않았으니 다양한 메소드를 활용하는 능력이 부족할 수 있을 것 같다.&lt;/li&gt;
  &lt;li&gt;문제를 어떻게 하면 해결할 수 있는지.. 효율적으로, 가독성 있게.. 작성하는 코드는 무작정 머릿속에서 어떻게든 해결하려는 단계를 넘어서 고민하고 생각해봐야하는 문제인 것 같다.&lt;/li&gt;
  &lt;li&gt;더 좋은 코드를 위해 오늘도 열심히!!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="filter" /><summary type="html">프로그래머스 Level 1 모의고사 문제입니다.</summary></entry><entry><title type="html">[DOM] DOM(document object model)</title><link href="http://localhost:4000/devlog/dom.html" rel="alternate" type="text/html" title="[DOM] DOM(document object model)" /><published>2021-10-23T00:00:00+09:00</published><updated>2021-10-23T00:00:00+09:00</updated><id>http://localhost:4000/devlog/dom</id><content type="html" xml:base="http://localhost:4000/devlog/dom.html">&lt;blockquote&gt;
  &lt;p&gt;여러 DOM에 대한 포스팅을 읽고 난 뒤 나름대로 정리한 포스팅입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-dom-이란&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-event&quot;&gt;Event&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-참고-자료&quot;&gt;참고 자료&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-dom이란&quot;&gt;📌 DOM이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DOM은 document object model의 약자로 JavaScript를 통해 HTML를 컨트롤하기 위해 도입되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;브라우저가 렌더링되는 과정
&amp;lt;img src=/assets/img/c_s/dom-tree.png alt=”img” width=’700px’ /&amp;gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;각각 HTML과 CSSOM으로부터 HTML과 CSS를 파서한 후 트리를 만든다.&lt;/li&gt;
    &lt;li&gt;HTML트리와 스타일 규칙은 어테치먼트 과정에서 하나로 합쳐진다.&lt;/li&gt;
    &lt;li&gt;이렇게 만들어진 랜더 트리를 통해 그려지고 브라우저에 표시된다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림은 브라우저가 서버로부터 사용자가 요청한 페이지를 화면 상에 그리는 순서를 요약한 것이다.&lt;/li&gt;
  &lt;li&gt;순서에 따르면 HTML을 파서한 이후 DOM이 개입하여 DOM트리를 구성한다.&lt;/li&gt;
  &lt;li&gt;DOM은 HTML에 영향을 끼치지만 CSS에는 일반적으로 관여하지 않기 때문에 CSS 가상 선택자 같은 요소에 영향을 주지 못한다.&lt;/li&gt;
  &lt;li&gt;이렇듯 DOM과 HTML은 서로 다를 수 있으며 HTML은 단순하게 화면에 보이고자 하는 모양과 구조를, DOM은 HTML을 객체화하여 유효하지 않은 HTML을 수정하기도 하고 직접 HTML에 간섭하여 조작할 수 있다.&lt;/li&gt;
  &lt;li&gt;또한, 브라우저와 콘솔 element 텝에서 보이지 않는 테그들은(display: none같은…) DOM에는 하나의 노드로 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-event&quot;&gt;📌 Event&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DOM를 통해 HTML에 접근할 수 있게 되면서 HTML에 특정 이벤트를 원하는 HTML요소에 적용할 수 있게 되었다.&lt;/li&gt;
  &lt;li&gt;querySelector, getElementById, getElementsByTagName, getElementsByClassName 등을 활용하여 특정 HTML 요소에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;접근한 요소에 addEventListener를 사용하여 특정 이벤트를 적용시킬 수 있다. (이벤트 종류: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/Events&quot;&gt;MDN-event&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;각 createElement, classList(add, remove, toggle), setAttribute 등 HTML 요소를 컨트롤 할 수 있는 다양한 메소드들이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Naver D2와 여러 포스팅을 읽고 나름대로 중요하다고 생각하는 것들을 요약해보았다.&lt;/li&gt;
  &lt;li&gt;특히 Naver 포스트는 많이 어렵다고 느껴 반복적으로 읽고 학습하는 것이 중요해보였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-참고-자료&quot;&gt;🎈 참고 자료&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;Naver D2 - 브라우저는 어떻게 동작할까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@surim014/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot;&gt;DOM이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@surim014/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot;&gt;HTML, DOM 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="computer_science" /><category term="DOM" /><category term="event" /><summary type="html">여러 DOM에 대한 포스팅을 읽고 난 뒤 나름대로 정리한 포스팅입니다.</summary></entry><entry><title type="html">[Algorithm] 문자 숫자열과 영단어</title><link href="http://localhost:4000/devlog/algorithm.html" rel="alternate" type="text/html" title="[Algorithm] 문자 숫자열과 영단어" /><published>2021-10-23T00:00:00+09:00</published><updated>2021-10-23T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm.html">&lt;blockquote&gt;
  &lt;p&gt;카카오 코딩 테스트 문제 ‘문자 숫자열과 영단어’입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.
다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.&lt;/p&gt;

  &lt;p&gt;1478 → “one4seveneight”
10203 → “1zerotwozero3”
234567 → “23four5six7”&lt;/p&gt;

  &lt;p&gt;이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution(s) {
    let answer = s;
    let numObj = {
        zero: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6,
        seven: 7,
        eight: 8,
        nine: 9,
    };

    function DFS() {
        for(let i in numObj) {
            let answer2 = answer;
            answer2 = answer2.replace(i, numObj[i]);

            if(answer2 !== answer) {
                answer = answer2;
                DFS();
            }
        }
    }

    DFS();

    return parseInt(answer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replaceAll&lt;/code&gt;을 사용하여 문제를 풀 마음이었지만 프로그래머스는 replaceAll을 지원하지 않는다고…ㅠ&lt;/li&gt;
  &lt;li&gt;어떻게 할까 고민하다가 replace를 상황에 따라 계속 해주면 되는거 아닌가? 싶은 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;상황이라함은 중복되는 숫자가 한 문자열에 존재할 경우였다.&lt;/li&gt;
  &lt;li&gt;기존 수를 변수로 할당하고 replace하여 기존 값과 replace하여 변하는 값이 있다면 다시 검사하는 방식으로 로직을 구현했다.&lt;/li&gt;
  &lt;li&gt;어떤 방법으로 다시 검사할까 고민하다가 최근에 배운 DFS (재귀함수)를 사용하여 구현해보았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이렇게 하니 모든 테스트케이스에는 통과했지만, 속도는 한 테스트케이스당 0.2s ~ 0.3s정도 나오는 것 같았다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-다른-풀이&quot;&gt;📌 다른 풀이&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function solution(s) {
  let num = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];

  let answer = s;

  for(let i = 0; i &amp;lt; num.length; i++) {
    let arr = answer.split(num[i]);
    answer = arr.join(i);
  }

  return parseInt(answer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이 중에서 제일 좋아요? 수를 많이 받는 코드이다.&lt;/li&gt;
  &lt;li&gt;잘 살펴보면 num 배열을 for문으로 돌리는 것까지는 내 코드와 비슷하지만, 필자는 DFS를 사용함으로서 이중 삼중으로 반복 로직을 실행시켰다.&lt;/li&gt;
  &lt;li&gt;하지만 이 로직에서는 for하나로 split를 사용함으로서 전체 string을 for가 돌때마다 한번씩만 호출하면 된다.&lt;/li&gt;
  &lt;li&gt;역시나 테스트 코드는 모두 통과임과 함께 속도도 하나의 테스트 코드당 0.06s ~ 0.07s가 걸린다.&lt;/li&gt;
  &lt;li&gt;시간복잡도 측면에서 훨씬 좋은 코드인 것이다..!!ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;역시나 알고리즘은 재밌다!!!&lt;/li&gt;
  &lt;li&gt;여러가지 알고리즘 자료구조를 활용해 최적의 코드를 구현하는 방법! 더 연구하고 많이 사용해보아야겠다.&lt;/li&gt;
  &lt;li&gt;하지만 나도 과거에 쩔쩔매던 재귀함수를 활용해서 스스로 코드를 구현한 것에 보람을 느낀다 :)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="재귀함수" /><category term="split" /><summary type="html">카카오 코딩 테스트 문제 ‘문자 숫자열과 영단어’입니다.</summary></entry><entry><title type="html">[Refactoring2] Chapter 6-1 함수 추출하기</title><link href="http://localhost:4000/book/chaper6-1.html" rel="alternate" type="text/html" title="[Refactoring2] Chapter 6-1 함수 추출하기" /><published>2021-10-20T00:00:00+09:00</published><updated>2021-10-20T00:00:00+09:00</updated><id>http://localhost:4000/book/chaper6-1</id><content type="html" xml:base="http://localhost:4000/book/chaper6-1.html">&lt;blockquote&gt;
  &lt;p&gt;chapter 6-1 함수 추출하기에 대한 생각 정리🤔&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-함수-추출하기&quot;&gt;함수 추출하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-예시-및-생각-정리&quot;&gt;예시 및 생각 정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-함수-추출하기&quot;&gt;📌 함수 추출하기??&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;함수 추출하기는 하나의 코드를 여러 조각으로 나누는 작업이다.&lt;/li&gt;
  &lt;li&gt;각각 독립적인 함수로 만들기 위해서는 함수의 목적을 파악하고 분리하기!!(목적이 명확하다면 변수명 짓는 것도 보다 수월해질 것🤩)&lt;/li&gt;
  &lt;li&gt;사람마다, 팀마다 목적에 맞게 나누는 정도는 다 다르지만..(저자는 reverse메소드 하나 사용하기 위해 함수를 만든 적도 있다고..), 상황에 맞는 유연함을 보여야할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-예시-및-생각-정리&quot;&gt;📌 예시 및 생각 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = {name: 'syeon', goToWork: [true, true, true, true]};

function goWorkRecording(person) {
  let counting = 0;

  console.log('In the morning');

  for(let working of person.goToWork) {
    if(working) {
      counting += 1;
    }
  };

  const today = new Date();
  person.date = `${today.getFullYear()}/${today.getMonth()}/${today.getDate()}`;

  console.log(`이름 : ${person.name}`);
  console.log(`오늘 날짜 : ${person.date}`);
  console.log(`출근 횟수 : ${counting}`);
}

goWorkRecording(person);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서적에 소개된 예시와 비슷한 함수를 만들어보았다.(이제 직장인이어서 출근으로 비유한 새내기 개발지🌱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수 추출하기 에서는 이정도로???라고 할 정도로 함수를 나누며 설명한다.&lt;/li&gt;
  &lt;li&gt;핵심은 매개 변수, 지역 변수 등의 배치를 최대한 쉽고 간결하게..이게 무슨 일을 하는 함수인지 바로 알 수 있도록 구현하는 것이라고 생각했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = {name : 'syeon', goToWork: [true, true, true, true]};

function goWorkRecording(person) {
  alertMorning();

  const counting = countWorking(person);

  getToday();

  showRecords(person, counting);

  function alertMorning() {
    console.log('In the Morning');
  };

  function countWorking(person) {
    let result = 0;

    for(let working of person.goToWork) {
      if(working) result += 1;
    }
    return result;

  };

  function getToday() {
    let today = new Date();
    return `${today.getFullYear()}/${today.getMonth()}/${today.getDate()}`;
  }

  function showRecords(person, counting) {
    console.log(`이름 : ${person.name}`);
    console.log(`오늘 날짜 : ${person.date}`);
    console.log(`출근 횟수 : ${counting}`);
  }
}
goWorkRecording(person);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코드가 생각보다 많이 길어졌다.&lt;/li&gt;
  &lt;li&gt;하지만 이 goWorkRecording이라는 함수가 무엇을 하려는지는 좀더 명확하게 보인다.&lt;/li&gt;
  &lt;li&gt;책에서는 나오지 않았지만, 본인은 중복 함수인 함수 선언문들을 제일 아래로 내려 놓은게 인사이트였다.&lt;/li&gt;
  &lt;li&gt;별거 아닌것처럼 보여도 무심결 함수 선언하고 함수 호출하고의 생각이 당연한 것처럼 여겼는데 이렇게보니 더 깔끔하다는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;alertMorning함수는 goWorkRecording에서 참조하는 지역변수가 없으므로 바깥으로 빼서 재사용성을 높일 수도 있다.&lt;/li&gt;
  &lt;li&gt;countWorking함수도 본래 goWorkRecording의 지역변수였던 counting을 함수 내부로 넣고 결과 값을 result으로 뺀 점, 그리고 그 결과값 result는 결국 couting 변수에 할당되어 다른 함수에서 사용할 수 있게 만든 것…이런 것이 바로 코드를 섬세하게 다룬다 라고 하는 것임을 알았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 생각보다 기초적이지만 처음에 등장한만큼 중요한 기법이라고 생각된다. 리팩터링을 다시 한번 생각해보게 되었고, 앞으로도 기대가 된다 😊&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="book" /><category term="refactoring2" /><summary type="html">chapter 6-1 함수 추출하기에 대한 생각 정리🤔</summary></entry><entry><title type="html">[Refactoring2] Chapter 3 &amp;amp; 4 : 전반적인 코드 개선 방법</title><link href="http://localhost:4000/book/chapter3-4.html" rel="alternate" type="text/html" title="[Refactoring2] Chapter 3 &amp;amp; 4 : 전반적인 코드 개선 방법" /><published>2021-10-19T00:00:00+09:00</published><updated>2021-10-19T00:00:00+09:00</updated><id>http://localhost:4000/book/chapter3-4</id><content type="html" xml:base="http://localhost:4000/book/chapter3-4.html">&lt;blockquote&gt;
  &lt;p&gt;Refactoring2 chapter 3과 4를 읽고..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-chapter-3--chapter-4&quot;&gt;📌 Chapter 3 &amp;amp; Chapter 4&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;3단원과 4단원은 어떤 코드를 점검하고 리팩토링을 고려해야하는지, 리팩토링과 테스트 코드는 구체적으로 어떤 연관을 가지는 것인지에 대해서 이야기한다. 3단원에서 소개하는 점검해야하는 리팩터링 요소들은 생각보다 엄청 많았다. 변수 이름 정하기부터 시작하여, 반복문 클래스를 어떻게 해는 것이 좋다! 라고 소개하지만… 신입인 나는 아직 경험해보지 못했던 상황들이 많이 있었다..ㅠㅠ 테스트 코드 또한 마찬가지였다..(jest를 빨리 익혀야겠다..!!)&lt;/p&gt;

&lt;p&gt;3단원을 통해서 고려해야할 코드들은 생각보다 많고, 이것들은 모두 코드를 명확하게 만들어주는 도구라고 생각하니 빨리 익히고 싶은 마음이 들었지만..! 급히 먹는 밥이 체한다고..🍚 천천히 잘 씹어 먹어야겠다😊&lt;/p&gt;

&lt;p&gt;4단원에서도 테스트 코드를 한차례 더 강조했는데 역시나 모든 코드에 테스트를 할 수 있다면 좋겠지만 우리의 몸과 마음은 유한하니.. 중심이 되는 코드들을 중점으로 테스트를 하는 것을 권장한다. 어디선가 ‘프론트엔드는 브라우저 상으로 잘 출력이 되는지 확인할 수 있으니까 굳이 안만들어도 되지 않나?’라는 이야기를 들은 적이 있었다. 그 때는 ‘어 그런가?’라고 생각했지만, 곧 이 생각은 바뀌게 되었다. 확실히 테스트 코드는 처음에 시간이 조금 걸릴 수는 있지만, 지속적인 테스트나 디버깅에 있어서 테스트 코드가 없는 것보다 월등한 속도를 보여준다고 주변에서 먼저 경험한 동기들에게 전해들었다! 즉 누구에게나 테스트 코드는 필요하다!&lt;/p&gt;

&lt;p&gt;더 나은 코드를 구현하기 위해 앞으로도 홧팅하며 달린다 🏃🏻&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="book" /><category term="refactoring2" /><summary type="html">Refactoring2 chapter 3과 4를 읽고..</summary></entry><entry><title type="html">[Refactoring2] Chapter 2 : 리팩터링 원칙</title><link href="http://localhost:4000/book/chapter2.html" rel="alternate" type="text/html" title="[Refactoring2] Chapter 2 : 리팩터링 원칙" /><published>2021-10-15T00:00:00+09:00</published><updated>2021-10-15T00:00:00+09:00</updated><id>http://localhost:4000/book/chapter2</id><content type="html" xml:base="http://localhost:4000/book/chapter2.html">&lt;blockquote&gt;
  &lt;p&gt;chapter 2 리펙터링 원칙을 읽고…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;[목차]
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-chapter-2-리팩터링-원칙을-읽으며&quot;&gt;Chapter 2 리팩터링 원칙을 읽으며..&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-chapter-2-리팩터링-원칙을-읽으며&quot;&gt;📌 Chapter 2 리팩터링 원칙을 읽으며..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이번 주제 또한 실질적인 기법을 알려주기 전에 리펙터링의 필요성과 효율 등을 이야기해주는 단원이었다.&lt;/p&gt;

&lt;p&gt;궁극적으로 리팩터링은 심미적으로 코드를 아름답게하기 위해, 좋아보이기 위해 진행하는 것이 아니다. 리팩터링을 통해 개발 속도를 높이고, 더 적은 노력으로 많은 가치를 창출하는 것에 있다.&lt;/p&gt;

&lt;p&gt;분명 리팩터링에는 여러가지 이점들이 존재한다. 소프트웨어를 이해하기 쉬워지고, 디버깅을 쉽게 할 수 있는 등 그밖에 여러가지 이점들을 가지고 있지만, 저자는 무턱대고 리팩터링을 하는 것을 권장하지 않는다고 말한다.&lt;/p&gt;

&lt;p&gt;리팩터링의 시기에 대한 명쾌한 해답은 없다. 누군가에게는 기능 추가와 동시에 하는 것이 베스트이고, 누군가에게는 팀원들과 코드리뷰를 하면서, 누군가는 날잡고 몇일동안.. 사실 특정 누군가에게 해당 방안들이 적용되는 것이 아니라 상황에 따라 취해야할 행동이 다르다고 생각된다. 하지만 이러한 행동을 취하기 위해서는 많은 경험과 고민들을 거쳐야만 할 것이다.&lt;/p&gt;

&lt;p&gt;본인은 기능을 구현함과 동시에 리팩터링을 진행하는 편이다. 비록 신입 개발자이지만.. 더 개선할 수 있을 것 같은데? 라는 마음으로 계속 고민하는 편이다. 하지만 기한이 빡빡한 새로운 프로젝트에 돌입한다면 기능을 우선적으로 구현해야지..라는 생각을 가지고 있다.&lt;/p&gt;

&lt;p&gt;책에서는 여러가지 리팩토링 시 고려해야할 점들, 리팩토링의 시기들을 이야기하지만 본인이 느꼈을 때 결론은 이것인 것 같다.
“코드의 지구력 설계를 위해서는 리팩토링이 필요하다. 리팩토링을 진행할 때 코드 테스트를 병행하고, 팀이라면 CI(지속적 통합) 방식으로 컨플릭같은 에러를 최소화하는 것이 좋다. 하지만 리팩터링 해야할 요소는 마땅한 리팩터링을 해야하는 근거가 필요하다. 기존보다 성능이 덜 좋거나, 래거시 코드 등 다양한 리팩터링 대상을 놓고, 기존 서비스를 잘 유지하는 차원에서 진행하는 것이 리팩토링의 원칙이다.”&lt;/p&gt;

&lt;p&gt;위의 내용이 맞는지 틀린지 사실 잘 모르겠지만 이제 다음 단원부터 시작되는 실질적인 리팩터링 기법들을 읽고 난 뒤 다시 단원 1장과 2장을 정독해보아야겠다. :)&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="book" /><category term="refactoring2" /><summary type="html">chapter 2 리펙터링 원칙을 읽고…</summary></entry><entry><title type="html">[Algorithm] 이진 트리 순회(DFS: 깊이 우선 탐색)</title><link href="http://localhost:4000/devlog/algorithm.html" rel="alternate" type="text/html" title="[Algorithm] 이진 트리 순회(DFS: 깊이 우선 탐색)" /><published>2021-10-14T00:00:00+09:00</published><updated>2021-10-14T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm.html">&lt;blockquote&gt;
  &lt;p&gt;재귀 함수를 응용한 이진트리순회(DFS 깊이 우선 탐색) 알고리즘!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;h2 id=&quot;-이진-트리-순회란&quot;&gt;📌 이진 트리 순회란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;2갈래 나무 형태로 되어 있는 자료구조이다.&lt;/li&gt;
  &lt;li&gt;부모 노드 root에는 left right 방향으로 총 2개의 자식 노드를 가진다.&lt;/li&gt;
  &lt;li&gt;이 노드들을 차례대로 순환하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/algorithm/DFS.png&quot; width=&quot;500px&quot; height=&quot;200px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;저렇게 부모 노드가 있고 자식 노드가 있으며 각 노드에 넘버링이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 노드들마다 접근하는 순서 및 방식에 따라 여러가지 개념들이 생기는데 &lt;b&gt;전위 순회&lt;/b&gt;, &lt;b&gt;중위 순회&lt;/b&gt;, &lt;b&gt;후위 순회&lt;/b&gt;가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;전위 순회는 1-2-4-5-3-6-7 이런 순으로 노드에 접근하며 순회한다.&lt;/li&gt;
  &lt;li&gt;중위 순회는 4-2-5-6-3-7-1 순으로 제일 왼쪽 끝 노드에 접근하고 중간 노드에 접근한 이후 다시 오른쪽 노드로 뻗어가는 방식으로 되어있다.&lt;/li&gt;
  &lt;li&gt;후위 순회는 4-5-2-6-7-3-1 순으로 제일 왼쪽 끝에서 오른쪽 끝 노드 순으로 접근하며 순회하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 이러한 노드를 재귀를 사용하여 구현한다고해서 연결리스트로 해야되나 어떻게 트리 구조를 만들지?라고 생각했었는데… 재귀를 한 함수에서 2번 호출하는 방법은 생각하지도 못했다…!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function DFS(n) {
  if(n &amp;gt; 7) return
  else {
    console.log(n);
    DFS(n * 2);
    DFS(n * 2 + 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-… 생각보다 너무 간단하다. 로직을 보는 순간 아 그렇게 되는구나 대박!! 이랬다👽&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS의 매개변수인 n _ 2와 n _ 2 + 1이 의아할 수 있는데 부모와 자식노드를 잘 보면 무조건 자식노드의 왼쪽은 부모노드의 _ 2, 오른쪽은 _ 2 + 1이라는 사실..&lt;/li&gt;
  &lt;li&gt;이것과 실행컨텍스트, 콜스텍의 개념으로 생각해보면 n _ 2를 매개변수로 가지고 있는 DFS함수는 그 안에서 또 DFS가 실행될텐데 그럼 또 그 안의 DFS함수 중 n _ 2를 매개변수로 가지고 있는 함수가 먼저 실행되는 것이 반복된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;계속 반복되다가 n &amp;gt; 7의 조건으로 종료되면 n * 2 + 1함수가 실행이 되어 아까와의 상황이 반복될 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;짚고 넘어가야될 부분은 console.log의 위치이다.&lt;/li&gt;
  &lt;li&gt;지금은 재귀 함수중 제일 위에 있기 때문에 함수를 깊게 들거가기 전 n값을 콘솔에 보여준다. 한차례 들어간 함수에서도 마찬가지..&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저 console.log가 DFS(n _ 2)와 DFS(n _ 2 ≠ 1)사이에 들어가게 되면 중위 순환이 되는 것이다. 제일 마지막에 있으면 후위 순환!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇듯 재귀함수의 호출과 종료를 이용한 DFS 이진트리 순환에 대해 알아보았다.(재밋당)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="깊이우선탐색" /><category term="이진트리순회" /><summary type="html">재귀 함수를 응용한 이진트리순회(DFS 깊이 우선 탐색) 알고리즘!</summary></entry><entry><title type="html">[Refactoring2] Chapter 1 : 리팩터링 예시</title><link href="http://localhost:4000/book/page23-51.html" rel="alternate" type="text/html" title="[Refactoring2] Chapter 1 : 리팩터링 예시" /><published>2021-10-13T00:00:00+09:00</published><updated>2021-10-13T00:00:00+09:00</updated><id>http://localhost:4000/book/page23-51</id><content type="html" xml:base="http://localhost:4000/book/page23-51.html">&lt;blockquote&gt;
  &lt;p&gt;chapter 1 리펙터링 : 첫번째 예시를 읽고..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-refactoring-2-시작&quot;&gt;Refactoring 2 시작!&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-chapter-1-리펙터링-첫번째-예시를-읽으면서&quot;&gt;Chapter 1: 리펙터링 첫번째 예시를 읽으면서..&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-테스트-코드를-작성하라&quot;&gt;테스트 코드를 작성하라!&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-프로그램에-새로운-기능을-추가하기-쉬운-형태로-리팩터링하자&quot;&gt;프로그램에 새로운 기능을 추가하기 쉬운 형태로 리팩터링하자!&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-사람이-이해하도록-작성하는-코드--수정을-간편하게-할-수-있게-고려한-코드&quot;&gt;사람이 이해하도록 작성하는 코드 &amp;amp; 수정을 간편하게 할 수 있게 고려한 코드&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며..&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-refactoring-2-시작&quot;&gt;📌 Refactoring 2 시작!&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;지금까지 리펙터링이라 생각했던 것은 전체적인 코드 컨벤션을 지키고 코드를 가독성있게 짜는 것이라고 생각했다. 하지만 가독성있는 코드란 도대체 무엇일까? 라는 의문이 들었다. 더러운 코드란 무엇일까? 무슨 의미인지 1도 모르겠는 변수명? 들여쓰기 내어쓰기? 줄바꿈?..🧐
좋은 코드를 위해 고민하는 훈련을 하고자 Refactoring을 읽기 시작했다.📚 충분한 고민과 함께 책을 완독하였을 떄 한층 더 성장해 있을 나를 꿈꾸며 열심히 달려야겠다!!🏃🏻&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-chapter-1-리펙터링-첫번째-예시를-읽으면서&quot;&gt;📌 Chapter 1: 리펙터링 첫번째 예시를 읽으면서..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;▶︎ 리펙터링 1장은 바로 어떻게 리펙터링하는 것인지 ‘방법’에 대한 글이 아닌 리펙터링의 ‘과정’을 보여주는 챕터였다. 하나의 함수를 기능마다 잘게 쪼개고, 변수를 선언하는 대신 가능한 변수를 인라인하고, 기능의 단계를 나누고, 얼마 전에 공부했던 OOP(객체 지향 프로그래밍)같이 클래스를 활용하여 다향성을 구현하는 등 여러가지 기법을 구사하는 과정을 보았다.&lt;/p&gt;

&lt;p&gt;▶︎ 물론 코드들이 한번에 이해되어 바로 적용할 수 있겠다!!는 아니지만(그렇다고 한다면 지금 여기 있을까..?) 리펙토링이라함은 서두에 언급한 것과 같이 단순히 컨벤션을 지키는 것에 그치는 것이 아니었다. 책 군데군데 명언?같은 글귀가 있었는데 리펙토링할 때 생각해야하는 중요한 사항인 것 같다.&lt;/p&gt;

&lt;h4 id=&quot;-테스트-코드를-작성하라&quot;&gt;🔥 테스트 코드를 작성하라!&lt;/h4&gt;

&lt;p&gt;▶︎ 책에서 틈만나면 나오는 문구이다. 오죽하면 저자가 “이제는 생략하겠습니다.”라고 언급하기까지… 리펙토링을 거쳐가는 과정에서 로직을 점검하기 위한 필수조건이라고 강조하는 것 같았다. (jest 빨리 익혀야게따…!)&lt;/p&gt;

&lt;h4 id=&quot;-프로그램에-새로운-기능을-추가하기-쉬운-형태로-리팩터링하자&quot;&gt;🔥 프로그램에 새로운 기능을 추가하기 쉬운 형태로 리팩터링하자!&lt;/h4&gt;

&lt;p&gt;▶︎ 당연히 이렇게 할 수 있다면 누가 이렇게 안하겠는가..? 당연한 이야기이지만 작은 규모의 IT회사 특성상 코드의 질보다 속도라는 이야기를 얼핏 들은 것 같다. 작업량이 많으니 당연한 이야기..
개발을 하는 누구나 양질의 코드를 짜내고 싶어할 것이라 생각한다.. 하지만 단순히 취미로 가져가는것이 아닌 ‘성과’를 내야하는 환경에서 항상 이런 태도를 이행하기는 쉽지 않을 것 같다. (상업적 코드라고 하나..?)
▶︎ 하지만 그렇다고 좋은 코드 생각하기를 그치지 않아야 한다. 환경에 타협하기보다는 틈틈히 개선해나가고 싶다 :)&lt;/p&gt;

&lt;h4 id=&quot;-사람이-이해하도록-작성하는-코드--수정을-간편하게-할-수-있게-고려한-코드&quot;&gt;🔥 사람이 이해하도록 작성하는 코드 &amp;amp; 수정을 간편하게 할 수 있게 고려한 코드&lt;/h4&gt;

&lt;p&gt;▶︎ 리펙터링의 제일된 목적이지 않을까? 맞게만 작성하면 컴퓨터는 알아서 잘 돌아간다. 하지만 사람은 그렇지 않다. 반복적인 코드를 줄이는 리펙터링을 하였다해도 사람이 못알아보면 말짱 도루묵이다.🐟&lt;/p&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며…&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;책을 읽으면서 의아했던 부분은 리팩터링을 진행하면서 점점 코드 길이가 늘어났다는 것이다. 개발을 처음 시작할 때 ‘간결한 코드가 좋은 코드’라는 근거없는 생각을 항상 하고 다녔다. ‘간결하니까 사람들이 잘 알아보지 않을까?’했다. 같은 맥락일 수 있지만 저자는 ‘명확한 코드’를 강조했다. 고쳐야할 곳을 쉽게 찾을 수 있고 오류없이 빠르게 수정할 수 있으려면 ‘명확’해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;단순히 코드를 길게 쪼개서 장황해지는 코드가 아니라 명확해지는 코드를 고민하며 책을 읽어야겠다. 책을 읽고 실제 코드에 적용하게 되는 날이 빨리 왔으면 좋겠다.👨🏻‍💻&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="book" /><category term="refactoring2" /><summary type="html">chapter 1 리펙터링 : 첫번째 예시를 읽고..</summary></entry><entry><title type="html">[Algorithm] Recursive Function(재귀 함수)</title><link href="http://localhost:4000/devlog/algorithm-dfs.html" rel="alternate" type="text/html" title="[Algorithm] Recursive Function(재귀 함수)" /><published>2021-10-12T00:00:00+09:00</published><updated>2021-10-12T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-dfs</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-dfs.html">&lt;blockquote&gt;
  &lt;p&gt;삽입 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-recursive-function이란&quot;&gt;Recursive Function이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-다른-풀이&quot;&gt;다른 풀이&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-recursive-function이란&quot;&gt;📌 Recursive Function이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 한 함수 내에서 자기 자신을 다시 호출하는 방식을 가진 함수이다.&lt;/li&gt;
  &lt;li&gt;보통 재귀함수는 스택에 매개변수, 지역변수, 복기주소로 구성되어 있는 스택 프레임에 정보가 저장되기 때문에 일반 반복문보다 느릴 수 있다는 단점을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;개인적으로 느끼기에 재귀함수의 전체적인 흐름은 실행컨텍스트의 흐름으로 이해해도 될 것 같다고 생각했다. (물론 실행컨텍스트가 재귀함수를 설명하기 위한 개념은 아닐 것이지만..)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;1, 2, 3 순으로 나열하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;️-나의-풀이&quot;&gt;💁🏻‍♂️ 나의 풀이&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let initNum = 0;

function selfFunc(a) {
  if(initNum &amp;lt; a) {
    initNum += 1;
    console.log(initNum);
    selfFunc(a);
  } else {
    return;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;️-다른-풀이&quot;&gt;💁🏻‍♀️ 다른 풀이&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selfFunc(a) {
  if(a === 0) return;
  else {
    selfFunc(a - 1);
    console.log(a);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;훨씬 간단해보이지만 중요한 것은 그것이 아니다.(아니..중요할수도..ㅎ)&lt;/li&gt;
  &lt;li&gt;각각 console.log를 찍는 위치가 재귀함수를 다시 호출하기 전/후로 나뉘지만 결과값은 1, 2, 3으로 같다.&lt;/li&gt;
  &lt;li&gt;여기서 스택의 개념이 사용된다.&lt;/li&gt;
  &lt;li&gt;재귀함수는 또 다시 호출된 자기 자신의 함수가 끝나기 전까지는 스택에서 사라지지 않고 보류된다.&lt;/li&gt;
  &lt;li&gt;마치 실행컨텍스트에서 사용되는 콜스택 개념처럼!!&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 재귀함수는 스택의 개념이 중요하다!&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="RecursiveFunction" /><summary type="html">삽입 정렬 알고리즘입니다.</summary></entry></feed>