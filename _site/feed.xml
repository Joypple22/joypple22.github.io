<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2021-08-19T13:52:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Syeon</title><subtitle>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</subtitle><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><entry><title type="html">[Algorithm] Bubble Sort</title><link href="http://localhost:4000/devlog/algorithm-bubbleSort.html" rel="alternate" type="text/html" title="[Algorithm] Bubble Sort" /><published>2021-08-19T00:00:00+09:00</published><updated>2021-08-19T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-bubbleSort</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-bubbleSort.html">&lt;blockquote&gt;
  &lt;p&gt;버블 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-bubble-sort버블-정렬란&quot;&gt;Bubble Sort(버블 정렬)란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-bubble-sort버블-정렬란&quot;&gt;📌 Bubble Sort(버블 정렬)란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;서로 인접한 두 요소를 검사하여 정렬하는 알고리즘&lt;/li&gt;
  &lt;li&gt;선택정렬과 마찬가지로 시간복잡도 측면에서 O(n&lt;sup&gt;2&lt;/sup&gt;)를 가진다.&lt;/li&gt;
  &lt;li&gt;단순하고 구현하기 어렵지 않지만, 많은 데이터를 다루게 된다면 상당히 비효율적인 정렬 방법이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 배열 내에서 오름차순으로 정렬하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [13, 5, 2, 7, 19, 20, 9, 17];

const question = arr =&amp;gt; {
    let answer = [];

    while(arr.length &amp;gt; 0) {
        for(let i = 0; i &amp;lt; arr.length; i++) {
            if(arr[i] &amp;lt; arr[i + 1]) {
                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
            }
        }
        answer.push(arr.pop());
    }

    return answer;
}

question(arr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이런 방법으로 처음에 구현했었는데 직관적으로 보기에는 정렬 순서가 내림차순 느낌이 나서 가독성에 좋지 않았던 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [13, 5, 2, 7, 19, 20, 9, 17];

const question = arr =&amp;gt; {
    let answer = arr;

    for(let i = 0; i &amp;lt; answer.length -1; i++) {
        for(let j = 0; j &amp;lt; answer.length - i - 1; j++) {
            if(answer[j] &amp;gt; answer[j + 1]) {
                [answer[j], answer[j + 1]] = [answer[j + 1], answer[j]];
            }
        }
    }

    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;가독성이 훨씬 좋아졌다. 그리고 전보다 불필요한 메서드를 사용하지 않아도 구현이 가능해졌다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="BubbleSort" /><summary type="html">버블 정렬 알고리즘입니다.</summary></entry><entry><title type="html">Werecord project -v2👨🏻‍💻</title><link href="http://localhost:4000/project/project-review-werecord-v2.html" rel="alternate" type="text/html" title="Werecord project -v2👨🏻‍💻" /><published>2021-08-17T00:00:00+09:00</published><updated>2021-08-17T00:00:00+09:00</updated><id>http://localhost:4000/project/project-review-werecord-v2</id><content type="html" xml:base="http://localhost:4000/project/project-review-werecord-v2.html">&lt;blockquote&gt;
  &lt;p&gt;Werecord -v2 project 후기 및 피드백입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-we-record--v2&quot;&gt;We Record -v2?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-각-페이지-소개&quot;&gt;각 페이지 소개&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-initail-setting&quot;&gt;Initail Setting&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-global-component&quot;&gt;Global Component&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-rending-page&quot;&gt;Rending Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-main-page&quot;&gt;Main Page&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#1-실시간-타이머-기능&quot;&gt;1. 실시간 타이머 기능&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#2-스크린-캡쳐-기능&quot;&gt;2. 스크린 캡쳐 기능&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-my-page&quot;&gt;My Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-mate-page&quot;&gt;Mate Page&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-responsive-web-반응형웹&quot;&gt;Responsive Web(반응형 웹)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-error--fix&quot;&gt;Error &amp;amp; Fix&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-마치며&quot;&gt;마치며…&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-we-record--v2&quot;&gt;📌 We Record -v2?!?!&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://ksy4568.github.io/project/project-review-werecord.html&quot;&gt;💁🏻‍♂️ 버전1 - WeRecord 후기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://youtu.be/TtY8FGlqDuw&quot;&gt;💁🏻‍♂️ 버전1 - WeRecord 영상&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;팀원들과 함께 한 We Record project가 마무리 된지 어느덧 한달이 지나고 있는 것 같다..(시간이 진짜 빠르다..🚗) 함께했던 팀원들도 각자도생..?의 느낌으로 흩어져 자신만의 스타일, 방식대로 취업을 준비하는 시간을 보내게 될 것 같았다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;빠듯한 취업 준비로 We Record의 프로젝트는 우리의 코딩 성장의 양분이 되어 기억 속에 잊혀질 것만 같았지만,, 사람 일은 모르는 것!!⭐️ 그저 코딩이 재미있고, 배우고 싶은 기술 스택도 많았고, 무엇보다 서비스를 목적으로 처음 작업했던 프로젝트를 더욱 완성도 있는 서비스를 만드는 것에 마음이 갔다.
이런 나를 팀원분들과 멘토님께서 배려해주셔서 혼자 We Record -v2를 작업할 기회가 생기게 되었다!! 🔥 (두둔)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;약 2주 정도가 지난 지금 프로젝트는 생각보다 재미있었고 다른 동기들이 짰던 코드들을 보면서 어떻게 구현해야하는지 몰랐던 로직도 알게 되고, 내가 짰던 코드와 동기 코드를 비교하면서 어떤게 더 효율적일까 고민도 하면서 재밌고 알찬 시간을 보낸 것 같아 기분이 좋았다.😊
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제는 개인 프로젝트로 바뀌었지만 컨벤션과 trello를 활용하여 할일을 체크하고 기록을 남겨두어 스스로 피드백을 하고 싶었다. 컨벤션은 최대한 이전 프로젝트를 따라가고 trello를 활용하여 blocker와 백앤드분께 추가적으로 요청해야될 부분들을 티켓으로 만들어 보관했다.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;trello&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/trelloImg.png&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-각-페이지-소개&quot;&gt;📌 각 페이지 소개&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-initail-setting&quot;&gt;🌱 Initail Setting&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;개인 프로젝트로 바뀌면서 제일 먼저 손봤던 것은 초기세팅이었다. 반응형을 시작으로 폰트, 색상들이 필요할 때마다 master가 merge되다가 지쳐 결국 각자 컴포넌트에서 일일히 따로 선언했던 기억이 떠올랐기 때문이다.&lt;/li&gt;
  &lt;li&gt;1차 프로젝트 당시에 사용했던 초기세팅의 기억을 되살려 폰트 색상, 반응형 breakpoint 등등을 다시 작업했다.&lt;/li&gt;
  &lt;li&gt;초기 세팅에서 제일 신경썼던 기능은 background였다!! 페이지 뒤에 보이는 산같은 실루엣들이 옆으로 계속 움직이는 것과 시간에 따라 색상이 변하는 기능이었다.(와우!!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;morning&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/morning.png&quot; width=&quot;250px&quot; /&gt; 아침
&lt;img alt=&quot;afternoon&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/afternoon.png&quot; width=&quot;250px&quot; /&gt; 점심
&lt;img alt=&quot;evening&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/evening.png&quot; width=&quot;250px&quot; /&gt; 저녁
&lt;img alt=&quot;dawn&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/dawn.png&quot; width=&quot;250px&quot; /&gt; 새벽&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;어떻게 구현할까 고민하다가 global css에 dayjs를 import시키고 시간 값에 따라서 background를 지정해주어 간단하게 끝냈다! (styled component 짱이다!! 👍🏼)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;뒤에 동산같이 생긴 곡선이 옆으로 움직이는 로직은 동산 이미지에 animation을 주어 옆으로 무한히 움직이도록 코드를 짰는데.. 생각보다 과부하가 걸리는 듯한 느낌이라 추후에 request animation frame으로 구현해볼까 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-global-component&quot;&gt;🌱 Global Component&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;GNB와 footer도 조금 다시 손봐야했다. GNB와 footer의 양 옆 margin이 page마다 일정해야했기 때문이다.&lt;/li&gt;
  &lt;li&gt;또한 기존에 해당 페이지에 있으면 그 버튼이 안보이게 되었던 것과 다르게, 바뀐 GNB는 각 페이지에 있을 때 폰트 색상이 흰색으로 바뀌어야했다.&lt;/li&gt;
  &lt;li&gt;location.pathname을 사용해 조건부 랜더링으로 되어있던 코드를 styled component에 넘겨주어 유동적으로 바뀌도록 코드를 짰다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;GNB&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/GNB.png&quot; width=&quot;250px&quot; title=&quot;desktop&quot; /&gt; desktop
&lt;img alt=&quot;GNB&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/GNB2.png&quot; width=&quot;250px&quot; /&gt; mobile&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존의 modal도 다시 작업했다! 이제는 start를 눌렀을 때 또한 모달창이 떠야했고 모달 크기는 일정해야하지만 내부 컨텐츠 크기가 제각각이어서 내부에 padding을 주기보단 width와 height를 직접 설정해주는 방법으로 변경했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-rending-page&quot;&gt;🌱 Rending Page&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;수정하는데 조금 복잡했던 랜딩페이지..! 소셜 로그인을 구현안해본 나로서는 멀 건드리면 안되고 되는지.. 하나하나 손볼 때마다 조심스럽게 다뤘던 것 같다.&lt;/li&gt;
  &lt;li&gt;포인트는 -v1에서는 SignIn이 모달을 통해 이루어졌는데 -v2에서는 한 페이지 내에서 구현을 해야했다..!!&lt;/li&gt;
  &lt;li&gt;하나로 합치는 것까지는 어렵지 않았지만 처음보는 소셜로그인 코드를 보고 JWT를 방식에 대해 공부하면서 작업해서 시간이 조금 소요되었다.(나중에 JWT 포스팅해야지~)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;rending&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/rending.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-main-page&quot;&gt;🌱 Main Page&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;드디에 시간이 제일 많이 걸린 Main Page다..&lt;/li&gt;
  &lt;li&gt;딱 봐도 새로운 기능이 추가되었는데 바로 실시간 타이머기능, 스크린샷 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-실시간-타이머-기능&quot;&gt;1. 실시간 타이머 기능&lt;/h4&gt;

&lt;p&gt;&lt;img alt=&quot;timer&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/timer.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존에 없던 기능이라 고민을 많이 했다. 마이 페이지에도 실시간으로 근태 시간이 반영되는 기능이 있지만 그것은 시간만 따로 빼내어 랜더링 시킨 것이라면, 이 기능은 flipClock기능도 추가시켜야 했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;npm을 구석구석 찾다가 페이지 컨셉과 잘 맞을 것 같은 라이브러리를 찾았다. react-simple-flipClock이 바로 그것이지만 문제점이 하나 있었는데… 시간이 0으로 가는 타이머 기능만 있었고 정교한 스타일링을 지원을 하지 않았고,, pause를 눌러 멈추고 다시 가게하는 기능이 없었던 것.. 너무나 pure한 타이머였다. 👶🏻&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;결국 라이브러리를 뜯어 커스텀하기 시작했는데.. 생각보다 재미있네..?? 🤭&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리의 동작 방식을 살펴보니 초를 넘겨주면 내부에서 알아서 1초마다 transform이 일어나도록 코드가 짜여져 있었다. 그리고 0에 도달하면 타이머가 멈추는 방식이었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이것을 이용하여 벡앤드분께 지금까지 진행한 total time과 last stop time을 요청하여 코드를 짰다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;start를 눌렀을 때는 0부터 serinterval로 1씩 증가
restart나 pause를 눌렀을 때는 백엔드로부터 total time을 초로 받아서 로직에 적용
start를 누른 상태에서 페이지를 나갔다가 다시 들어왔을 때도 계속 변하는 값을 기억하는 방법은 total시간에 (가장 나중에 누른 start시간 - 현재 시간)으로 계산했다.
문제점이 하나 있는데 백엔드 시간 데이터와 프론트 시간 데이터 간의 차이가 간혹 발생한다.. 이로 인해 1~2초 정도 오차가 나는 경우가 종종 발생하는데.. 시간 데이터는 한쪽에서 계산하는 것이 좀 더 안정적으로 보인다..ㅠ&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-스크린-캡쳐-기능&quot;&gt;2. 스크린 캡쳐 기능&lt;/h4&gt;

&lt;p&gt;&lt;img alt=&quot;screenCapture&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/screenCapture.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것도 새로운 기능이라 신기하고 재미있었다 :)&lt;/li&gt;
  &lt;li&gt;html2canvas 라이브러리를 이용하여 적용했는데 처음에는 desktop영역을 지정하려 했었지만, desktop영역에는 없는 요소들도 추가되거나 desktop에는 있지만 screenCapture에는 보이지 않아야하는 요소들이 있었다.&lt;/li&gt;
  &lt;li&gt;결국 ScreenModal을 새로 만들어 그 modal를 capture하는 식으로 계획을 변경했다! 😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-my-page&quot;&gt;🌱 My Page&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;myPage&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/myPage.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이페이지는 전체적인 UI를 수정하는 것이 주 작업이었다.&lt;/li&gt;
  &lt;li&gt;앞서 소개한 랜딩 페이지와 마이 페이지를 수정하면서 느낀 것이 있다라면,, 다른 사람 코드도 내 코드처럼 보는 능력을 기르는 것!! 굉장히 중요한 능력인 것 같다고 생각되었다!🥸&lt;/li&gt;
  &lt;li&gt;기존의 highChart의 내부 코드를 수정해야하는 작업, 랜더링 시켜야하는 시간 데이터 코드 수정 작업을 제외하면 빠르게 작업한 페이지였던 것 같다. :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-mate-page&quot;&gt;🌱 Mate Page&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;matePage&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/matePage.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기수페이지 또한 빠르게 작업한 페이지였다.&lt;/li&gt;
  &lt;li&gt;전체적인 UI부분을 바꾸는 것이 주 작업이었다.&lt;/li&gt;
  &lt;li&gt;기수페이지는 나 혼자 작업하기에는 한계가 있었고 백엔드분께 추가적인 데이터를 요청드려야했다! (공손공손)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-responsive-web-반응형-웹&quot;&gt;🌱 Responsive Web (반응형 웹)&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&quot;responsiveWeb&quot; src=&quot;/assets/img/project/2021-08-17-werecord-v2/responsive.gif&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;반응형은 최대 1440px, 모바일 1024px로 지정하여 적용하였다.&lt;/li&gt;
  &lt;li&gt;styled에 media를 적용하여 해당 breakPoint별로 변화가 있다면 각 component에 선언해주어야 하는 방식으로 코드를 짰다.&lt;/li&gt;
  &lt;li&gt;하지만 이 방법이 가독성이나 효율적인 코드인지는 다시 검토해보고 적용시킬 예정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-error--fix&quot;&gt;🌱 Error &amp;amp; Fix&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;나름 꼼꼼하게 코드를 짰다고 하더라도 초기에는 에러와 함께하는 것 같다…ㅠㅠ(디자인이나 문구도 조금씩 바뀌는 것들도 함께 고려..!) 생각지도 못했던 에러들을 접하면서 코드의 질을 높일 수 있는 고민을 해보는 시간을 가져야겠다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🔥 멘토님께서 확인해주신 Error &amp;amp; Fix &amp;amp; Design 수정&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;window.innerheight를 사용하여 화면 크기가 달라도 한 화면에 보여질 수 있도록&lt;/li&gt;
    &lt;li&gt;화면이 커져도 요소들이 창 가운데 있도록&lt;/li&gt;
    &lt;li&gt;요소들 dragEvent시 포인트 색상으로 변경&lt;/li&gt;
    &lt;li&gt;Screen Capture Modal 위, 아래에 페이지 이름, 넣기&lt;/li&gt;
    &lt;li&gt;다른 기수 페이지에 접근하기 위해 url을 바꾸면 에러가 나는 버그 수정&lt;/li&gt;
    &lt;li&gt;반응형 모바일일 때 ScreenCapture Modal이 desktop화면과 동일하도록 수정&lt;/li&gt;
    &lt;li&gt;반응형 모바일일 때 기수페이지 기수 등수를 누르면 z-index가 앞으로 나오도록 하는 이벤트 걸기 &lt;br /&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;(생각보다 버그보다는 디자인이 고칠 부분이 많은 것 같아서 괜히 뿌듯했다 :) )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-마치며&quot;&gt;📌 마치며..&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;사실 아직 아쉬운 부분들도 남아있다. Redux를 사용해서 전역으로 state를 관리해보고 싶었고, typeScript를 사용해서 트렌드에 맞는 코드를 경험해보고 싶었다. 이런 바램과 달리 오늘 멘토님과 프로젝트 에러픽스를 마치면 바로 배포 진행해서 실제 서비스할 예정이라고 말씀해주셔서 왠지 모르게 신기했다. 엄청난 프로젝트는 아닐지 몰라도 나에게는 실제 코딩을 통해 부트캠프 근태라는 ‘개발’을 했다라는 것이 기분이 묘해졌다. 앞으로도 개발과 함께 삶을 살아간다는 것 또한 신기했다.👨🏻‍💻 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우여곡절이 많았던 WeRecord 프로젝트! 실제 서비스할 수 있도록 끝까지 함께했던 시간을 통해 많은 것들을 알아갔다. 마냥 코딩이 재미있어서, 새로운 알고리즘으로 문제를 해결하는 쾌감, 새로운 기술 스택으로 안정성 있는 코드를 구현하는 즐거움… 이런 것들이 전부였던 나에게(당연히 저 요소들도 중요하겠지만 🤗) ‘내 프로젝트, 내 코드’라는 애착이 생겼다. 더 효율적으로, 다른 사람들이 봐도 가독성있게, 무엇보다 실제 서비스를 받는 클라이언트를 위한 쾌적한 서비스환경을 만들고 싶은 마음이 생겼다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;가치를 만들고자 하는 가치관에서 ‘어떤 가치를 만들고 싶은지’에 대해 약간 가닥이 잡혀가는 것 같다. 특정 분야가 아니라 어느 분야에서도 실제 서비스를 받는 클라이언트가 만족할 수 있는 ‘개발’을 하고 싶다. 그런 개발자가 될 수 있도록 앞으로도 화이팅이다!! 💪🏻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 &lt;a href=&quot;https://github.com/wecode-bootcamp-korea/werecord-frontend&quot;&gt;We-Record Github repo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="project" /><category term="project" /><category term="werecord" /><category term="React" /><category term="근태" /><summary type="html">Werecord -v2 project 후기 및 피드백입니다.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/project/2021-08-17-werecord-v2/cover.jpg" /><media:content medium="image" url="http://localhost:4000/assets/img/project/2021-08-17-werecord-v2/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">[Algorithm] Selection Sort</title><link href="http://localhost:4000/devlog/algorithm-selectionSort.html" rel="alternate" type="text/html" title="[Algorithm] Selection Sort" /><published>2021-08-17T00:00:00+09:00</published><updated>2021-08-17T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-selectionSort</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-selectionSort.html">&lt;blockquote&gt;
  &lt;p&gt;선택 정렬 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-selection-sort버블-정렬란&quot;&gt;Selection Sort(버블정렬)란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-selection-sort버블-정렬란&quot;&gt;📌 Selection Sort(버블 정렬)란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;입력 배열(정렬되지 않는 값들) 이외에 다른 추가 메모리가 필요하지 않다.&lt;/li&gt;
  &lt;li&gt;해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘&lt;/li&gt;
  &lt;li&gt;일반적으로 이중 for문을 사용하는 느낌이다. (첫번째 요소를 두번째 요소부터 차례대로 비교하여 조건이 충족하면 첫번째 요소와 조건에 맞는 요소를 바꾸고, 다음 두번째 요소를 세번째 요소부터 비교하는 작업을 반복하여 정렬한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 배열의 요소를 오름차순으로 정렬하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (arr) =&amp;gt; {
    let answer = arr;

    for(let i = 0; i &amp;lt; answer.length; i++) {
        let idx = i;

        for(let j = i + 1; j &amp;lt; answer.length; j++) {
            if(answer[idx] &amp;gt; answer[j]) idx = j;
        }

        [answer[i], answer[idx]] = [answer[idx], answer[i]];
    }

    return answer;
}

question([13, 5, 7, 3, 9, 16, 2]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 for문에서는 첫번째 요소를 지정해준다.&lt;/li&gt;
  &lt;li&gt;두번째 for문에서는 지정된 첫번째 요소와 두번째 이후부터의 요소들과 비교한다.&lt;/li&gt;
  &lt;li&gt;두번째 for문이 종료되면 첫번째 요소와 조건에 충족된 요소의 위치를 바꾸어준다.&lt;/li&gt;
  &lt;li&gt;이것을 첫번째 for문이 종료될 때까지 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🎈 시간복잡도 측면에서는 O(n&lt;sup&gt;2&lt;/sup&gt;)으로 느린 속도를 가진다.&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="SelectionSort" /><summary type="html">선택 정렬 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Queue</title><link href="http://localhost:4000/devlog/algorithm-queue.html" rel="alternate" type="text/html" title="[Algorithm] Queue" /><published>2021-08-15T00:00:00+09:00</published><updated>2021-08-15T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-queue</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-queue.html">&lt;blockquote&gt;
  &lt;p&gt;Queue 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-queue란&quot;&gt;Queue란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제요세푸스-순열&quot;&gt;사용 예제(요세푸스 순열)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-queue란&quot;&gt;📌 Queue란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 넣은 데이터를 먼저 나오게 하는 FIFO(First in First Out) 자료구조 형식이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FILO(First in Last Out) 형식인 Stack과 다르게 Queue는 한쪽에서는 삽입 연산, 다른 한쪽은 삭제 연산이 이루어지는 형식이다.&lt;/p&gt;

    &lt;p&gt;&lt;img alt=&quot;queue&quot; src=&quot;/assets/img/algorithm/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제요세푸스-순열&quot;&gt;📌 사용 예제(요세푸스 순열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;8명의 사람들을 원형으로 세우고 순서대로 돌아가면서 1부터 번호를 부르는데 3에 해당하는 사람은 제외시킨다.&lt;/li&gt;
  &lt;li&gt;제외가 되면 제외된 다음 사람부터 1을 부르고 마찬가지로 3에 해당되는 사람은 제외시키는 것을 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const question = (n, k) =&amp;gt; {
    let answer;
    let queue = Array.from({length: n}, (v, i) =&amp;gt; i + 1); ----- (1)

    while(queue.length) {     -------(2)
        for(let i = 1; i &amp;lt; k; i++) queue.push(queue.shift());
        queue.shift();
        if(queue.length === 1) answer = queue.shift();
    }
    return answer;
}

question(8, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)에서 함수형 프로그래밍으로 1부터 8까지의 요소들을 갖는 배열을 만든다.(함수형 프로그래밍 공부해야겠다..🔥)&lt;/li&gt;
  &lt;li&gt;(2)에서 queue.length가 0이 될 때까지 반복문을 돌린다.&lt;/li&gt;
  &lt;li&gt;먼저 queue의 첫번째 요소, 두번째 요소를 for문을 사용하여 차례로 queue 배열 뒤에 쌓고 앞의 숫자는 제거한다.&lt;/li&gt;
  &lt;li&gt;그 다음 queue의 첫번째 요소가 되는 숫자는 처음 queue의 3번째 숫자였으므로 뒤에 넣지 않고 제거만 한다.&lt;/li&gt;
  &lt;li&gt;이것을 반복하여 마지막 queue의 요소가 1개가 남으면 그 요소를 answer에 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 정리하여 앞에 숫자가 조건에 만족하면 배열 마지막 요소로 push하고 shift를 사용하여 제거하지만, 조건에 만족하지 않으면 shift만 사용하여 제거함으로 최후에 남는 데이터를 찾을 수 있는 알고리즘이다.&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Queue" /><summary type="html">Queue 자료구조를 활용한 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Stack</title><link href="http://localhost:4000/devlog/algorithm-stack.html" rel="alternate" type="text/html" title="[Algorithm] Stack" /><published>2021-08-10T00:00:00+09:00</published><updated>2021-08-10T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-stack</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-stack.html">&lt;blockquote&gt;
  &lt;p&gt;Stack 자료구조를 활용한 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-stack이란&quot;&gt;Stack이란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제배열&quot;&gt;사용 예제(배열)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-stack이란&quot;&gt;📌 Stack이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;‘쌓다’, ‘더미’ 라는 의미를 가진 알고리즘&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이름의 의미와 같이 한쪽으로만 열려있기 때문에 한쪽으로만 데이터를 받고 빼는 구조로 되어 있다. (후입선출)
&lt;img alt=&quot;&quot; src=&quot;/assets/img/algorithm/stack1.png&quot; width=&quot;400px&quot; /&gt; Last In First Out&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack의 구현 방법은 배열, 연결 리스트 2가지가 있다. (Stack이라고 해서 특별한 저장 공간을 가지는 array나 object가 있는 것이 아니라 stack이라는 자료구조 형식으로 알맞게 구현하는 것!)&lt;/li&gt;
  &lt;li&gt;각각 배열과 연결 리스트의 장단점이 있는데 &lt;br /&gt;
배열은 ‘데이터 접근 속도가 빠르기 때문에 데이터 양이 많으면 많을수록 효율이 좋지만, 데이터 삽입과 삭제에서는 비효율적’이다. &lt;br /&gt;
연결리스트는 ‘데이터 접근할 경우에는 연결되어 있는 노드를 따라 확인하며 접근하기 때문에 접근, 속도에서는 효율이 떨어지지만 데이터 삽입, 삭제는 배열보다 효율이 좋다’.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제배열&quot;&gt;📌 사용 예제(배열)&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;()의 짝이 맞는 경우는 true, 안맞으면 false&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let str = '(()()(())' // false

const question = (str) =&amp;gt; {
    let stack = [];

    for(let i of str) {
        if(i === '(') {
            stack.push(i);
        }
        else {
            if(stack.length === 0) {
                return false;
            } else {
                stack.pop();
            }
        }
    }
    if(stack.length &amp;gt; 0) return false
    else return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;stack이라는 배열을 만들고 난 후 ‘(‘가 있으면 stack에 push하고 ‘)’가 있으면 기존에 있는 ‘(‘를 pop하는 방식이다.&lt;/li&gt;
  &lt;li&gt;이렇듯 하나의 배열에 데이터를 순서대로 쌓고 순서대로 빼는 방식이 stack 자료구조이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Stack" /><summary type="html">Stack 자료구조를 활용한 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Hash</title><link href="http://localhost:4000/devlog/algorithm-hash.html" rel="alternate" type="text/html" title="[Algorithm] Hash" /><published>2021-08-06T00:00:00+09:00</published><updated>2021-08-06T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-hash</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-hash.html">&lt;blockquote&gt;
  &lt;p&gt;임의의 길이의 데이터를 고정된 길이의 데이터로 변환시키는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-hash란&quot;&gt;Hash란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-hash란&quot;&gt;📌 Hash란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&quot; target=&quot;\_blank&quot;&gt;사전적 정의&lt;/a&gt;로 임의의 길이를 가지고 있는 데이터를 고정된 길이의 데이터로 변환시켜주는 자료 구조이다.&lt;/li&gt;
  &lt;li&gt;Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.&lt;/li&gt;
  &lt;li&gt;데이터를 추가/삭제 시 기존 데이터를 밀어내거나 당기는 작업이 없도록 하는 알고리즘을 이용하여 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. (&lt;a href=&quot;https://jroomstudio.tistory.com/10&quot; target=&quot;/\_blank&quot;&gt;출처&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 쉽게 설명하자면 식당 메뉴판에 정렬된 메뉴를 볼때는 순차적으로 위에서 아래로 훑는게 아니라 아예 메뉴 이름에 대한 값을 알고 있는 것이라고 비유할 수 있을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;array안에 있는 과일들 중 가장 많이 들어있는 과일을 찾으시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let fruits = ['사과', '바나나', '배', '사과', '사과', '배', '배', '사과', '사과']
const question = (fruits) =&amp;gt; {
    let answer;
    let hash = new Map();

    for(let i of fruits) {
        if(hash.has(i)) hash.set(i, hash.get(i) + 1);
        else hash.set(i, 1);
    }

    let max = 0;
    for(let [key, value] of hash) {
        if(value &amp;gt; max) {
            max = value;
            answer = key;
        }
    }
    return answer; // '사과'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for문을 사용한 것은 배열 안에 있는 요소들이 map을 사용한 hash 안에 있는지 없는지 탐색하기 위함이다.&lt;/li&gt;
  &lt;li&gt;키값에 대한 데이터를 저장할 때 배열의 특징이 아닌 객체같은 특징을 보여준다.(데이터를 추가시 밀어내거나 당기는 이벤트가 발생하지 않는 부분)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="Hash" /><summary type="html">임의의 길이의 데이터를 고정된 길이의 데이터로 변환시키는 알고리즘입니다.</summary></entry><entry><title type="html">[Algorithm] Sliding Window</title><link href="http://localhost:4000/devlog/algorithm-slidingWindow.html" rel="alternate" type="text/html" title="[Algorithm] Sliding Window" /><published>2021-08-05T00:00:00+09:00</published><updated>2021-08-05T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-slidingWindow</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-slidingWindow.html">&lt;blockquote&gt;
  &lt;p&gt;배열에서 일정한 간격을 유지하면서 이동하며 탐색하는 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-sliding-window란&quot;&gt;Sliding Window란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-sliding-window란&quot;&gt;📌 Sliding Window란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;배열같은 형태를 띈 자료 구조에서 일정한 간격을 유지하면서 탐색하는 알고리즘 기법이다.&lt;/li&gt;
  &lt;li&gt;이중 for문보다 시간복잡도 측면에서 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;🎈 배열 안에서 연속되는 3개의 수의 합 중 가장 큰 합을 구하시오.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// For문을 사용했을 경우
const useFor = (m, arr) =&amp;gt; {
    let answer = 0;

    for(let i = 0; i &amp;lt; arr.length - m + 1; i++) {
        let sum = 0;

        for(let z = i; z &amp;lt; i + m; z++) {
            sum += arr[z];
            answer = Math.max(answer, sum);
        }
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문을 사용하게 되면 시간복잡도로 최대 O(N&lt;sup&gt;2&lt;/sup&gt;)가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const useSliderWindow = (m, arr) =&amp;gt; {
    let answer = 0;
    let sum = 0;

    for(let i = 0; i &amp;lt; m; i++) {
        sum += arr[i];
    }

    for(let i = m; i &amp;lt; arr.length; i++) {
        sum += arr[i] - arr[i - m];
        answer = Math.max(answer, sum);
    }
    return answer;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이중 For문과 달리 Slider Window는 배열의 처음과 끝을 &lt;b&gt;한번만&lt;/b&gt;탐색한다. (시간 효율이 좋다);&lt;/li&gt;
  &lt;li&gt;일정한 간격을 유지하기 때문에 범위의 앞과 뒤에서는 삭제와 삽입이 일어난다. (Deque 자료구조)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="TwoPointer" /><summary type="html">배열에서 일정한 간격을 유지하면서 이동하며 탐색하는 알고리즘</summary></entry><entry><title type="html">[JavaScript] This</title><link href="http://localhost:4000/devlog/this.html" rel="alternate" type="text/html" title="[JavaScript] This" /><published>2021-08-03T00:00:00+09:00</published><updated>2021-08-03T00:00:00+09:00</updated><id>http://localhost:4000/devlog/this</id><content type="html" xml:base="http://localhost:4000/devlog/this.html">&lt;blockquote&gt;
  &lt;p&gt;This의 개념과 작동 원리입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-this란&quot;&gt;📌 This란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;this는 간단하게 말해서 &lt;b&gt;식별자가 바라봐야할 대상&lt;/b&gt;을 의미합니다.&lt;/li&gt;
  &lt;li&gt;이게 무슨 말이지?? 라고 할 수 있겠지만, this는 함수가 호출되어 실행 컨텍스트가 생성되면 결정됩니다.&lt;/li&gt;
  &lt;li&gt;이 때, this가 &lt;b&gt;전역에 있을 경우&lt;/b&gt;!! 실행 컨텍스트가 생성되면서 가지게 되는 Lexical Environment(환경 정보들을 모아 놓은 객체)를 가리키게 됩니다.&lt;/li&gt;
  &lt;li&gt;그래서 식별자가 바라봐야할 대상을 의미한다는 것은 this를 가지고 있는 함수가 호출되었을 때 해당 함수 호출 주체를 가리키게 되는 것인지, 함수 바깥의 전역을 가리키게 되는 것인지에 대한 현상들을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-갑자기-lexical-environment&quot;&gt;🎈 갑자기 Lexical Environment?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;갑자기 왜 Lexical Environment일까?? 다음 예시를 보면 이해가 될 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
console.log(window.a) // a = 1
console.log(this.a) // a = 1

window.a = 3
console.log(a) // a = 3
console.log(this.a) // a = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;앞서 언급했던 ‘this는 전역에 있을 때 Lexical Environment를 가리킨다’라는 의미를 설명해주는 코드라고 생각한다.&lt;/li&gt;
    &lt;li&gt;var로 a를 선언하게 되면 a라는 변수는 전역 컨텍스트의 Lexical Environment에 저장된다.&lt;/li&gt;
    &lt;li&gt;this가 가리키는 것 또한 Lexical Environment이기 때문에 this.a로 접근이 가능함과 동시에 수정도 가능했던 것이다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;=&amp;gt; 이와같이 this가 전역 내부에 있다면 전역 Lexical Environment를 참조하게 되지만, 만약 함수 내부에서 this를 실행시키면 그 this는 함수가 호출되었을 때 생성된 실행 컨텍스트 Lexical Environment를 가리키게 될것인가? 상황에 따라 다르다. 이제부터 그 상황을 알아보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;-함수-안의-this&quot;&gt;📌 함수 안의 This&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-함수와-메서드의-차이점&quot;&gt;🌱 함수와 메서드의 차이점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수와 메서드를 나눌 수 있는 기준점은 &lt;b&gt;독립성&lt;/b&gt;이다.&lt;/li&gt;
  &lt;li&gt;함수는 그 자체로 가지고 있는 동작을 수행하지만, 메서드는 자신을 호출하는 대상 객체에 관한 동작을 수행한다.&lt;/li&gt;
  &lt;li&gt;여기서 포인트는 그 자체로 가지고 있는 동작을 수행하는 것과 함께 자신을 호출하는 대상 객체에 관한 동작을 수행하는 것도 메소드이다.&lt;/li&gt;
  &lt;li&gt;쉽게말해서 함수 앞에 “.”! 이 점을 찍냐의 유무에 따라 함수인지 메소드인지 구별할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(a)
}

func(1);   ---- (1)

var obj = {
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)과 (2)는 그 자체로 사용될 수 있는 함수이다. 여기서 (1)은 자체적으로 선언하지만, (2)는 obj라는 호출 주체를 통해서 함수를 사용했다.&lt;/li&gt;
  &lt;li&gt;이 차이가 (1)은 함수, (2)는 메소드로 구분짓는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-그래서-함수랑-메소드가-this랑-무슨-상관&quot;&gt;🌱 그래서 함수랑 메소드가 this랑 무슨 상관??&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수 내부에 있는 this는 전역을 가리킨다.&lt;/li&gt;
  &lt;li&gt;호출 주체를 함께 명시한 함수(ex. obj.num)의 this는 호출 주체를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var func = function(a) {
    console.log(this, a)
}

func(1);   ---- (1)

var obj = {
    b: 1,
    num: func
}

obj.num(1);  ---- (2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드에서 func의 console.log에 this만 추가시켰다.&lt;/li&gt;
  &lt;li&gt;(1)에서의 this는 전역을 가리키게 되지만, (2)에서는 obj를 가리키게 된다. ((2)의 값으로{b: 1, num: func()}이 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-this의-예외-케이스&quot;&gt;🌱 this의 예외 케이스&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;this가 포함된 함수를 다른 변수에 할당한 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = function() {
            console.log(this);
        }
        c();         --- (2)

        var self = this;
        var d = function () {
            console.log(self);
        }
        d();          ----- (3)
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;(1)은 b가 obj를 호출 주체를 명시하며 호출했기 때문에 this는 obj를 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(2)는 c 자체가 호출 주체를 명시하지 않고 호출했기 때문에 전역을 가리키게 된다.&lt;/li&gt;
  &lt;li&gt;(3)은 this를 b의 함수 안에 선언한 변수에 할당했기 때문에 이 때는 this가 상위의 호출 주체를 가리키게 된다.(여기에서는 obj)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이러한 현상을 ES6의 화살표 함수를 통해서도 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    b: function () {
        console.log(this);  --- (1)

        var c = () =&amp;gt; {
            console.log(this);
        }
        c();
    }
};

obj.b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;c에 있는 this는 c가 호출했다고 해서 전역을 가리키는 것이 아니라 화살표 함수를 사용했기 때문에 위와 같은 현상이 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;🎈 또, 콜백 함수, 생성자 함수 내부에서의 this는 위와 같이 동일한 현상이 일어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;(apply, call, bind 추가 포스팅 예정)&lt;/p&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="javascript" /><category term="CoreJavaScript" /><category term="this" /><category term="call" /><category term="apply" /><category term="bind" /><summary type="html">This의 개념과 작동 원리입니다.</summary></entry><entry><title type="html">[Algorithm] Two Pointer</title><link href="http://localhost:4000/devlog/algorithm-toPointer.html" rel="alternate" type="text/html" title="[Algorithm] Two Pointer" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>http://localhost:4000/devlog/algorithm-toPointer</id><content type="html" xml:base="http://localhost:4000/devlog/algorithm-toPointer.html">&lt;blockquote&gt;
  &lt;p&gt;1차원의 배열에서 2개의 포인터를 주어 풀어내는 알고리즘입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-two-pointer란&quot;&gt;Two Poiner란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-사용-예제&quot;&gt;사용 예제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-two-pointer란&quot;&gt;📌 Two Pointer란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;의미 그대로 2개의 포인터를 가진다.&lt;/li&gt;
  &lt;li&gt;1차원 배열에 포인터를 2개를 두어 각각 포인터들을 사용해 순차적으로 비교할 수 있다.&lt;/li&gt;
  &lt;li&gt;이중 for문을 사용해도 되지만, 이중 for문은 시간복잡도가 O(N&lt;sup&gt;2&lt;/sup&gt;)이고 Two Pointer는 O(N)이어서 시간적으로 효율이 더 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사용-예제&quot;&gt;📌 사용 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 두 배열을 오름차순으로 합치는 알고리즘을 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr1 = [1, 3, 5];
let arr2 = [2, 3, 4, 6, 8];

const twoPointer = (arr1, arr2) =&amp;gt; {
   let answer = [];
   let i = z = 0;

    while(i &amp;lt; arr1.length &amp;amp; z &amp;lt; arr2.length) {
       if(arr1[i] &amp;lt; arr2[z]) {
           answer.push(arr1[i++]);
       }
       if(arr1[i] &amp;gt; arr2[z]) {
           answer.push(arr2[z++]);
       }
       if(arr1[i] === arr2[z]) {
        answer.push(arr1[i++], arr2[z++])
       }
   }

   while(i &amp;lt; arr1.length) answer.push(arr1[i++]);
   while(z &amp;lt; arr2.length) answer.push(arr2[z++]);

   return answer;
}

twoPointer(arr1, arr2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;간단하게 concat으로 합친다음 sort으로 정렬해도 되는 문제라고 생각이 든다.&lt;/li&gt;
  &lt;li&gt;하지만 sort는 최악의 경우 O(N&lt;sup&gt;2&lt;/sup&gt;)이 될 수 있기 때문에 시간복잡도 측면에서는 효율이 좋지 못하다.&lt;/li&gt;
  &lt;li&gt;Two Pointer 알고리즘은 포인터가 배열의 끝에 다다르면 마무리되기 때문에 시간복잡도 측면에서 sort보다 효율이 좋다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="TwoPointer" /><summary type="html">1차원의 배열에서 2개의 포인터를 주어 풀어내는 알고리즘입니다.</summary></entry><entry><title type="html">[JavaScript] 실행 컨텍스트</title><link href="http://localhost:4000/devlog/excutionContext.html" rel="alternate" type="text/html" title="[JavaScript] 실행 컨텍스트" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>http://localhost:4000/devlog/excutionContext</id><content type="html" xml:base="http://localhost:4000/devlog/excutionContext.html">&lt;blockquote&gt;
  &lt;p&gt;실행 컨텍스트(Excution context)의 개념입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트란&quot;&gt;실행 컨텍스트란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트-동작-원리&quot;&gt;실행 컨텍스트 동작 원리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-실행-컨텍스트의-구조&quot;&gt;실행 컨텍스트의 구조&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-호이스팅hoisting&quot;&gt;Hoisting&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-예제&quot;&gt;예제&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-scope&quot;&gt;Scope&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트란&quot;&gt;📌 실행 컨텍스트란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수, 함수, 매개 변수등 환경 정보들을 수집하여 모아놓은 객체&lt;/li&gt;
  &lt;li&gt;Variable Environment, Lexical Environment, thisBinding으로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트-동작-원리&quot;&gt;📌 실행 컨텍스트 동작 원리&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;-사전에-알아야할-cs지식&quot;&gt;🌱 사전에 알아야할 CS지식&lt;/h3&gt;

&lt;h4 id=&quot;-stack&quot;&gt;○ Stack&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Stack은 출구가 하나뿐인 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 쌓아 저장했다면, 데이터를 꺼낼 때는 역순으로 꺼내야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/stack.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;-queue&quot;&gt;○ Queue&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Queue는 양쪽이 모두 열려있는 데이터 구조이다.&lt;/li&gt;
  &lt;li&gt;여러 가지 데이터를 순서대로 저장했다면, 순서대로 데이터를 꺼낼 수 있는 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/javascript/excutionContext/queue.png&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-그래서-실행-컨텍스트는&quot;&gt;🌱 그래서 실행 컨텍스트는?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;실행할 코드에 필요한 환경 정보들을 모아 놓은 실행 컨텍스트는 일반적으로 함수가 호출될 때 구성된다.&lt;br /&gt;
(전역은 코드가 실행되는 즉시 전역 환경 정보들을 모아 놓는다.)&lt;/li&gt;
  &lt;li&gt;전역을 첫번째로, 함수가 호출되면 각각 콜스택에 쌓인다.&lt;br /&gt;
(이 때, 콜스택에 쌓이면 해당 변수나 함수를 할당하다가 또다른 실행컨텍스트가 생기면 할당하던 컨텍스트는 잠시 중지된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-실행-컨텍스트의-구조&quot;&gt;📌 실행 컨텍스트의 구조&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 크게 3가지로 구성되어 있다. (ThisBinding은 다음에 공부..!)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Variable Environment &lt;br /&gt;
실행 컨텍스트가 환경 정보를 수집하는 최초의 값을 유지하며 담는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lexical Environment &lt;br /&gt;
Variable Envionment에 정보를 담은 후, Variable Environment를 토대로 Lexical Environment를 만든다. Lexical Environment는 Variable Environment와 다르게 환경 정보의 변경 값을 적용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Variable Environment와 Lexical Environment는 또 environmentRecord, outerEnvironmentReference로 구성되어 있다.&lt;/li&gt;
    &lt;li&gt;environmentRecord가 실행 컨텍스트의 환경 정보 수집하는 역할을 이행하는 역할을 맡고 있다&lt;/li&gt;
    &lt;li&gt;outerEnvironmentReference는 만약 해당 컨텍스트에서 참조해야하는 정보가 없을 경우 제일 근접한 상위 컨텍스트의 Lexical environment를 참조하는 역할을 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;-호이스팅hoisting&quot;&gt;🎈 호이스팅(Hoisting)?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;호이스팅은 선언한 변수들이 위치와 상관없이 제일 상단에 선언되어 변수나 함수를 호출할 수 있는 현상을 말한다.
실제로 코드가 제일 상단에 올라가는 것이 아니라, 코드가 실행되면 실행 컨텍스트가 만들어지고 환경 정보를 수집하는데 자바스크립트 엔진은 환경 정보로 수집한 변수명들을 먼저 알게 되는 것이다. 이 과정을 호이스팅이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-예제&quot;&gt;📌 예제&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1
function b() {
    function c() {
        console.log(a);
        var a = 1;
    }
    c();
    console.log(a);
}
b()
console.log(a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;전역 실행 컨텍스트가 형성되고 변수 a와 함수 b를 환경 정보에 저장했다. / 콜스택에 전역 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;변수 a에 1을 할당하고, b에 함수를 할당하고 함수를 호출한다. / 콜스택에 함수 b의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 b의 환경 정보로 변수 c에 함수가 할당되어 저장된다.&lt;/li&gt;
  &lt;li&gt;함수 b안에 함수 c가 호출되었다. / 콜스택에 함수 c의 실행 컨텍스트가 쌓였다.&lt;/li&gt;
  &lt;li&gt;함수 c안에 환경 정보로 a가 선언되어 호이스팅 되었다. / c안의 console은 호이스팅된 a를 가리키기 때문에 호이스팅으로 선언만 된 a를 undefined를 가진다.&lt;/li&gt;
  &lt;li&gt;함수 c의 실행 컨텍스트가 종료됨으로 b의 실행 컨텍스트로 넘어간다. / 함수 b의 console.log(a)는 해당 컨텍스트 안에 a가 없기 때문에, outerEnvironmentReference로 인해 a를 가지고 있는 제일 근접한 상위 컨텍스트의 Lexical Environment를 참조하려 한다. (정확히는 해당 컨텍스트가 실행되기 전 Lexical Environment를 참조한다.)&lt;/li&gt;
  &lt;li&gt;마침 전역에 a가 있으므로 함수 b의 console.log(a)는 1값을 가진다.&lt;/li&gt;
  &lt;li&gt;b의 실행 컨텍스트가 종료되고 전역 console.log(a)는 마지막 전역에 있는 a를 참조하여 1값을 가진다. / 전역 실행 컨텍스트가 완료되어 종료됨으로 콜스택에는 아무것도 남아있지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-scope&quot;&gt;🎈 Scope&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;scope는 쉽게 말해 변수의 유효 범위이다. 실행 컨텍스트와 가리키는 범위는 같지만, 스코프는 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정하는 것이 목적이다.
위의 예시에 있는 outerEnvironmentReference가 상위 Lexical Environment를 참조하게되는 연결점, 외부 실행 컨텍스트에서 내부 실행 컨텍스트에 저장된 변수들은 접근할 수 없는 것, 이러한 것들을 스코프 체인이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-정리&quot;&gt;📌 정리&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 변수나 함수같은 환경 정보들을 모아놓은 객체이다.&lt;/li&gt;
  &lt;li&gt;실행 컨텍스트의 정보들은 순서에 따라 콜스택 형태로 저장되고 호출된다.&lt;/li&gt;
  &lt;li&gt;호이스팅은 컨텍스트와 연관이 있으며, 코드가 실행되기 전 환경 정보를 저장하여 미리 변수명 등을 알게되는 자바스크립트 엔진에 의해 일어난다.&lt;/li&gt;
  &lt;li&gt;스코프는 실행 컨텍스트가 접근할 수 있는 변수나 함수들에게 순서를 부여하는 역할이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>gsy4568@gmail.com</email></author><category term="devlog" /><category term="javascript" /><category term="CoreJavaScript" /><category term="ExcutionContext" /><category term="LexicalEnvironment" /><category term="VariableEnvironment" /><summary type="html">실행 컨텍스트(Excution context)의 개념입니다.</summary></entry></feed>