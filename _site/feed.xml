<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2023-04-23T15:26:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Syeon</title><subtitle>&quot;생각하고 기록하는 습관을 익히는 중...&quot;
</subtitle><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><entry><title type="html">[Algorithm] 프로그래머스 신고결과받기</title><link href="http://localhost:4000/devlog/programmers.html" rel="alternate" type="text/html" title="[Algorithm] 프로그래머스 신고결과받기" /><published>2022-07-20T00:00:00+09:00</published><updated>2022-07-20T00:00:00+09:00</updated><id>http://localhost:4000/devlog/programmers</id><content type="html" xml:base="http://localhost:4000/devlog/programmers.html">&lt;blockquote&gt;
  &lt;p&gt;프로그래머스 신고결과받기(카카오)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#https://school.programmers.co.kr/learn/courses/30/lessons/92334&quot;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public int[] solution(String[] id_list, String[] report, int k) {

        HashMap&amp;lt;String, ArrayList&amp;lt;String&amp;gt;&amp;gt; notice = new HashMap&amp;lt;&amp;gt;();
        HashMap&amp;lt;String, Integer&amp;gt; personState = new HashMap&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; id_list.length; i++) {
            ArrayList&amp;lt;String&amp;gt; init = new ArrayList&amp;lt;&amp;gt;();
            notice.put(id_list[i], init);

            personState.put(id_list[i], 0);
        }


        for(int i = 0; i &amp;lt; report.length; i++) {
            StringTokenizer st = new StringTokenizer(report[i], &quot; &quot;);

            String reporter = st.nextToken();
            String reported = st.nextToken();

            if(notice.get(reporter).contains(reported)) {
                continue;
            }

            personState.put(reported, personState.get(reported) + 1);

            notice.get(reporter).add(reported);
        }

        int[] answer = new int[id_list.length];
        for(int i = 0; i &amp;lt; id_list.length; i++) {
            ArrayList&amp;lt;String&amp;gt; last = notice.get(id_list[i]);

            for (int x = 0; x &amp;lt; last.size(); x++) {
                if  (personState.get(last.get(x)) &amp;gt;= k) {
                    answer[i]++;
                }
            }
        }

        return answer;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;📌 피드백 포인트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;백준 풀이 방식에 익숙해져있다보니 StringTokenizer를 자주 쓰게 되는 것 같다. (split도 있으니 사용해보기)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for문 index를 정직하게 모두 사용하는 경우는 for(String i : list) 문법을 사용하여 좀 더 간결하게 만드는 것도 좋을 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;계속 틀렸던 부분이 contains로 해당 값이 있나 없나 검증하는 코드였다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;원래 처음에는 report를 sorting하고 한 reporter가 같은 reported 사람을 신고하면 1번만 처리되게하는 코드였는데 sorting으로 데이터를 나열하여 같은 값을 찾는건 위험하다는 것을 알게 된 것 같다. (ex. neo, neos일 경우)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 사람의 풀이를 보니 User라는 class를 만들고 report관련된 데이터를 class instance에 저장하는 방법을 사용한 것 같은데 신박했다. 새로운 api를 사용하고 method를 사용하는 것도 신기했지만, 객체지향 관점을 알고리즘에 적용하여 풀어내는 부분이 인상깊었다. 도전해봐야겠다!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><summary type="html">프로그래머스 신고결과받기(카카오)</summary></entry><entry><title type="html">[Algorithm] 백준 12845문제</title><link href="http://localhost:4000/devlog/baekjoon-12845.html" rel="alternate" type="text/html" title="[Algorithm] 백준 12845문제" /><published>2022-07-12T00:00:00+09:00</published><updated>2022-07-12T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-12845</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-12845.html">&lt;blockquote&gt;
  &lt;p&gt;백준 12845 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;영관이는 게임을 좋아한다. 별의별 게임을 다 하지만 그 중에서 제일 좋아하는 게임은 모두의 마블이다. 어김없이 오늘도 영관이는 학교 가는 버스에서 캐릭터 합성 이벤트를 참여했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 이벤트는 다음과 같다. 순서가 매겨진 여러 장의 카드가 있다. 각각의 카드는 저마다 레벨이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;카드 A에 카드 B를 덧붙일 수 있다. 이때 붙이는 조건은 다음과 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 카드는 인접한 카드여야 한다.
업그레이드 된 카드 A의 레벨은 변하지 않는다.
카드 합성을 할 때마다 두 카드 레벨의 합만큼 골드를 받는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;영관이가 골드를 최대한 많이 받을 수 있게 여러분이 도와주자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어, c1, c2, c3로 연속된 카드 3개가 있고 각각 레벨이 40,30,30 이라고 하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 카드들을 합치는 과정에서, 먼저 c3에 c2를 합쳐 임시 카드 x1을 만든다. x1의 레벨은 30이고 획득 골드는 60이다. 그 다음엔 c1에 x1을 합쳐 카드 x2를 만들면 레벨이 40이고 70만큼의 골드를 획득할 수 있다. 이때, 영관이가 획득한 골드는 70+60 = 130이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다른 방법으로 c1에 c2를 덧붙인 카드 x1을 만들면, x1의 레벨은 40이고 획득한 골드는 70이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;x1에 c3를 덧붙인 카드 x2의 레벨은 40이고 획득 골드는 70이다. 이때, 영관이가 획득한 골드는 70 + 70 = 140이다. 이외에 더 많은 골드를 받는 방법이 없으므로 140이 획득할 수 있는 최대 골드이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
3
40 30 30 / 140&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        Integer[] list = new Integer[N];

        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        for (int i = 0; i &amp;lt; N; i++) {
            list[i] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(list, Collections.reverseOrder());

        int result = 0;
        for (int i = 1; i &amp;lt; N; i++) {
            result += list[0] + list[i];
        }

        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;오랜만에 시간초과나 런타임 에러 없이 한번에 문제를 풀었다! (쉬운 문제지만..ㅎ)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문제에서 이것 저것 정보를 주지만, 문제의 핵심 요약은 나열되어 있는 수들을 짝을 지어 더하면 한 카드는 사라지고 두 카드의 레벨만큼 골드를 획득하는데 이 골드의 수가 가장 큰 경우를 구하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;생각해보면 문제에서는 인접한 카드의 합이라고 했지만 가장 레벨을 가지고 있는 카드를 기준으로 레벨을 더하면 결국 모든 카드가 가장 레벨이 높은 카드와 합해진다는 것을 의미할 수 있다.&lt;/li&gt;
  &lt;li&gt;따라서 내림차순으로 sorting한 다음 index 0을 기준으로 나머지 값들과 더한 값을 더한 값(result += list[0] + list[i] / 0 &amp;lt; i &amp;lt; N)이 정답이 되는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문제가 쉽기는 했지만 결국 문제를 푼다는 것은 대충 해당 알고리즘만 갔다가 끼워맞추는 것이 아니라 요구하는 바를 파악하고 문제에 맞는 알고리즘을 파악하고 최적의 방법을 생각하는 것이라 느꼈다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 12845 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1541문제</title><link href="http://localhost:4000/devlog/baekjoon-1541.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1541문제" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1541</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1541.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1541 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.
그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.
괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
55-50+40 / -35
10+20+30+40 / 100
0009 - 0009 / 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String input = br.readLine();

        // + 만 있는 경우
        if (!input.contains(&quot;-&quot;) &amp;amp;&amp;amp; input.contains(&quot;+&quot;)) {
            String[] indexes = input.split(&quot;\\+&quot;);

            int result = 0;
            for (int i = 0; i &amp;lt; indexes.length; i++) {
                result += Integer.parseInt(indexes[i]);
            }

            System.out.println(result);
        } else if (input.contains(&quot;-&quot;) &amp;amp;&amp;amp; !input.contains(&quot;+&quot;)) {
            // - 만 있는 경우
            String[] indexes = input.split(&quot;-&quot;);

            int result = Integer.parseInt(indexes[0]);
            for (int i = 1; i &amp;lt; indexes.length; i++) {
                result -= Integer.parseInt(indexes[i]);
            }

            System.out.println(result);
        } else if (input.contains(&quot;-&quot;) &amp;amp;&amp;amp; input.contains(&quot;+&quot;)) {
            // 두개 다 있는 경우
            String[] minusList = input.split(&quot;-&quot;);

            int result = 0;
            // first Value
            if (minusList[0].contains(&quot;+&quot;)) {
                String[] firstList = minusList[0].split(&quot;\\+&quot;);

                for (int i = 0; i &amp;lt; firstList.length; i++) {
                    result += Integer.parseInt(firstList[i]);
                }
            } else {
                result = Integer.parseInt(minusList[0]);
            }

            for (int i = 1; i &amp;lt; minusList.length; i++) {
                if (minusList[i].contains(&quot;+&quot;)) {
                    String[] indexValues = minusList[i].split(&quot;\\+&quot;);

                    for (int x = 0; x &amp;lt; indexValues.length; x++) {
                        result -= Integer.parseInt(indexValues[x]);
                    }
                } else {
                    result -= Integer.parseInt(minusList[i]);
                }
            }

            System.out.println(result);
        } else {
            System.out.println(Integer.parseInt(input));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이번 문제는 생각보다 쉬웠다. (정답률 50%이니 당연한건가..?)&lt;/li&gt;
  &lt;li&gt;임의의 괄호를 추가하여 식이 최솟값이 되려면 -를 기준으로 +하여 한꺼번에 빼면 된다고 생각하였다.&lt;/li&gt;
  &lt;li&gt;그래서 식에 +만 있는 경우, -만 있는 경우, +,-만 있는 경우 3가지로 나누어 코드를 설계하였다.&lt;/li&gt;
  &lt;li&gt;+만 있으면 + split하여 값을 모두 더하면 끝!&lt;/li&gt;
  &lt;li&gt;-만 있으면 처음 값만 양수로 지정하고 나머지를 모두 빼면 끝!&lt;/li&gt;
  &lt;li&gt;+, -가 모두 있으면 먼저 -를 기준으로 split한다. 그리고 각 index에 +가 있는 경우 값을 더해주고 아니면 그대로 둔다.&lt;/li&gt;
  &lt;li&gt;그리고 index 0을 양수로 두고 나머지를 모두 빼면 최솟값을 구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;처음에 NumberFormat 에러가 발생하기에 이게 머지라는 생각을 했다.&lt;/li&gt;
  &lt;li&gt;Integer.parseInt 할 때, 안의 값에 숫자 이외에 다른 타입의 문자가 섞여있으면 발생하는 에러였다.&lt;/li&gt;
  &lt;li&gt;그래서 +, -가 모두 있을 때는 index 하나하나에 문자들이 섞여있는지 모두 검사해주어 해결하였다. (다행히 시간초과는 아니었다.)!!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1541 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 4796문제</title><link href="http://localhost:4000/devlog/baekjoon-4796.html" rel="alternate" type="text/html" title="[Algorithm] 백준 4796문제" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-4796</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-4796.html">&lt;blockquote&gt;
  &lt;p&gt;백준 4796 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;등산가 김강산은 가족들과 함께 캠핑을 떠났다. 하지만, 캠핑장에는 다음과 같은 경고문이 쓰여 있었다.
캠핑장은 연속하는 20일 중 10일동안만 사용할 수 있습니다.
강산이는 이제 막 28일 휴가를 시작했다. 이번 휴가 기간 동안 강산이는 캠핑장을 며칠동안 사용할 수 있을까?
강산이는 조금 더 일반화해서 문제를 풀려고 한다.
캠핑장을 연속하는 P일 중, L일동안만 사용할 수 있다. 강산이는 이제 막 V일짜리 휴가를 시작했다. 강산이가 캠핑장을 최대 며칠동안 사용할 수 있을까? (1 &amp;lt; L &amp;lt; P &amp;lt; V)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
5 8 20 / Case 1: 14
5 8 17 / Case 2: 11
0 0 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int count = 1;

        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        while(true) {
            StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

            int L = Integer.parseInt(st.nextToken());
            int P = Integer.parseInt(st.nextToken());
            int V = Integer.parseInt(st.nextToken());

            if (L == 0 &amp;amp;&amp;amp; P == 0 &amp;amp;&amp;amp; V == 0) {
                break;
            }

            int result = ((V / P) * L) + (V % P);

            list.add(&quot;Case &quot; + count + &quot;: &quot; + result);
            count++;
        }

        list.forEach(System.out::println);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음 문제를 봤을 때 ‘어? 이거 쉬운데 왜 정답률이 30%대지??’ 라는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;막상 백준에서 제시해준 test case들을 기준으로 식을 세워 코드를 짰다. 그리고 제출을 한 결과..Fail..😂 그럼그렇지..&lt;/li&gt;
  &lt;li&gt;그런데 아무리 생각해봐도 저기에서 예외 케이스가 먼지 도통 알 수가 없었다..그저 빨리 풀고 싶었을 뿐..&lt;/li&gt;
  &lt;li&gt;조급한 마음에 다른 사람들이 썼던 풀이법을 살짝 봤는데.. 머리를 한대 맞은 느낌이었다.&lt;/li&gt;
  &lt;li&gt;V % P가 L보다 클 경우가 있다는 것… 예를 들어 5 8 15 케이스이다.&lt;/li&gt;
  &lt;li&gt;15 % 8 * 5는 문제없이 5이다. 여기서 내가 만든 코드를 넣으면 15 % 8 = 7 =&amp;gt; 5 + 7이 되는데.. 이 문제에서는 한번 연속된 값을 더할때는 분명 5(L)을 넘으면 안되는데… 중얼거리며 바로 수정하니 정답…&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int result = ((V / P) * L) + (V % P);

    =&amp;gt;

    int result1 = (V / P) * L;
    int result2;
    if (V % P &amp;gt; L) {
        result2 = L;
    } else {
        result2 = V % P;
    }

    int result = result1 + result2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;누가 그랬던 것 같은데..? 개발은 겸손해야한다고..&lt;/li&gt;
  &lt;li&gt;더 문제에 대해 고민해볼 수 있었지만, 깊이 생각하고 싶지 않고 내 코드가 왜 이상이 있지? 라고 생각했던 것이 이번 문제의 오답의 요인이 되었던 것 같다.&lt;/li&gt;
  &lt;li&gt;주어진 테스트 케이스 뿐아니라 다양한 상황에서 예외를 가질 수 있는 테스트 케이스가 있을 수 있고 이런 케이스들을 잘 찾아내는 능력도 중요하겠구나 라는 생각도 들었다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 4796 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1946문제</title><link href="http://localhost:4000/devlog/baekjoon-1946.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1946문제" /><published>2022-07-08T00:00:00+09:00</published><updated>2022-07-08T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1946</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1946.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1946 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(br.readLine());

        while(T-- &amp;gt; 0) {

            int N = Integer.parseInt(br.readLine());

            int[][] list = new int[N][2];

            for(int i = 0; i &amp;lt; N; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
                list[i][0] = Integer.parseInt(st.nextToken());
                list[i][1] = Integer.parseInt(st.nextToken());
            }

            Arrays.sort(list, (o1, o2) -&amp;gt; {
                return o1[0] - o2[0];
            });

            int count = 0;
            int pivot = list[0][1];

            for(int i = 1; i &amp;lt; N; i++) {
                if(pivot &amp;lt; list[i][1]) {
                    count++;
                } else {
                    pivot = list[i][1];
                }
            }

            System.out.println(N - count);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2일에 걸쳐 푼 문제…😂&lt;/li&gt;
  &lt;li&gt;어제는 생각을 쥐어짜내도 풀어지지가 않던데..(배탈나서 그런가..) 오늘은 앉아서 문제를 보자마자 술술 풀렸다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사실 술술 풀리기보다는 array sort만 오름차순으로 바꿨을뿐인데 풀이 방법이 생각났다…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;처음에는 이중 for문으로 하나하나 비교해서 값을 찾을까 했지만.. 아니나 다를까 시간초과가 떳다..&lt;/li&gt;
  &lt;li&gt;다른 자료구조를 사용해야하나 어떻게 해야하나 문제를 읽고 읽어서 요구하는 것을 파악하는데 시간이 좀 걸린 것 같다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이번 문제는 알고리즘이나 자료구조의 사용법보다 풀이 전략을 잘 세우는 것이 중요한 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 서류심사 기준으로 sorting을 한다. 1순위부터 n순위까지 sorting을 하면 면접 순위만 비교하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;서류 1순위가 면접 4순위라면, 그 다음 서류 2순위는 📌무조건!! 면접 4순위보다 높아야한다.&lt;/li&gt;
  &lt;li&gt;서류 2순위가 면접 4순위보다 낮은 순위라면 서류 1순위보다 두개 다 낮기 때문에 탈락되기 때문..!&lt;/li&gt;
  &lt;li&gt;이런 식으로 서류 1순위의 면접 순위를 pivot으로 정하고 서류 2순위가 서류 1순위보다 면접 순위가 높으면 pivot은 서류 2순의의 면접 순위로 재할당한다.&lt;/li&gt;
  &lt;li&gt;이렇게 비교하면 전체 count는 탈락한 사람들의 숫자가 나올텐데 여기서 전체(N) - 탈락인원(pivot)을 하면 값을 구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1946 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 13458문제</title><link href="http://localhost:4000/devlog/baekjoon-13458.html" rel="alternate" type="text/html" title="[Algorithm] 백준 13458문제" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-13458</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-13458.html">&lt;blockquote&gt;
  &lt;p&gt;백준 13458 Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
1
1
1 1 / 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3
3 4 5
2 2 / 7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
1000000 1000000 1000000 1000000 1000000
5 7 / 714290&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
10 9 10 9 10
7 20 / 10&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5
10 9 10 9 10
7 2 / 13&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        int[] place = new int[N];

        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
        for (int i = 0; i &amp;lt; place.length; i++) {
            place[i] = Integer.parseInt(st.nextToken());
        }

        StringTokenizer person = new StringTokenizer(br.readLine(), &quot; &quot;);
        int B = Integer.parseInt(person.nextToken());
        int C = Integer.parseInt(person.nextToken());

        int count = 0;

        for (int i = 0; i &amp;lt; place.length; i++) {
            // 총감독관 counting
            int remain = place[i] - B;
            count++;

            // 부감독관 counting
            // remain 이 0 이하일 경우
            if (remain &amp;lt;= 0) {
                continue;
            }

            // remain 이 C 보다 작을 경우
            if (remain &amp;lt;= C) {
                count++;
                continue;
            }

            // remain 이 C 보다 클 경우
            if (remain &amp;gt; C) {
                if(remain % C == 0) {
                    count += remain / C;
                } else {
                    count += (remain / C) + 1;
                }
            }
        }

        System.out.println(count);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;각 시험장마다 총감독관은 1명씩 무조건 필요하므로 총감독관의 감독가능 학생 수를 뺀 나머지 값을 부감독관 감독 가능 수로 나누어 count한다.&lt;/li&gt;
  &lt;li&gt;총감독관 무조건 한명 =&amp;gt; (total 학생 - 총감독 가능 인원 = a) -&amp;gt; a / 부감독 가능 인원 -&amp;gt; 만약 a와 부감독 가능 인원의 나눈 값에 나머지가 있다면 count + 1 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    long count = 0;

    int[] place = new int[N];
    for(int i = 0; i &amp;lt; N; i++) {
        place[i] = sc.nextInt();
    }

    int B = sc.nextInt();
    int C = sc.nextInt();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 문제는 쉬운 것 같은데 왜 정답률이 20%인지 잘 몰랐다.&lt;/li&gt;
  &lt;li&gt;막상 풀어보니 풀이 방법은 맞는 것 같은데 계속 틀리는 이유가 무엇인지 모르겠다..&lt;/li&gt;
  &lt;li&gt;IDE로 풀어보았을 때 테스트 코드는 모두 통과했지만 백준에서는 계속 제출하자마자 틀렸다는 문구가 나왔다…&lt;/li&gt;
  &lt;li&gt;혹시나 싶어서 BufferedReader 대신 Scanner를 사용해보았는데 성공.. (차이가 머지..?)&lt;/li&gt;
  &lt;li&gt;일단 Scanner 사용방법을 알게 되어 좋긴했지만.. 소요된 시간이 아깝..ㅠ&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 13458 Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 2217문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-2217.html" rel="alternate" type="text/html" title="[Algorithm] 백준 2217문제 (Greedy)" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-2217</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-2217.html">&lt;blockquote&gt;
  &lt;p&gt;백준 2217 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
2
10
15 / 20&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        ArrayList&amp;lt;Integer&amp;gt; ropes = new ArrayList&amp;lt;&amp;gt;();

        for(int i = 0; i &amp;lt; N; i++) {
            int rope = Integer.parseInt(br.readLine());

            ropes.add(rope);
        }

        ropes.sort((o1, o2) -&amp;gt; {
            return o1 - o2;
        });

        int result = 0;

        for (int i = 0; i &amp;lt; ropes.size(); i++) {
            int curWeight = ropes.get(i) * N;

            result = Math.max(result, curWeight);
            N--;
        }

        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;처음에는 주어진 ropes들을 Des sorting하여 제일 앞에 있는 rope에 N을 곱하여 최대 중량을 구하는 문제라고 생각했다. 하지만 그렇게 간단한..?(너무 간단한가..?) 문제는 아니었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ropes에 많은 좋은 rope들이 있더라도 index 0에 있는 줄의 최대 중량이 1이라면 1 * N밖에 되지 않는 최대 중량이 될 것이다.&lt;/li&gt;
  &lt;li&gt;그래서 로프가 N–일 때 그에 맞는 최대 중량이 다 다를 것이고 값도 규칙성을 가지지 않기 때문에 하나하나 Math.max하여 비교한 값을 return 하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;처음으로 다른 분들의 코드와 비슷했다. (뿌듯)&lt;/li&gt;
  &lt;li&gt;문제의 난이도가 쉽다고 하지만 이것을 기점으로 더 알고리즘 성장을 이뤄내고 싶다🔥&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 2217 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 11000문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-11000.html" rel="alternate" type="text/html" title="[Algorithm] 백준 11000문제 (Greedy)" /><published>2022-07-04T00:00:00+09:00</published><updated>2022-07-04T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-11000</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-11000.html">&lt;blockquote&gt;
  &lt;p&gt;백준 11000 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.
김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.
참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input / Output
3
1 3
2 4
3 5 / 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        while(N-- &amp;gt; 0) {
            ArrayList&amp;lt;Integer&amp;gt; classes = new ArrayList&amp;lt;&amp;gt;();

            StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
            int startClass = Integer.parseInt(st.nextToken());
            int endClass = Integer.parseInt(st.nextToken());

            classes.add(startClass);
            classes.add(endClass);

            list.add(classes);
        }

        list.sort((o1, o2) -&amp;gt; {
          if(o1.get(1) == o2.get(1)) {
            return o1.get(1) - o2.get(1);
          }

          return o1.get(0) - o2.get(0);
        });


        // 시간초과
//        ArrayList&amp;lt;Integer&amp;gt; endList = new ArrayList&amp;lt;&amp;gt;();
//        endList.add(list.get(0).get(1));
//
//        for (int i = 1; i &amp;lt; list.size(); i++) {
//            boolean isChanged = false;
//
//            for (int x = 0; x &amp;lt; endList.size(); x++) {
//
//                if (list.get(i).get(0) &amp;gt;= endList.get(x)) {
//                    endList.set(x, list.get(i).get(1));
//                    isChanged = true;
//                    break;
//                }
//            }
//
//            if(!isChanged) {
//                endList.add(list.get(i).get(1));
//            }
//        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;저번에 풀었던 회의실 문제랑 비슷한 문제라고 생각했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 강의 시간들을 잘 정렬하는 것이 이 문제의 키포인트 중 하나이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;강의 시간을 정렬할 때 기본적으로 시작시간 기준으로 오름차순으로 정렬하되, 만약 시작시간이 같을 경우 끝나는 시간을 오름차순으로 정렬한다.&lt;/li&gt;
  &lt;li&gt;이렇게 시간을 정렬하고나면 시간을 for문으로 각각 비교하였을 때 오름차순 순으로 시간들을 비교할 수 있어서 이중, 삼중으로 비교하고 값을 할당하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;그렇게 최소한의 비교를 위해 전체 시간 정렬 list와 끝나는 시간 list를 만들어 비교하려고 했..으나.. 계속 ‘시간초과’가 발생하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;();
    pq.add(list.get(0).get(1));

    for (int i = 1; i &amp;lt; list.size(); i++) {
        if(pq.peek() &amp;lt;= list.get(i).get(0)) {
            pq.poll();
        }

        pq.add(list.get(i).get(1));
    }

    System.out.println(pq.size());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;로직이 잘못된 것인지, for loop 하나로 해결할 수 있는 방법이 있는지 계속 고민했지만 결국 해결하지 못했다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하루 이틀 고민해봤지만 무엇이 문제인지 알수가 없어서 결국 다른 사람들이 어떻게 풀이하였는지 참고하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;참고해보니 접근법은 비슷했다. 다만, 이 접근법을 통해 더 효율적인 방안을 사용하는 것…&lt;/li&gt;
  &lt;li&gt;Java로 알고리즘 문제들을 풀이할 때 지금까지 알고리즘 방법에서 막혔었다면.. 이번에는 자료구조에 실패의 요인이 있었다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ArrayList는 get 메소드 경우 O(1)로 복잡하지 않지만, add, remove 등의 메소드는 O(n)의 시간이 소요된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그럴 때 사용하는 자료구조가 우선순위 큐(최대 / 최소 힙)이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우선순위 큐는 시간복잡도가 O(logN)으로 이 문제에서 요구하는 각 시간들을 비교할 때 최적의 자료구조라고 생각되었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자료구조를 ArrayList에서 PrioityQueue로 바꾸니 정답이었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이번 문제를 통해 각 문제마다 접근할 수 있는 것이 알고리즘뿐 아니라 자료구조에 대해 고민해보게 되었다… 점점 고려할 사항들이 많아지니 언제 한번 문제 접근 방법에 대해 고민해보는 시간을 가져야겠다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 11000 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 1783문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-1783.html" rel="alternate" type="text/html" title="[Algorithm] 백준 1783문제 (Greedy)" /><published>2022-07-01T00:00:00+09:00</published><updated>2022-07-01T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-1783</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-1783.html">&lt;blockquote&gt;
  &lt;p&gt;백준 1783 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2칸 위로, 1칸 오른쪽
1칸 위로, 2칸 오른쪽
1칸 아래로, 2칸 오른쪽
2칸 아래로, 1칸 오른쪽
병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;100 50 =&amp;gt; 48
1 1 =&amp;gt; 1
17 5 =&amp;gt; 4
2 4 =&amp;gt; 2
20 4 =&amp;gt; 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int count = 1;
        int moveM = 1;

        // 최대 칸이 4이상일 최소 경우의 수
        if (N &amp;gt;= 3 &amp;amp;&amp;amp; M &amp;gt;= 7) {
            count = 5;
            moveM = 7;

            while (M &amp;gt;= moveM + 1) {
                moveM++;
                count++;
            }

            System.out.println(count);
        } else {
            // 최대 칸이 4미만이며, 말이 위 아래로 왔다갔다할 수 있는 경우
            // 세로칸이 3칸일 경우 오른쪽으로 1씩 이동 가능
            if (N &amp;gt; 2) {
                while (M &amp;gt;= moveM + 1) {
                    count++;
                    moveM++;
                }

                System.out.println(Math.min(count, 4));
                return;
            }

            // 세로칸이 2칸일 경우 오른쪽으로 2씩 이동 가능
            if (N &amp;gt; 1) {
                while (M &amp;gt;= moveM + 2) {
                    count++;
                    moveM += 2;
                }

                System.out.println(Math.min(count, 4));
                return;
            }

            System.out.println(count);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;문제에서 체스말이 움직일 수 있는 방법은 4가지이지만, 제약을 기준으로 코드를 설계하는 것이 좋을 것 같다고 판단했다.&lt;/li&gt;
  &lt;li&gt;체스말이 최대 4번 이상 움직일 수 있으면 무조건 4가지 이동방법을 다 사용해야하는 제약을 통해 알 수 있는 것이 있다.&lt;/li&gt;
  &lt;li&gt;체스말의 이동 방법의 특징은 상하로는 언제든지 움직일 수 있지만, 좌우로는 무조건 오른쪽으로 이동한다는 특징이다.&lt;/li&gt;
  &lt;li&gt;이 특징을 활용하여 세로칸이 3이상, 가로칸이 7이상인 경우 위에서 언급한 제약사항을 적용한다.&lt;/li&gt;
  &lt;li&gt;제약사항에 적용되지 않는 상황일 때는 각 세로칸에서(2 or 1) 가로칸으로 움직일 수 있는 상황을 구한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        if(N == 1) { System.out.println(1); }

        if(N == 2) {
            int result = Math.min(4, 1 + ((M - 1) / 2));
            System.out.println(result);
        }

        if(N &amp;gt;= 3) {
            if(M &amp;gt;= 7) {
                System.out.println(5 + (M - 7));
            } else {
                System.out.println(Math.min(4, M));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;특징을 다시 잘 살펴보면, 세로칸이 1일 경우, 2일 경우, 3이상일 경우로 나누어 코드를 단축시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;세로가 1일 경우에는 당연히 움직이지 못하기 때문에 (1, 1)하나로 return 1&lt;/li&gt;
  &lt;li&gt;세로가 2일 경우에는 체스말이 상하로 1씩밖에 움직이지 못하기 때문에 오른쪽으로 무조건 2씩 이동해야한다.&lt;/li&gt;
  &lt;li&gt;세로가 3 이상일 경우에는 제약 사항을 적용해야한다.&lt;/li&gt;
  &lt;li&gt;즉, 세로가 3이상이면서 가로가 7이상이면 4가지 방식을 다 적용한 이후의 좌표 (3, 7)부터 오른쪽으로 가능한 한 움직인다.&lt;/li&gt;
  &lt;li&gt;가로가 7 미만이면 제약사항을 적용시키지 못하므로 무조건 최대값은 4가 된다. (4 이상이려면 제약사항을 적용해야하므로)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇기 때문에 상하로는 계속 움직일 수 있지만 가로로는 4와 M 중 최소값을 return하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코드를 설계할 때 문제를 잘 파악하여, 기준점을 잘 세우는 것이 중요할 것 같다.&lt;/li&gt;
  &lt;li&gt;문제를 잘 파악하는 능력을 길러야겠다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 1783 Greedy Algorithm 문제입니다.</summary></entry><entry><title type="html">[Algorithm] 백준 10610문제 (Greedy)</title><link href="http://localhost:4000/devlog/baekjoon-10610.html" rel="alternate" type="text/html" title="[Algorithm] 백준 10610문제 (Greedy)" /><published>2022-06-30T00:00:00+09:00</published><updated>2022-06-30T00:00:00+09:00</updated><id>http://localhost:4000/devlog/baekjoon-10610</id><content type="html" xml:base="http://localhost:4000/devlog/baekjoon-10610.html">&lt;blockquote&gt;
  &lt;p&gt;백준 10610 Greedy Algorithm 문제입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!---more---&gt;

&lt;ul&gt;
  &lt;li&gt;목차
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#-문제&quot;&gt;문제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-나의-풀이&quot;&gt;나의 풀이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#-자가-피드백&quot;&gt;자가 피드백&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-문제&quot;&gt;📌 문제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.
미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-나의-풀이&quot;&gt;📌 나의 풀이&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Thirty10610 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String fullText = br.readLine();
        int N = fullText.length();

        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; N; i++) {
            list.add(Integer.parseInt(fullText.substring(i, i + 1)));
        }

        list.sort((o1, o2) -&amp;gt; o2 - o1);

        StringBuilder sb = new StringBuilder();
        list.forEach(sb::append);

        String value = sb.toString();

        Integer finalValue = Integer.parseInt(value);

        if(finalValue % 30 != 0) {
            System.out.println(-1);
        } else {
            System.out.println(finalValue);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;풀이전략&lt;/li&gt;
  &lt;li&gt;30의 배수에 대한 특징을 살펴보아 10의 자리의 수 특성에 따라 뒤에 무조건 0이 있어야하는 것,&lt;/li&gt;
  &lt;li&gt;또한 각 자리의 숫자를 모두 더한 값이 3의 배수여야했다. (수학적으로 알아볼 필요가 있을 것 같…)&lt;/li&gt;
  &lt;li&gt;이러한 특징들을 고려하여 알고리즘을 만들었으나…IDE에서는 자가 테스트로 통과되었지만 백준에서는 계속 NumberFormat 에러가 발생하였다..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-자가-피드백&quot;&gt;📌 자가 피드백&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String fullText = br.readLine();
        int N = fullText.length();

        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int total = 0;

        for (int i = 0; i &amp;lt; N; i++) {
            int parseInt = Integer.parseInt(fullText.substring(i, i + 1));

            list.add(parseInt);
            total += parseInt;
        }

        if(total % 3 != 0 || !list.contains(0)) {
            System.out.println(-1);
            return;
        }

        list.sort((o1, o2) -&amp;gt; o2 - o1);

        list.forEach(System.out::print);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제를 다시 잘 읽어보니 N은 10^5 개의 숫자들이라고 한다.&lt;/li&gt;
  &lt;li&gt;사실 저게 무슨 의미인지 아직 이해가 잘 가지 않지만, 다른 분들의 설명을 들은 결과 N의 결과를 Integer는 물론이거니와 Long으로도 형변환할 수 없다는 것이었다…&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 어떻게 풀어내지 고민했는데 각각 값들을 System.out.print하면 하나로 보이지 않을까 해서 해봤는데.. 통과!!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;문제들을 풀어보니 여러가지 고려사항들이 하나씩 늘어가기 시작한다. 시간/공간 복잡도, 주어지는 input을 어떻게 찰떡같이 받아내서 output으로 내보낼 수 있을지.. 등등..&lt;/li&gt;
  &lt;li&gt;이번 풀이에서 소요된 시간이 1000ms이 걸렸는데 다른 사람들은 100~200ms으로 푼 사람들도 있었다.&lt;/li&gt;
  &lt;li&gt;문제 접근 방식은 같지만 loop를 유발하는 메소드, BufferedReader, StringBuffer 같은 API 활용이 시간을 더 단축시킬 수 있다는 생각에 이러한 툴들을 적재적소에 사용하는 것이 중요할 것 같다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SuYeon Kim</name><email>waterkite94@gmail.com</email></author><category term="devlog" /><category term="algorithm" /><category term="greedy" /><summary type="html">백준 10610 Greedy Algorithm 문제입니다.</summary></entry></feed>