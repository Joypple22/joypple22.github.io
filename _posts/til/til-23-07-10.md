---
layout: post
title: "23.07.10 TIL"
subtitle: "Today I Learned"
categories: til
tags: daily
image:
  path: https://wkblog-images.s3.ap-northeast-2.amazonaws.com/til/cover/red.jpeg
---

> Today I Learn 💁🏻‍♂️

</--more-->

## 🌱 오늘 스터디 내용
### 🟤 운영체제
- 컴퓨터 시스템의 구조에 대해서 설명해보자 (자유롭게)

컴퓨터 시스템은 컴퓨터 내부 장치(CPU, 메모리 등)과 외부 장치(디스크, 키보드 등)로 이루어져있다. 외부 장치로부터 데이터를 입력받아 요청 처리를 위해 내부 장치까지 
오게 되는 과정을 Input(입력)이라고 하고 내부 장치에서 요청받은 데이터를 처리하여 다시 외부 장치로 보내는 과정을 Output이라고 한다. 이 과정을 통틀어 I/O라고 한다.

각 외부 장치에는 CPU의 역할을 대신 수행해주는 컨트롤러가 존재한다. 이 컨트롤러는 외부 장치에서 다양한 역할을 수행하면서 처리해야하는 연산을 하게 된다. 이 때, 연산하면서 발생하는 
데이터는 외부 장치의 로컬 버퍼라는 곳에 저장된다.

정라하면, CPU는 내부 장치의 요청으로부터 외부 장치에서 데이터를 처리할 때 컨트롤러에게 역할을 위임한다. 역할을 위임받은 컨트롤러는 외부 장치의 연산을 수행한 후 로컬 버퍼에 데이터를 저장한다.
(이 때 역할을 위임한 CPU는 현재 외부 장치에 요청을 의뢰한(시스템 콜) 프로세스를 잠시 Blocked 상태로 만들고 다른 Ready 상태에 있는 프로세스를 실행한다.) 외부 장치의 처리를 마친 컨트롤러는 
CPU에 있는 인터럽트 라인에 자신의 처리가 완료되었음을 알리는 인터럽트를 세팅한다. CPU는 하나의 명령 단위로 일반 명령을 처리하면서 인터럽트 라인을 지속적으로 확인하는데, 이 때 컨트롤러로부터 세팅된 
인터럽트가 있다면 CPU는 그 즉시 실행하고 있던 프로세스를 멈추고 인터럽트 백터 자료구조에서 해당 인터럽트를 처리할 수 있는 인터럽트 핸들러를 탐색한다. 해당 인터럽트 핸들러를 통해 상황에 맞는 인터럽트가 
발생한다. 일반적으로 인터럽트 핸들러가 발생하면 현재 프로세스를 멈추고 커널의 데이터 영역에 있는 PCB 자료구조에 현재 CPU가 실행하고 있던 프로세스의 상태를(Ready) 저장한다. 그리고 로컬 버퍼에 있는 
데이터를 수집하여 외부 장치에 요청한 프로세스의 메모리에 저장한다. 그리고 난 뒤에 CPU는 Blocked된 프로세스를 Ready 상태로 변경하고 CPU 스케줄러에 의해 프로세스를 받아 다시 처리하게 된다. (컨텍스트 스위칭)

위의 상황은 일반적으로 동기식 입출력에 해당하는 과정이다. 반면에 비동기식 입출력은 CPU가 프로세스의 시스템 콜을 처리하면서 프로세스를 Blocked 상태로 만드는 것이 아니라 입출력의 과정에 상관없이 계속 프로세스를 
실행하는 것을 의미한다.

----
- 프로세스와 외부 장치의 동시성 이슈를 제어하는 방법

만일 동기식 입출력 방식을 하는 프로세스 2개가 있다고 가정해보자. 프로세스 A는 하나밖에 없는 키보드(외부 장치)에 1이라는 데이터에 접근하는 요청을하고 Blocked의 상태가 된다. 이 때 프로세스 B가 CPU를 
점유하여 똑같이 키보드에 1이라는 데이터를 2로 변경했다고 가정해보자. 동시성 제어가 없다면 프로세스 A는 프로세스 B가 먼저 키보드에 대한 요청을 처리했을 경우 1이 아닌 2라는 데이터를 조회하여 처리하게 될 것이다. 
이것을 방지하기 위하여 커널 영역에는 각 외부 장치에 접근하는 프로세스들을 큐에 저장하고 FIFO 방식으로 프로세스의 요청을 처리하도록 했다. 그렇기 때문에 다수의 프로세스가 동시에 실행되면서 발생할 수 있는 외부 
장치의 동시성 이슈를 제어할 수 있게 되었다.

---
- DMA

CPU는 외부 장치의 처리가 완료된 이후 인터럽트를 통해 로컬 버퍼에 접근하여 데이터를 가져온다. 하지만 너무나 빈번한 요청일 경우 CPU가 
모든 것을 담당하기에는 너무 많은 처리들이 있기에 DMA라는 장치 컨트롤러를 두어 CPU 대신 외부 장치로부터 데이터를 수집하는 역할을 한다. 이 때, DMA는 데이터의 단위를 
Block 단위로 가져오기 때문에 한번에 많은 양의 데이터를 가져와 CPU에게 인터럽트 신호를 줄 수 있다.
이런 장치가 있는 이유는 바로 외부 장치로 접근하는 I/O는 특권 명령이기 때문이다. 사용자 프로세스가 직접적으로 외부장치를 제어하게 되면 시스템적인 보안이 침해될 
수 있다. 이에 I/O 요청같이 보안이 필요한 작업은 사용자 프로세스가 직접 접근하느 것을 막고 운영체제가 이를 관리하며 접근하도록 설계되었다. 외부 장치로부터 
프로세스가 외부 장치로부터 데이터를 가져오지 못하기 때문에 CPU가 OS의 시스템 콜 함수를 통해 직접 가져와야된다.

-----
- 보안

컴퓨터 시스템은 다양한 환경에서 보안을 지키기 위해 여러가지 장치들을 마련했다.

먼저 하드웨어적인 보안이다. 하드웨어적 보안은 사용자 프로세스가 직접적으로 다른 외부장치에 접근하는 것을 막는 것을 대표적으로 이야기할 수 있다. 
만일 사용자 프로세스가 직접적으로 외부 장치에 접근하게 된다면 해커들이 무단으로 프로세스를 통해 컴퓨터에 있는 여러 정보들을 가로챌 수도 있고, 시스템을 
엉망으로 만들 수도 있다. 이로 인해 시스템적으로 유저모드와 커널모드를 지원하고 해당 모드에 따라서 접근할 수 있는 영역들이 달라지게 된다.

유저모드는 사용자 프로세스가 CPU를 점유하여 자신의 명령을 처리하고 있는 단계이다. 이 때는 모드비트가 1로 설정되어 사용자 프로세스가 직접적으로 
타 메모리에 접근하거나 시스템에 접근하는 것을 일체 차단한다. 반면에 커널모드는 운영체제가 CPU를 점유하여 여러 시스템 장치에 직접적으로 접근할 수 있는 
권한을 얻게되는 것을 의미한다. 만약 사용자 프로세스가 시스템에 접근해야할 때는 시스템 콜이라는 함수이자 인터럽트(트랩)을 호출하여 운영체제에게 그 처리를 대신 요청해야한다. 
사용자 프로세스가 시스템 콜을 호출하면 모드비트가 0으로 변경되고 운영체제가 CPU를 점유하여 사용자 프로세스에게 받은 요청을 처리한다.

두번째로는 메모리 보안이다. 프로세스는 자신에게 주어진 메모리 주소 이외에 다른 주소에 접근할 수 없다. 시스템적으로 프로세스마다 메모리의 기준을 정하는 방법이 있는데, 
기준 레지스터와 한계 레지스터를 사용하여 접근 가능한 메모리의 밤위를 부여한다. 이 범위 외의 메모리에 접근하게 되면 운영체제는 해당 프로세스를 강제적으로 종료한다.

세번째로는 CPU의 보안이다. CPU는 연산을 위한 장치일 뿐 스스로 프로세스의 상태를 확인하여 처리하는 장치가 아닌 수동적인 장치이다. 그렇기 때문에 
다른 프로세스로 변경하여 처리하는 특별한 장치 없다면 하나의 프로세스가 CPU를 독점하여 시분할 처리를 하지 못할 것이다. 컴퓨터 시스템에는 타이머라는 
장치를 마련하여 프로세스가 CPU를 점유하여 사용하기 시작하면 카운터를 센다. 정해진 카운터를 다 사용하면 타이머가 인터럽트를 세팅하여 CPU를 점유하고 있던 프로세스가 
다른 프로세스로 컨텍스트 스위칭하게 된다.

### 🟤
