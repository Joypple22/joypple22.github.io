---
layout: post
title: "운영체제"
subtitle: "운영체제 간략 정리"
categories: devlog
tags: computer_science 운영체제
---

> 운영체제를 공부하고 간략하게 정리한 글입니다.

<!---more--->

## 📌 운영체제

---

### 🌱 운영체제란?

- 컴퓨터 시스템의 자원들을 효율적으로 관리
- 사용자가 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
- Window, macOS, Android 등 다양한 운영체제 존재
- 운영체제가 없어도 동작은 하지만 처음에 설계한 그대로만 사용 가능(유연한 작업 X)

---

### 🌱 운영체제의 역할

- 프로세스 관리 : 다양한 프로그램을 동시 실행(시분할 처리)
- 메모리 관리 : 모든 응용 프로그램은 메모리 위에서 동작
- 하드웨어 관리 : 사용자가 하드웨어에 대한 직접적 접근 권한 차단 -> 메모리 중복 사용을 방지하여 각 프로세스들의 정보들이 얽히는 상황을 방지 / 해킹으로 인한 조작 방지
- 파일 시스템 관리

---

### 🌱 운영체제의 구조

#### <strong>커널</strong>

- 운영체제의 핵심 기능을 담당한다. -> 컴퓨터의 자원을 관리(사용자와 상호작용X)
- 시스템 프로그램이 사용자와 커널을 이어주는 역할
- 컴퓨터 물리적 자원, 추상화 자원을 관리 -> 여러 자원을 추상화하여 각 하드웨어의 물리적 자원과 대응함 (CPU : task / 디스크 : File / 메모리 : page, segment / network : socket)
- 커널의 기능
  - 디바이스 관리 : 디바이스 드라이버 소프트웨어 이용
- 프로세스 관리
  - 리눅스는 프로그램을 실행할 때 약 100여개의 프로세스가 동시에 실행
  - 각 프로세스의 PID를 통해 시분할 처리로 관리
- 메모리 관리
  - 프로그램 뿐 아니라 프로그램의 데이터 영역까지 메모리에 저장 -> 메모리 영역 분배 / 수거
  - 가상 메모리 지원

#### <strong>시스템 콜</strong>

- 어플리케이션이 커널에 접근하기 위한 도구
- 사용자로부터 커널을 보호하기 위한 인터페이스(저장공간을 안전하게 분배)

#### <strong>User Interface</strong>

- 사용자는 인터페이스만을 이용해서 커널에 접근
- GUI : 그래픽 유저 인터페이스
  - 그래픽 환경으로 시스템 제어
- CLI : 커멘드 라인 인터페이스
  - 명령어를 통해 시스템 제어

---

### 🌱 하드웨어의 구조

- 폰 노이만 구조
  - CPU <-> Bus <-> Memory
- CPU 구조
  - 제어 장치 : 모든 장치 동작 제어
  - 산술 논리 연산 장치 : 데이터 연산
  - 레지스터 : CPU내 계산을 위한 임시 보관 장소(ex. 변수)
- 메모리 구조
  - RAM : 메인 메모리
  - ROM : 컴퓨터 부팅 바이오스 저장

---

### 🌱 인터럽트

- CPU가 입출력 관리자를 통해 각 하드웨어 및 소프트웨어의 이벤트를 확인하여 처리하는 방식
- 과거에는 요청이 들어왔는지 CPU가 계속 확인하는 방식(Polling)
- 오늘 날 CPU가 명령 이후 다른 작업을 진행하다가 입출력 관리자로부터 해당 작업이 완료됨을 CPU에게 알리는 방식(인터럽트 / 비동기적으로 동작)

## 📌 프로세스 / 쓰레드

---

### 🌱 프로그램과 프로세스

- 프로그램 : 저장 장치에 저장된 명령문의 집합체(어플리케이션, \*.exe)
- 프로세스 : 실행 중인 프로그램
  - 하드 디스크에 저장된 프로그램이 메모리에 올라온 것이 실행 중인 프로그램 즉 프로세스라고 정의한다.
- 프로그램은 저장장치만 사용하지만 프로세스는 RAM, CPU등을 사용한다.

---

### 🌱 프로세스의 구조

- CODE 영역 : 실행하는 코드가 저장된다.
- DATA 영역 : 전역변수 / 정적변수가 저장된다.
- HEAP 영역 : 사용자가 동적으로 메모리를 할당 가능한 영역이다.
- STACK 영역 : 지역변수 / 함수 호출 시 매개변수 / 주소를 저장한다.

---

### 🌱 코드가 실행되는 과정 (ex. c언어)

- 컴파일 과정

1. test.c파일이 전처리기를 거쳐 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러온 뒤에 test.i 파일로 변경
2. test.i는 컴파일러를 거쳐 고수준 C언어를 저수준 어셈블리어로 변환하며 test.s인 파일로 변경
3. test.s는 어셈블러를 거쳐 기계어로 구성된 test.o파일로 변환한다.
4. test.s를 링커가 링킹을 한다. 링킹을 마치면 test.s는 test.exe파일로 변환된다.
   => exe 파일을 실행시키면 코드가 메모리에 올라가 프로세스가 된다. 프로세스가 되면 운영체제가 프로세스를 관리한다.

- CPU가 코드를 실행시키는 과정

1. CPU내의 제어장치가 코드의 값을 메모리에 저장시킨다.
2. 메모리에 저장된 값을 레지스터로 가져와 산술 논리 연산장치에 의해 처리된다.
3. 처리된 결과값을 레지스터에 저장하면 제어 장치가 레지스터에 저장된 값을 메모리에 저장시킨다.

---

### 🌱 멀티프로그래밍 / 멀티프로세싱

- 유니프로그래밍 : 메모리에 1개의 프로세스를 올려 파일을 실행시킬 수 있다.
  - 스와핑이라는 동작을 통해 저장장치와 메모리가 프로세스를 주고받으며 프로그램을 실행시킨다.
- 멀티프로그래밍 : 메모리 내에 여러 개의 프로세스를 올려 실행시킬 수 있다.
- 멀티프로세싱 : CPU가 여러개의 프로세스를 동시에 처리할 수 있다.(시분할 처리)

---

### 🌱 PCB(Process Control Block)

- 프로세스가 만들어지면 운영체제가 해당 프로세스의 정보를 가지고 있는 PCB를 생성한다.
- PCB들은 Linked-list 형태로 저장되어 있다.

- PCB의 구조
  - 포인터 : 부모와 자식 프로세스에 대한 포인터 / 할당된 자원에 대한 포인터 등이 있으며, 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.
  - 프로세스 상태 : 5가지의 프로세스 상태가 있다.(생성, 준비, 대기, 실행, 완료)
  - 프로세스 ID : 프로세스를 식별하는 숫자이며 CPU가 시분할 처리로 여러 프로세스를 처리할 때 기억하는 숫자이다.
  - 프로그램 카운터 : 다른 프로세스로 전환되었다가 다시 해당 프로세스가 실행될 때 어디서부터 실행시킬 것인지에 대한 명령어 주소를 저장한다.
  - 레지스터 정보 : 프로세스가 다시 실행될 때 전까지 가지고 있었던 레지스터 값들이 저장된다.
  - 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범 방지하는 경계 레지스터 값이 저장되어 있다.
  - CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행 시간, CPU 점유시간이 저장된다.

---

### 🌱 프로세스 상태(시분할 처리)

- 생성 : PCB를 생성, 메모리에 프로그램 적재 요청 / 완료되면 준비 단계로 넘어간다.
- 준비 : CPU를 사용하기 위해 준비 / CPU 스케줄러에 의해 CPU 할당 -> 할당 완료되면 실행 단계로 넘어간다.
- 실행 : CPU가 할당되어 프로세스가 실행된다. 여기서 실행을 마치면 완료단계, CPU스케줄링에 의해 CPU를 강제로 빼앗기면 준비상태, I/O 입출력 처리 요청을 발생시키면 대기 상태로 넘어간다.
- 대기 : I/O 입출력 요청을 받아 요청을 완료하면 준비상태로 넘어간다.
- 완료 : 프로세스가 종료된 상태

---

### 🌱 컨텍스트 스위칭

- 프로세스를 실행 중에 다른 프로세스를 실행하기 위해 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 동작
- 운영체제는 CPU가 할당받는 PCB를 교체하여 실행중인 프로세스를 변경한다.
- CPU의 점유 시간 초과, 입출력 발생, 다른 인터럽트 등에 의해 발생한다.

---

### 🌱 프로세스 생성과 종료

- 프로세스 생성 과정

  - 프로그램을 실행하면 운영체제는 프로그램을 메모리에 올리는데 프로그램의 코드 영역, 데이터 영역을 메모리에 로드하고, 빈 스태과 빈 힙을 만들어 공간을 확보한다.
  - 운영체제는 이후에 PCB를 만들어서 init한다.
    => 이 과정은 컴퓨터가 부팅된 이후 1번만 실행한다. 이후의 모든 프로세스들은 위의 과정을 거친 프로세스로부터 복제되어 생성된다. (복제가 더 빠르기 때문, fork()를 이용하여..)
    => 복제의 주체가 된 프로세스를 부모 프로세스, 복제된 프로세스를 자식 프로세스라고 한다.

- 부모와 자식 프로세스를 각각 pid를 할당받는데 자식은 0을 부모는 0이 아닌 값을 할당받는다.

```
  #include <stdio.h>
  #include <unistd.h>

  int main()
  {
    int pid; // 부모는 != 0, 자식은 = 0
    pid = fork();

    if(pid == 0) // 자식 프로세스
    {
      execlp("InternetBrowser", "0", NULL); // 부모 pcb를 복제하여 exec함수로 오버로딩하여 동작을 덮어씀

      exit(0); // exit을 하면 자식프로세스에서 부모프로세스로 동작이 넘어간다.
    }
    else
    {
      // 자식 프로세스에게 exit 함수가 호출될 때까지 기다리는 함수
      wait(NULL);
      printf("인터넷 브라우저 닫힘");
      exit(0);
    }
  }
```

- 부모 프로세스가 자식 프로세스보다 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 exit함수를 호출하지 못하여 메모리에 계속 데이터가 남아있는 프로세스를 좀비 프로세스라고 한다.

---

### 🌱 쓰레드

- 프로세스는 메모리를 많이 차지하는 것으로부터 고안된 것이 쓰레드이다.
- 쓰레드는 프로세스 내에 있는 CODE, DATA, HEAP영역을 공유하고 각각 한개씩 STACK영역을 가지고 있다.
- 쓰레드는 TCB(Thread control block을 통해 관리된다.)
- 프로세스는 각각 가지고 있는 데이터가 독립적이기 때문에 안정성 측면에서는 쓰레드보다 우수하다. 쓰레드는 하나의 프로세스가 이상이 생기면 공유하는 자원으로부터 다른 쓰레드에도 영향을 줄 수 있어 안정성이 떨어진다.
- 프로세스는 각 프로세스 간 데이터를 주고 받을 때마다 IPC라는 통신작업을 해야해서 속도와 자원이 크고 느리지만 쓰레드는 공유 자원과 하나의 프로세스 안에 형성되어 있어 속도와 자원이 작고 빠르다.

---

# 📌 CPU 스케줄링

### 🌱 CPU 스케줄링

- 프로세스들은 운영체제의 명령에 의해 CPU에게 작업을 요청한다.
- 어떤 프로세스에게 CPU 리소스를 할당해야하는지, CPU를 할당받은 프로세스가 얼마의 시간동안 CPU를 사용해야하는지 운영체제가 판단하는 작업을 CPU 스케줄링이라고 한다.

- 프로세스가 실행되고 있는 상태에서 CPU에 의해 강제로 준비상태로 되거나 I/O 요청이 발생해 대기 상태로 넘어간다. 이때 준비 상태와 대기상태는 다중큐라는 자료구조로 관리한다.
- 프로세스가 실행에서 준비로 갈 때 CPU는 프로세스의 우선순위에 따라 알맞는 준비큐에 PCB를 할당한다.

---

### 🌱 CPU 스케줄링의 목표

- 리소스 사용률 : CPU 사용률을 높이고 I/O 사용률을 높인다.
- 오버헤드 최소화 : 컨텍스트 스위칭 등 오버헤드를 일으킬 수 있는 요인을 최소화한다.
- 공평성 : 프로세스들에게 중요도 등 여러가지 요인에 따라 알맞게 CPU를 할당한다.
- 처리량 : 많은 처리량을 가질 수 있도록 한다.
- 대기 시간 : 짧은 대기 시간을 가질 수 있도록 한다.
- 응답 시간 : 짧은 응답 시간을 가질 수 있도록 한다.

### 🌱 CPU 스케줄링 자료구조

- CPU 성능은 프로세스들의 평균 대기 시간으로 평가한다.

- FIFO(First in First out) : I/O같은 작업이 있다면 오래걸린다.
- SJF(Shortest Job First) : 이론적으로 FIFO보다 빠르지만(작은 프로세스들을 큐의 제일 앞에 할당하여 실행시키는 방법)
- RR(Round Robin)
  - 프로세스마다 일정 시간(타임 슬라이스)동안 CPU를 할당한다.
  - 끝나지 않았으면 강제로 프로세스를 전환한다.(오버헤드 발생)
  - 컨텍스트 스위칭이 일어나 전환 자원이 크다.
- MLFQ(Multi level Feadback Queue)
  - 프로세스가 종료되는 시점을 파악하여 강제로 전환되는 CPU는 타임슬라이스를 조금씩 크게 준다.
  - CPU에서 정한 타임슬라이스보다 빨리 끝난 프로세스는 계속 그대로의 실행시간이 반영되어 실행된다.
    => 타임 슬라이스보다 빨리 완료되는 프로세스는 그대로 실행시키고 타임슬라이스보다 작동 시간이 커서 강제로 뺏기는 프로세스는 타임슬라이스를 조금씩 크게주어 컨텍스트 스위칭이 덜 나도록(오버헤드가 작아지도록) 한다.

---

# 📌 프로세스 동기화

### 🌱 프로세스 동기화

- 프로세스 간 자원을 공유하기 위해 통신을 하는 경우가 있다.

  - 하나의 파일을 통해 자원을 공유
  - 운영체제가 생성한 파이프를 통해 자원을 공유
  - 한 프로세스 내의 쓰레드 간의 자원을 공유(DATA / HEAP영역)
  - 타 컴퓨터의 프로세스와 통신을 하는 경우에는 네트워크(소켓, RPC)를 통해 자원을 공유

- 프로세스 간 공유되는 자원(파일, 변수 등)을 공유자원이라고 한다.

  - 각 프로세스들이 접근 순서에 따라 결과가 달라질 수 있다.
  - 컨텍스트 스위칭에 의한 시분할 처리로 인해 프로세스 실행 순서 예측이 어렵다.
  - 이에 발생되는 문제를 동기화 문제라고 한다.

- 여러 프로세스들이 공유하면 안되는 자원을 임계구역이라고 한다.

  - 임계 구역은 상호 배제 매커니즘이 필요하다.
  - 임계 영역에는 동시에 1개의 프로세스만 접근이 가능하다.
  - 여러가지의 요청이 있어도 하나의 프로세스만 진입을 허용한다.
  - 임계 구역에 들어가는 프로세스는 빠르게 나와야 한다.(임계 구역에 들어가면 임계 구역을 필요로 하는 다른 프로세스들이 기다리기 때문)

- 새마포어(상호 배제 매커니즘 중 한가지)

  - 하나의 공유 자원을 필요로 하는 프로세스들을 경쟁 조건이라고 한다.
  - 경쟁 조건에 만족하는 프로세스들은 대기큐에서 공유자원을 할당받기 위해 기다린다.
  - 공유 자원을 큐의 순서대로 할당받기 전 운영체제에 의해 세마포어라는 인증키를 받는다.
  - 세마포어를 가지고 있는 프로세스만이 공유 자원을 사용할 수 있는 방식이다.

  - wait과 signal함수를 사용한다.
  - wait 함수에 세마포어가 들어가면 세마포어를 받은 프로세스에서 다른 프로세스로 컨텍스트 스위칭이 일어나서 같은 공유자원을 사용하려해도 이미 세마포어가 컨텍스트 스위칭이 일어나기 전 프로세스에게 있기 때문에 코드를 실행하지 못하고 다시 넘어간다.
  - 세마포어가 있는 프로세스에게 CPU가 할당되면 남은 코드들을 싫행하고 signal함수를 호출하여 세마포어를 반납한다.
  - 반납된 세마포어로 다른 프로세스가 사용해 공유 자원을 사용한다.
    => wait과 signal함수를 잘 선언하지 않으면 코드가 꼬이는 경우가 발생한다.

- 모니터(세마포어의 단점들을 해결한 상호배제 매커니즘)
  - Java를 예로 들면 syncronized의 키워드가 붙을 시 키워드가 붙은 함수는 다른 곳에서 동시에 호출하는 것이 불가능하다.

---

# 📌 데드락

### 🌱 교착상태

- 다른 프로세스가 끝나기까지 기다리다 끝이 안나는 경우를 뜻한다.
- 교착상태가 일어나는 필요조건 4가지
  - 상호배제 : 어떤 프로세스가 한 자원을 점유했다면 다른 프로세스에게 공유가 되면 안된다.
  - 비선점 : 프로세스 간에서는 자원을 뺏지 못하고 기다린다.
  - 점유와 대기 : 한 자원을 가지고 있는 상태에서 다른 자원을 요청한다.
  - 원형 대기 : A -> B -> C -> A같은 원형구조로 요청을 하는 상황

---

### 🌱 데드락 해결

- 교착상태 회피 : 프로세스들에게 자원을 할당할 때 어느정도를 할당하면 교착상태가 발생하는지 먼저 파악한다.
- 교착상태가 발생하지 않을 정도로만 자원을 할당한다.
- 운영체제는 프로세스들에게 자원을 할당하기 전에 가지가 가지고 있는 전체 자원의 수를 파악한다. (시스템의 총 자원)
- 프로세스들은 각자 자기가 필요한 자원의 최대 숫자를 운영체제에게 알려줘야 한다.(최대 요구 자원)

- 가벼운 교착상태 검출 : 타이머를 사용하여 프로세스가 실행되지 않는 일정시간이 지난 이후 운영체제가 마지막 체크포인트로 롤백하는 방법
- 무거운 교착상태 검출 : 자원 할당 그래프를 이용하며 운영체제가 제어한다. 교착상태를 일으킨 프로세스를 강제 종료시키고 다시 실행할 때 체크포인트로 롤백한다.
