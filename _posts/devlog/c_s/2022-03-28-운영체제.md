---
layout: post
title: "운영체제"
subtitle: "운영체제 간략 정리"
categories: devlog
tags: computer_science 운영체제
---

> 운영체제를 공부하고 간략하게 정리한 글입니다.

<!---more--->

## 📌 운영체제

---

### 🌱 운영체제란?

- 컴퓨터 시스템의 자원들을 효율적으로 관리
- 사용자가 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
- Window, macOS, Android 등 다양한 운영체제 존재
- 운영체제가 없어도 동작은 하지만 처음에 설계한 그대로만 사용 가능(유연한 작업 X)

---

### 🌱 운영체제의 역할

- 프로세스 관리 : 다양한 프로그램을 동시 실행(시분할 처리)
- 메모리 관리 : 모든 응용 프로그램은 메모리 위에서 동작
- 하드웨어 관리 : 사용자가 하드웨어에 대한 직접적 접근 권한 차단 -> 메모리 중복 사용을 방지하여 각 프로세스들의 정보들이 얽히는 상황을 방지 / 해킹으로 인한 조작 방지
- 파일 시스템 관리

---

### 🌱 운영체제의 구조

#### <strong>커널</strong>

- 운영체제의 핵심 기능을 담당한다. -> 컴퓨터의 자원을 관리(사용자와 상호작용X)
- 시스템 프로그램이 사용자와 커널을 이어주는 역할
- 컴퓨터 물리적 자원, 추상화 자원을 관리 -> 여러 자원을 추상화하여 각 하드웨어의 물리적 자원과 대응함 (CPU : task / 디스크 : File / 메모리 : page, segment / network : socket)
- 커널의 기능
  - 디바이스 관리 : 디바이스 드라이버 소프트웨어 이용
- 프로세스 관리
  - 리눅스는 프로그램을 실행할 때 약 100여개의 프로세스가 동시에 실행
  - 각 프로세스의 PID를 통해 시분할 처리로 관리
- 메모리 관리
  - 프로그램 뿐 아니라 프로그램의 데이터 영역까지 메모리에 저장 -> 메모리 영역 분배 / 수거
  - 가상 메모리 지원

#### <strong>시스템 콜</strong>

- 어플리케이션이 커널에 접근하기 위한 도구
- 사용자로부터 커널을 보호하기 위한 인터페이스(저장공간을 안전하게 분배)

#### <strong>User Interface</strong>

- 사용자는 인터페이스만을 이용해서 커널에 접근
- GUI : 그래픽 유저 인터페이스
  - 그래픽 환경으로 시스템 제어
- CLI : 커멘드 라인 인터페이스
  - 명령어를 통해 시스템 제어

---

### 🌱 하드웨어의 구조

- 폰 노이만 구조
  - CPU <-> Bus <-> Memory
- CPU 구조
  - 제어 장치 : 모든 장치 동작 제어
  - 산술 논리 연산 장치 : 데이터 연산
  - 레지스터 : CPU내 계산을 위한 임시 보관 장소(ex. 변수)
- 메모리 구조
  - RAM : 메인 메모리
  - ROM : 컴퓨터 부팅 바이오스 저장

---

### 🌱 인터럽트

- CPU가 입출력 관리자를 통해 각 하드웨어 및 소프트웨어의 이벤트를 확인하여 처리하는 방식
- 과거에는 요청이 들어왔는지 CPU가 계속 확인하는 방식(Polling)
- 오늘 날 CPU가 명령 이후 다른 작업을 진행하다가 입출력 관리자로부터 해당 작업이 완료됨을 CPU에게 알리는 방식(인터럽트 / 비동기적으로 동작)

## 📌 프로세스 / 쓰레드

---

### 🌱 프로그램과 프로세스

- 프로그램 : 저장 장치에 저장된 명령문의 집합체(어플리케이션, \*.exe)
- 프로세스 : 실행 중인 프로그램
  - 하드 디스크에 저장된 프로그램이 메모리에 올라온 것이 실행 중인 프로그램 즉 프로세스라고 정의한다.
- 프로그램은 저장장치만 사용하지만 프로세스는 RAM, CPU등을 사용한다.

---

### 🌱 프로세스의 구조

- CODE 영역 : 실행하는 코드가 저장된다.
- DATA 영역 : 전역변수 / 정적변수가 저장된다.
- HEAP 영역 : 사용자가 동적으로 메모리를 할당 가능한 영역이다.
- STACK 영역 : 지역변수 / 함수 호출 시 매개변수 / 주소를 저장한다.

---

### 🌱 코드가 실행되는 과정 (ex. c언어)

- 컴파일 과정

1. test.c파일이 전처리기를 거쳐 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러온 뒤에 test.i 파일로 변경
2. test.i는 컴파일러를 거쳐 고수준 C언어를 저수준 어셈블리어로 변환하며 test.s인 파일로 변경
3. test.s는 어셈블러를 거쳐 기계어로 구성된 test.o파일로 변환한다.
4. test.s를 링커가 링킹을 한다. 링킹을 마치면 test.s는 test.exe파일로 변환된다.
   => exe 파일을 실행시키면 코드가 메모리에 올라가 프로세스가 된다. 프로세스가 되면 운영체제가 프로세스를 관리한다.

- CPU가 코드를 실행시키는 과정

1. CPU내의 제어장치가 코드의 값을 메모리에 저장시킨다.
2. 메모리에 저장된 값을 레지스터로 가져와 산술 논리 연산장치에 의해 처리된다.
3. 처리된 결과값을 레지스터에 저장하면 제어 장치가 레지스터에 저장된 값을 메모리에 저장시킨다.

---

### 🌱 멀티프로그래밍 / 멀티프로세싱

- 유니프로그래밍 : 메모리에 1개의 프로세스를 올려 파일을 실행시킬 수 있다.
  - 스와핑이라는 동작을 통해 저장장치와 메모리가 프로세스를 주고받으며 프로그램을 실행시킨다.
- 멀티프로그래밍 : 메모리 내에 여러 개의 프로세스를 올려 실행시킬 수 있다.
- 멀티프로세싱 : CPU가 여러개의 프로세스를 동시에 처리할 수 있다.(시분할 처리)

---

### 🌱 PCB(Process Control Block)

- 프로세스가 만들어지면 운영체제가 해당 프로세스의 정보를 가지고 있는 PCB를 생성한다.
- PCB들은 Linked-list 형태로 저장되어 있다.

- PCB의 구조
  - 포인터 : 부모와 자식 프로세스에 대한 포인터 / 할당된 자원에 대한 포인터 등이 있으며, 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.
  - 프로세스 상태 : 5가지의 프로세스 상태가 있다.(생성, 준비, 대기, 실행, 완료)
  - 프로세스 ID : 프로세스를 식별하는 숫자이며 CPU가 시분할 처리로 여러 프로세스를 처리할 때 기억하는 숫자이다.
  - 프로그램 카운터 : 다른 프로세스로 전환되었다가 다시 해당 프로세스가 실행될 때 어디서부터 실행시킬 것인지에 대한 명령어 주소를 저장한다.
  - 레지스터 정보 : 프로세스가 다시 실행될 때 전까지 가지고 있었던 레지스터 값들이 저장된다.
  - 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범 방지하는 경계 레지스터 값이 저장되어 있다.
  - CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행 시간, CPU 점유시간이 저장된다.

---

### 🌱 프로세스 상태(시분할 처리)

- 생성 : PCB를 생성, 메모리에 프로그램 적재 요청 / 완료되면 준비 단계로 넘어간다.
- 준비 : CPU를 사용하기 위해 준비 / CPU 스케줄러에 의해 CPU 할당 -> 할당 완료되면 실행 단계로 넘어간다.
- 실행 : CPU가 할당되어 프로세스가 실행된다. 여기서 실행을 마치면 완료단계, CPU스케줄링에 의해 CPU를 강제로 빼앗기면 준비상태, I/O 입출력 처리 요청을 발생시키면 대기 상태로 넘어간다.
- 대기 : I/O 입출력 요청을 받아 요청을 완료하면 준비상태로 넘어간다.
- 완료 : 프로세스가 종료된 상태
