---
layout: post
title: "Listen Socket과 Accept 이후의 Socket의 변화(feat. Spring)"
subtitle: "Spring MVC로 확인하는 Socket 변화"
categories: devlog
tags: computer_science Network Wireshark Socket
---

> 네트워크 원리 83p의 글 중 "서버는 클라이언트의 요청을 받기 위해 먼저 Socket을 열고 대기하고 있다." 의 문구를 보고
> 가지게 된 의문점

<!---more--->

## 📚뭐가 궁금했을까?
네트워크 원리의 책에 따르면 서버는 언제 발생할지 모르는 클라이언트의 요청을 받기 위해 Socket을 미리 열어놓고
대기한다고 한다. 그렇다면 그 전부터 봐왔던 소켓의 Lifecycle이 무언가 성립되지 않지 않을까? 생각이 들었다.
(소켓의 Lifecycle은 데이터를 요청할 때 생성되어서 전송이 완료되면 소멸하는 전형적인 패턴이라고 생각했다.)

위와 같은 상황에서 서버는 어떻게 처리하고 있었을지 나름 3가지 정도 추론을 해보았다.

1. Spring의 소켓은 하나고 다수의 클라이언트가 접근해도 하나의 소켓으로 처리하는 것인가? 그럼 각각 클라이언트마다
다른 패킷 데이터들은 하나의 소켓으로 들어왔을 때 패킷 내부의 데이터로 WAS에서 필터링하여 요청한 스레드의 비지니스 로직으로
 전달해주는 것인가?

2. 아니면 Spring의 RequestMapping마다 기본적으로 열려있는 소켓이 있는 것인가? 그렇다면 RequestMapping 수가 
많아질 수록 소켓을 저장할 메모리도 부족해지고, 같은 RequestMapping을 하는 클라이언트가 발생한다면 네트워크 
통신에 장애를 일으킬 수 있지 않을까?

3. 그러면 서버가 미리 소켓을 열어놓은 것은 클라이언트의 소켓을 생성한 후 파이프라인을 만들기 위한 요청을 받는 소켓이고, 
클라이언트의 소켓 연결 요청을 받게 되면 그 클라이언트와 앞으로 패킷을 주고받을 소켓이 새로 생성되어 이 소켓을 
통해 네트워크 통신을 하게 되는 것인가?

이러한 의문점을 가지고 구글링을 통해 답을 확인할 수 있었지만 스스로 확인해보는 것이 제일 좋은 방법이라고 생각되었다. 어떻게 
확인할 수 있을까? 고민하던 찰나에 얼마 전에 익혔던 Wireshark를 활용해보면 어떨까 생각되었다.

---

### 🌱 Wireshark 테스트
테스트 기기 : 아이폰, 아이패드 <br />
테스트 방법 : 맥북으로 서버 어플리케이션을 실행시킨 후, 노트북 IP번호를 통해 아이폰과 아이패드로 각각 동시에
Spring RequestMapping URL로 요청
결과 : 각각 기기마다 3 way handshake 진행, 당연한 결과이지만 source 넘버가 일치하지 않음
(아이패드 : 61150 port, 아이폰 : 57688 port)
<img src="https://wkblog-images.s3.ap-northeast-2.amazonaws.com/devlog/cs/2023-04-29-socket.png" />

테스트 결과를 보면 각각 아이패드는 61150 포트로, 아이폰은 57688 포트를 사용해서 서버 포트인 8080으로 접근한 이력을 확인할 수 있었다.
히지만 막상 테스트를 해보니 패킷 데이터는 해당 요청을 송신하거나 수신받는 어플이케이션의 포트정도로만 표시하고, 그 어플리케이션 안에서 어떤 소켓으로 
넘어가는지는 확인할 수 없었기 때문에 이 방법은 궁금했던 사항을 확인할 수 없는 테스팅 방법이었다.

-----
### 🌱 파일 디스크립터 생성을 통해 간접적으로 확인하기

### 🟤 1. 어플리케이션 직후 파일 디스크립터 확인하기
<img src="https://wkblog-images.s3.ap-northeast-2.amazonaws.com/devlog/cs/2023.04.29-socket-1.png" />

`lsof -i <pid>` CMD 명령어를 사용해서 지금 서버 어플리케이션이 가지고 있는 파일 디스크립터 리스트를 볼 수 있다. 소켓 또한 파일 디스크립터의 일종이기 때문에
이 명령어를 통해 소켓의 존재를 확인할 수 있었다. (여담으로 소켓또한 파일 디스크립터이기 때문에 운영체제의 설정값으로 가지고 있는 파일 개수 제한에 걸릴 수 있다. 즉,
무한정으로 소켓을 만들 수 없기 때문에 소켓이 많이 생성될 가능성이 있다면 튜닝을 해주어야 한다.)

현재 리스트를 확인해보면 TCP *:http-alt (LISTEN) 를 볼 수 있다. 이것이 클라이언트의 요청을 받기 위해 열려있는 소켓 파일 디스크립터로써 현재 아무런 요청을 보내지 않았음에도 
어플리케이션을 실행하면 처음부터 실행되는 파일이라고 판단할 수 있다.

### 🟤 2. 서버 어플리케이션이 요청된 이후 파일 디스크립터 리스트 확인하기
가지고 있는 장비들로 각 서버 어플리케이션이 실행되고 있는 IP 주소를 통해 요청해보았다.
<img src="https://wkblog-images.s3.ap-northeast-2.amazonaws.com/devlog/cs/2023-04-29-socket-3.png" />
위에서 확인할 수 있는 것은 56550 포트 번호를 가진 네트워크 장비가 서버 어플리케이션 8080포트로 요청한다는 것을 확인할 수 있다.
이 때 위와 다르게 다시 `lsof -i <pid>`로 서버 어플리케이션가 가진 파일 디스크립터를 확인해보면 이런 결과를 볼 수 있다.
<img src="https://wkblog-images.s3.ap-northeast-2.amazonaws.com/devlog/cs/2023-04-29-socket-2.png" />
맨 아래를 보면 무언가 파일 디스크립터가 추가된 것을 확인해볼 수 있다. 바로 방금 wirewhark로 보았던 56550 클라이언트 포트와 http-alt가 연결되어 있는 
소켓이 추가된 것을 확인할 수 있다.

현재 http의 헤더 중 keep-alive가 60초로 설정되어 있기 때문에 이 소켓은 60초동안 유지된다. 60초가 지난 이후 다시 파일 디스크립터 리스트를 확인해보면 방금 생성되었던 
소켓이 삭제되어 있는 것을 확인할 수 있다.

---

### 🌱 결론
얼추 추론했던 3가지 중 3번과 모니터링 툴을 사용해서 확인한 결과와 비슷한 것 같다. 즉, 서버 어플리케이션은 최초 클라이언트 요청을 받는 소켓과 이후 데이터를 송수신하기 위한 
소켓이 별개로 존재한다. 🤩

2개월동안 CS를 스터디하면서 느꼈던 것은 생각보다 기술블로그에 오류가 많다는 것을 느꼈다. 같은 것을 기리키더라도 부르는 용어가 달라 혼란스러운 상황도 빈번하게 발견했고, 아예 
사실과는 다른 글들도 간혹 발견되곤 하였다(나도 사실과 다른 글들을 작성한 적이 있는데..너무 낯부끄러워 바로 삭제했던 기억ㅇ..)

개발자로써 좋은 참고자료를 찾는 것도 능력이라 생각했다. 여전히 이 생각은 변하지 않았지만, 한가지 더 도전하고 싶은 것이 떠올랐다. 바로 
직접 확인해보는 것이다. 물론, 이 글에도 오류가 있을 수 있고 이 글뿐만 아니라 작성했던 다른 글에도 여전히 오류를 담고 있는 글들이 있을 수 있겠지만, 적어도 남들에게 "블로그에 그렇게 
나와 있던데요..?" 라는 변명은 하지 않을 것이다. 어떻게 결과를 도출했는지 확인할 수 있고, 그 과정에서 오류를 발견한다면 그것은 나에게 오류를 발견함과 함께 오류를 발견했던 과정도 다시 
생각해볼 수 있는 일석이조의 효과와, 무엇보다 기술을 구현함에 있어서 더 책임감있게 개발할 수 있을거라 생각한다.

앞으로 블로그는 경험 위주, 논리적 근거를 바탕으로한 나의 생각을 위주로 작성할 예정이다.(좋은 글은 이미 널려있기에..ㅎ) 앞으로의 개발 공부하는 시간이 더욱 기대된다.🌅