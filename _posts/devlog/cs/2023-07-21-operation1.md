---
layout: post
title: "[스스로 정리해보는 CS] #1 컴퓨터 구조 & CPU"
subtitle: "전반적으로 동작하는 컴퓨터 시스템을 머릿속으로 정리하기 위한 포스팅"
categories: devlog
tags: computer_science os 
---

> 컴퓨터가 동작하는 원리부터 시작해 OS, Network, Database 등이 어떻게 상호작용하며 동작하는지 스스로 정리하기 위한 시리즈입니다. 

<!--more-->

### 🟤 CS를 정리해보고자 하는 이유
지난 몇개월동안 CS 위주로 스터디했었다. 그 때까지는 책만 펴면 새로운 개념들이 등장했기 때문에 개념을 익히고 간단하게 어떤 역할을 하는지만 대략적으로 아는 상황이었다. 
주변 상황이 여의치 않아 빠르게 습득하고 넘어가고자 했지만 지금 시점에서 보니 정리되지 않은 개념들이 뒤죽박죽하게 얽혀있었다.

또한, OS나 network 등 여러가지 CS 개념들을 단편적으로 스터디하다보니 서로에게 줄 수 있는 영향력을 간과하는 것 같았다. 
OS에서 등장하는 프로세스의 I/O 요청에서 Network 통신, Database 등이 있고. 여기에서 어떤 처리를 하고난 이후 다시 인터럽트를 통해 CPU에게 전달하는 등 CS의 개념들을 연관짓고 싶었다.  
이에 더해 현재 내가 무엇을 모르고 있는지 객관적으로 파악할 수 있는 것이 블로그 작성이라는 생각이 들었다.

그래서 이번 기회에 CS의 큰 틀인 OS, Database, Network 순으로 그동안 스터디했던 것들을 정리해볼 예정이다.

---

## 🌱 내가 생각하고 있는 전반적인 컴퓨터 시스템의 흐름
보통 OS를 공부하면 OS가 어떻게 되어 있는지의 간단한 설명과 함께 그림자료를 보여준다. 이것에 더해 조금 더 큰 범위 내에서의 흐름을 생각해보고 싶었다.
<img src="https://i.ibb.co/rQVVKvR/cs-operation1.jpg" alt="cs-operation1" border="0">

간단한 그림이지만 하나의 PC에서 다른 PC에 통신하기 위해서의 Network, 데이터를 저장하기 위한 Database 등이 있다. 사실 NIC를 통해 데이터를 서버 등에 전달하기 위해서 OS의 처리가 필요하고, 
데이터베이스를 통해 disk에 데이터를 영구 저장하기 위해서도 Database의 프로세스를 통해 디스크에 영구 저장하는 과정이 필요하다.

이번 파트는 컴퓨터 내부 구조와 OS를 집중적으로 파헤쳐보고자 한다.

### 🟤 주제 1: 컴퓨터 시스템과 I/O 입출력 과정
컴퓨터 시스템은 내부구조와 외부구조로 나뉠 수 있다. 내부 구조는 CPU, 메모리 등이 내부 구조에 속하고, NIC(Network Interface Card), 디스크, 마우스, 키보드 등을 외부구조라고 한다. 
이 내부 구조에서 외부 구조로, 외부 구조에서 내부 구조로 데이터를 요청하고 응답하는 과정을 I/O 입출력 과정이라고 한다. I/O 입출력 과정에서 컴퓨터의 각 영역들은 각자 자신들이 가지고 있는 역할을 수행함으로써 최종 목표인 `프로그램을 실행하는 것`에 도달할 수 있다. 

#### 1. CPU
CPU는 `수동적인 역할을 수행하는 기계장치이다.` 이것이 무슨 의미인가 하면, CPU는 스스로 자신이 어떤 일을 수행해야하는지 알지 못한다. 단지 메모리에 올라와 있는 프로세스의 명령들을 처리하는 장치이다. 즉, CPU는 프로세스가 가지고 있는 
명령들을 연산 처리하여 프로세스의 목적을 이루는 장치인 것이다. 그리고 CPU가 프로세스의 명령을 처리하게끔 하는 역할을 OS가 담당하게 된다.

CPU 관점에서 I/O 입출력 과정을 생각해보자. CPU는 프로세스의 명령어들을 연산하고 있다. 이 때, 프로세스로부터 외부장치에 데이터 등을 요청하는 인터럽트(트랩)를 요청하게 되면 OS가 "CPU야 너 잠깐 프로세스 처리하던거 멈추고 내꺼 인터럽트 함수 처리해줘"라고 하면서 
CPU 레지스터(저장 장치)를 OS의 커널 함수가 실행될 수 있게끔 세팅이 된다.(기존에 처리하고 있던 프로세스의 정보는 커널의 데이터 영역에 있는 PCB에 저장한다.) 이 후 명령 중 외부 장치로부터 데이터를 수집하여 요청하기 위해서 CPU는 외부 장치에 접근한다. 하지만, CPU가 외부장치로부터 직접 연산과정을 거쳐 데이터를 모으는 것이 아니라 외부 장치에 있는 
`컨트롤러`라고 하는 작은 CPU에게 명령을 이양한다. 컨트롤러는 CPU의 명령을 받아 외부장치에서 데이터를 처리 및 연산하게 되는데 이 때 발생하는 데이터들을 저장하는 공간을 `로컬 버퍼`라고 한다.(로컬버퍼는 네트워크 때 중요하게 등장하는 개념이다.)

이 때 CPU는 컨트롤러에게 명령처리를 이양한 후 끝날 때까지 대기 상태에 있는 것이 아니라 CPU 스케줄러에 의해 준비 큐에 있는 다른 프로세스를 할당받아 처리하게 된다.(시분할 처리) 컨트롤러가 요청한 명령을 모두 수행하면 CPU에 있는 인터럽트 라인에 인터럽트를 세팅하게 된다. 
CPU는 자신이 수행하고 있는 명령 1개 단위로 명령을 완료하면 인터럽트 라인을 확인하게 되는데 이 때 발생된 인터럽트가 있다면 그 즉시 인터럽트를 처리하기 위해 인터럽트 백터(다양한 인터럽트 처리들을 모아놓은 자료구조)에서 해당 인터럽트 핸들러를 탐색하고 처리하게 된다. 

인터럽트를 처리하면서 수행하는 동작 중에는 처리된 데이터가 있는 로컬버퍼에서 데이터를 가지고 와 해당 요청을 수행한 프로세스에 저장하게 된다. 이와 같이 CPU는 외부장치와의 교류가 잦은데 CPU가 매번 외부장치로부터 인터럽트를 받아 이같은 과정을 반복하게 되면 CPU가 프로세스를 
처리하게 되는 효율이 떨어지게 된다.(프로세스의 대기시간이 증가하게 된다.) 그래서 DMA라는 컨트롤러 장치를 마련하여 외부장치 컨트롤러는 로컬버퍼의 데이터를 DMA에 적재하게 되고 일정 범위(Block 단위)가 되거나 조건에 만족하게 되면 DMA가 CPU에게 인터럽트를 세팅하여 
한번에 많은 양의 외부장치로부터의 데이터를 처리하게끔 한다.

인터럽트를 처리한 CPU는 다시 CPU 스케줄러에 의해 처리할 프로세스를 받아 처리하게 되는데, 지금까지의 과정이 CPU가 컴퓨터 시스템에서 수행하는 역할들을 간략하게 정리한 것이다.

이 과정을 통해 간단하게 CPU 사용량 메트릭을 보고 원인을 분석해보자.

<img src="https://i.ibb.co/zrQC7nB/Screenshot-2023-07-21-at-2-45-37-PM.png">

이건 Spring으로 API를 호출할 때마다 while로 무한 루프를 돌게 한 프로세스의 CPU 사용량이다. 해당 메소드가 호출되면 값을 끝내지 못하고 계속 무한으로 처리하기 때문에 해당 메소드를 처리하는 메소드가 늘어갈 때마다 가파르게 CPU를 사용하고 있다는 것을 보여준다. 
즉, 외부 장치나 다른 연산없이 CPU을 사용하는 연산 위주로 수행하게 된다면 CPU의 사용량이 증가하게 된다.

서버 어플리케이션의 효율을 높이기 위해서는 이 경계를 잘 다스려야 할 것이다. 너무 CPU 사용량이 낮다면 그만큼 CPU를 사용하지 못하고 CPU가 놀고 있는 수준에 그쳐 CPU 자원이 아까울 수 있다. 그래서 최대한 서버 어플리케이션이 CPU가 받아드릴 수 있는 수준에서 사용할 수 있도록 
하는 것이 중요할 것이다. (서버 어플리케이션 입장에서 CPU 사용량이 늘게되면 그만큼 처리해야하는 I/O 요청이 많아질 수 있기 때문에 대용량 트래픽에서는 분산환경을 잘 고려해야 한다.)
한편, 별 기능이 없는데도 CPU의 사용량이 많다면 어디선가 병목 현상이 일어나고 있는지 의심해보아야 한다. 그러나 이 그래프만으로는 어디에서 병목이 일어났는지 확인할 수 없고 그에 대한 근거도 부족하기 때문에 여러 모니터링 도구를 활용하는 것이 필요하다.


#### 2. CPU의 입장에서의 보안
CPU는 OS로부터 프로세스의 명령어들을 처리하는 수동적인 존재이다. 그런데 만약 프로세스의 명령어를 처리하다 프로세스에게 할당되지 않은 다른 중요한 메모리에 접근을 시도하는 경우에는 어떻게 될까? 이러한 공격 등으로부터 보안을 유지시키기 위해 CPU에 장치를 마련한다. 
모드비트(mode bit)이라는 것이다. 이 모드 비트의 값에 따라 특권 명령, 일반 명령으로 나누어 CPU가 명령을 수행하게 된다. 모드 비트는 0과 1로 나눌 수 있는데, 모드 비트가 0이라면 특권 명령으로 자신이 처리하는 모든 명령을 특권 명령으로 규정한다. 
특권 명령은 모든 장치로부터 접근을 허용하는 모드인데 일반적으로 OS가 프로세스로부터 시스템 콜 요청을 받아 처리하는 과정에서 모드비트가 0으로 세팅된다.<br />
반대로 모드비트가 1일 경우에는 자신이 처리하는 명령을 일반 명령으로 규정하고 아주 제한된 명령들만 수행한다. 즉, 일반 명령은 현재 실행하고 있는 프로세스 자신의 명령들만 수행하도록 하는 명령이다. 이것을 통해 CPU는 언제 시스템 리소스에 접근 가능한지를 구별해낼 수 있다.

CPU는 프로세스를 실행시키면서 언제 다른 프로세스를 실행해야할지 스스로 알지 못한다.(시분할 처리 시스템) 하드웨어 인터럽트, 소프트웨어 인터럽트 이외에 한 프로세스가 CPU를 계속 점유하고 있는 상황을 방지하기 위해 타이머라는 장치를 두었다. 
타이머는 프로세스가 CPU를 정유하여 실행할 수 있는 아주 짧은 시간을 관리한다. 프로세스가 실행된 이후 타이머가 관리하는 시간만큼 시간이 지난다면 타이머는 CPU에게 인터럽트를 보내게 되고 CPU는 강제적으로 자신이 처리하고 있는 프로세스에서 다른 프로세스를 교체받아 
처리하게 된다.

---

## 🌱 정리
이번 글은 CPU의 위주로 CPU가 컴퓨터에서 어떤 역할을 하는지 복습해보았다. CPU를 설명하면서 현업에서 사용할 수 있는 정보가 무엇이 있을까 고민해보았는데 이런 매트릭을 분석하는 것도 CS를 스터디하는 것이라 느끼게 되었다. 
다음 글은 메모리와 프로세스에 대해서 복습해보려고 한다.

---
<br />
<br />
<br />

#### ❗️ 깨알 상식

#### 1. 인터럽트
인터럽트는 다양한 환경에서 접해볼 수 있는 개념이다. 컴퓨터 시스템 레벨에서 사용되는 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 외부장치 컨트롤러로부터 CPU에게 이양된 명령을 모두 수행하고 다시 CPU에게 
처리한 값을 응답해야할 때 보내는 신호이다. 소프트웨어 인터럽트(트랩)은 예외 상황과 시스템 콜로 나눌 수 있는데, 예외 상황은 프로세스가 비정상적인 행동을 취할 때(허용되지 않은 메모리에 접근하거나, 프로세스의 메모리가 가득차게 되는 등) 인터럽트를 
발생시켜서 OS가 적절한 조치를 취할 수 있도록 한다. 시스템 콜은 사용자 프로세스는 제한된 일반 명령만을 수행할 수 있기 때문에 시스템 리소스에 접근하기 위해서는 OS의 도움이 필요하다. 이 때, OS에 요청할 수 있는 인터럽트가 시스템 콜이다.

#### 2. 동기식 입출력, 비동기식 입출력
사용자 프로세스는 I/O 요청을 위해 인터럽트를 발생시킬 수 있다. 이 때, 동기식 입출력 방식으로 동작하는 요청일 경우에는 프로세스가 해당 요청을 OS의 시스템 콜 인터럽트로 보낸 이후 Blocked 상태가 되어 응답을 받기 까지 일시적으로 실행이 중단된다. 반면에, 
비동기식 입출력은 프로세스가 인터럽트를 발생시키면 Blocked 상태가 되는 것이 아니라 바로 준비 큐에 할당되어 CPU 스켈줄러에 의해 CPU를 할당받기 기다리거나 바로 CPU를 점유하여 실행할 수 있는 방식이다.

글로만 보면 그럼 비동기가 좋은 것 아닌가요? 할 수 있지만 각 방식마다 사용하는 목적이 달라서 둘 다 꼭 필요한 방식들이다. (이부분은 추후에 Blocked & Non-Block / Synchronous & Asynchronous를 다룰 때 설명하는 것이 좋을 것 같다.) 
