---
layout: post
title: "[스스로 정리해보는 CS] #2 프로세스"
subtitle: "전반적으로 동작하는 컴퓨터 시스템을 머릿속으로 정리하기 위한 포스팅"
categories: devlog
tags: computer_science os process
---

> 컴퓨터가 동작하는 원리부터 시작해 OS, Network, Database 등이 어떻게 상호작용하며 동작하는지 스스로 정리하기 위한 시리즈입니다.

<!--more-->

## 🌱 프로세스란?
프로그램은 컴퓨터 상에서 어떤 목적을 이루고자 하는 명령어들의 집합이다. 그렇다면 프로세스는 무엇일까?

> 프로그램이 실행되고 있는 것을 프로세스라고 한다.

조금 더 자세히 설명하자면 프로그램을 사용하기 위해서는 프로그램의 명령어들이 메인 메모리 적재되어 실행되어야한다. 이 때 메모리에 올라온 프로그램을 프로세스라고 한다.  

### 🟤 프로세스와 CPU의 연관 관계
[앞의 포스팅](https://syeon2.github.io/devlog/operation1.html)에서 CPU의 동작 방식에 대해서 설명했지만 간략하게 프로세스 관점해서 이해해보려고 한다. 프로세스는 
크게 커널의 프로세스, 사용자 프로세스로 나뉠 수 있다. 커널의 프로세스는 운영체제가 상시 실행되어야 하는 것들의 집합체이며, 사용자 프로세스는 커널 이외에 실행되는 모든 프로세스를 의미한다.

프로세스가 실행되기 위해서는 CPU의 도움이 필요하다. 프로세스는 자신이 가지고 있는 코드를 CPU를 통해서 실행시키게 되는데 이 때 여러가지 방면으로 분석해볼 수 있다.

#### - 프로세스의 컨텍스트 스위칭
현대에 사용되는 PC는 일반적으로 시분할 처리가 가능하다. 이는 여러 프로세스를 동시적으로 실행할 수 있다는 의미이다. 싱글 코어 관점에서 시분할 처리를 하기 위해서는 한번에 처리할 수 있는 프로세스는 
1개밖에 없기 때문에 짧은 텀을 두어 각 프로세스들이 번갈아가며 실행되어야 한다. 이 과정을 컨텍스트 스위칭이라고 한다.

컨텍스트 스위칭은 여러 이유로 발생하곤 한다. 그 중 하나는 타이머 인터럽트를 통해 강제적으로 프로세스의 실행이 다른 프로세스의 실행으로 전환되는 것이다. 타이머라는 장치를 통해 프로세스가 CPU를 점유해서 
자신의 명령어를 실행하게 되면 그 순간부터 지정된 시간동안 동작하도록 한다. 지정된 시간을 모두 소모하면 타이머는 인터럽트를 세팅하여 현재 실행하고 있는 프로세스를 전환한다.

다른 이유도 있다. 프로세스는 I/O 요청(시스템 콜 인터럽트)을 하여 디스크, NIC 같은 외부 장치에 간접적으로(운영체제의 도움) 접근할 수 있다. 이 프로세스가 동기식 입출력 방식을 사용한다면 프로세스는 
I/O 요청이 완료될 때까지 Blocked 상태가 된다. CPU는 Blocked된 프로세스를 처리할 수 없으니 이 때 다른 프로세스를 처리하는 것이 CPU 이용률에서 이득이기 때문에 기존에 실행되던 프로세스에서 새로운 
프로세스로 컨텍스트 스위칭된다.

이렇듯 프로세스의 컨텍스트 스위칭은 CPU의 이용률을 늘리고자 하는 목적과 멀티 테스킹의 목적을 가지고 있다.

> ❗️ 프로세스와 스레드의 컨텍스트 스위칭 <br />
> 
> 프로세스와 스레드는 각각 CPU를 점유하여 실행되어야하는 관점에서 서로 비슷한 실행 방식을 가지고 있다. 그저 프로세스는 프로그램 단위에서의 변경이고 스레드는 프로세스 내에서 발생하는 기능의 단위로 컨텍스트 
> 스위칭을 하게 된다. 하지만 둘 다 컨텍스트 스위칭을 한다고 해서 그 비용마저 같은 것은 아니다.
> 
> 프로세스가 컨텍스트 스위칭을 하기 위해서는 CPU가 참조하고 있던 프로세스의 가상 메모리 정보를 초기화하여야 한다.(그래야 다른 프로세스의 메모리 정보로 업데이트하여 실행해야하기 때문이다.) 그래서 메모리 영역인 
> MMU와 TLB (메모리를 다룰 때 언급할 예정이다.)를 초기화 해주어야하는 오버헤드가 있다. 반면 스레드는 하나의 프로세스에서 데이터를 공유하기 때문에 메모리 정보를 초기화할 필요가 없다. 따라서 프로세스의 컨텍스트 스위칭이 
> 조금 더 비용이 많이 발생하게 된다. (물론 스레드는 Race condition, Deadlock 같은 문제들이 발생할 수 있다.)

----

### 🟤 프로세스의 구조
프로세스는 코드, 데이터(+ 힙), 스택으로 구분할 수 있다. 코드는 프로세스가 실행을 위해 가지고 있는 코드를 저장하고 있는 공간이다. 데이터는 프로세스가 실행될 때 필요한 전역 변수 등을 저장하는 공간이며
(힙 영역은 프로세스가 동적으로 할당되는 메모리(로컬 변수, 실행되는 메소드 정보)를 저장하는 공간이다.), 스택은 메소드가 실행되면서 내부적으로 실행되는 다른 메소드가 있다면 현재 메소드를 스택 자료구조에 
저장한 이후 다른 메소드가 종료되면 다시 원래의 메소드가 이어서 실행될 수 있도록 주소를 보관하고 있는 공간이다.

프로세스는 이러한 구조들을 메모리에 저장할 때 프로그램 내에 있는 모든 데이터들을 메모리에 적재하지 않는다.

프로그램의 모든 데이터를 한꺼번에 메인 메모리에 올리게 되면 함께 실행할 수 있는 다른 프로세스가 할당될 수 있는 메모리의 영역은 줄어들게 된다.
게다가 주어진 메인 메모리 용량보다 프로그램의 메모리 크기가 더 크다면 애초에 실행할 수도 없는 상황이 발생할 수도 있을 것 같다.

이러한 상황을 해결하기 위해 프로세스는 사용되는 일정 부분만을 메인 메모리에 올리고 나머지는 디스크 영역에 보관하여 필요할 때마다 스왑인/스왑아웃 처리하여 프로세스르 동작시킨다. 
여기서 또 발생할 수 있는 이슈가 있는데, 프로세스가 많이 실행되고 있는 상황이라면 실행되는 프로세스를 메모리에 올려야하기 때문에 하나당 부여되는 메모리 공간이 작아지게 된다. 
메인 메모리에 올라갈 수 있는 공간이 작아지게 되면 프로세스가 디스크에 있는 데이터를 불러와야하는 횟수가 잦아지는데 이는 모두 디스크 I/O이다. I/O의 특징은 CPU의 연산 속도보다 훨씬 느리기 때문에 
CPU가 프로세스를 처리하다 디스크 I/O가 발생하고, 그렇게 되면 CPU는 다른 프로세스를 처리하기 위해 컨텍스트 스위칭을 하게 되고.. 그 프로세스 또한 동일하기 때문에 또 디스크에 있는 I/O.... 무한 루프..
결국 CPU 이용률이 매우 떨어지고 I/O 요청으로 발생하는 비용, 컨텍스트 스위칭 비용 등 매우 비효율적인 처리를 야기한다.

> ❗️ 서버 어플리케이션에서 무리하게 스레드를 생성하지 않아야하는 이유도 비슷하다. 하나의 제한된 메모리 영역을 사용해야하는 서버 메모리 안에서 
> 무차별적으로 스레드를 생성하여 처리를 요청하게 되면 스레드들끼리 CPU를 차지하기 위한 경합이 발생하게 되고 이는 불필요한 오버헤드를 유발하게 된다. 
> 또한 스레드를 생성한다는 것은 하나의 메모리 영역을 스레드에게 할당한다는 의미이기도 해서 매우 많은 스레드가 발생할 경우 OOME(OutofMemoryException)가 발생할 수도 있다.
> 이에 대한 문제 해결 방안으로 Thread Pool을 사용하여 서버에서 생성할 수 있는 스레드의 개수를 제한하는 것이다. (즉, 프로세스든 스레드든 많이 생성하는 것만이 능사가 아니다.😅) 

------

### 🟤 프로세스 상태
컨텍스트 스위칭이 발생하는 과정을 살펴보면 프로세스 상태와 PCB 등의 개념을 당연하게 접하게 된다. 프로세스 상태는 말그대로 현재 프로세스가 어떤 상태에 있는지를 나타낸다.
<img src="https://i.ibb.co/jkhgRyh/3-C0-EE55-A-F817-411-C-9-AB2-88-AC7-F8-BDD81.jpg" />

전반적으로 프로세스가 가질 수 있는 상태가 존재한다. (각 언어에 따라서 프로세스가 가질 수 있는 상태가 조금씩 다를 수 있다.)

프로세스가 최초 실행되면 New 단계를 거치게 되는데, New 상태의 프로세는 프로세스가 실행되기 위해 데이터를 메모리에 적재하는 단계하는 등의 준비를 한다.<br />
New 상태를 거쳐 프로세스는 Ready 상태로 가 CPU 스케줄러(단기 스케줄러)로부터 CPU를 할당받기까지 기다리게 된다. CPU 스케줄러에 의해 CPU를 점유하게 된 프로세스는 Running 상태가 되어 
자신의 명령어들을 실행한다. 이 때 타이머로부터 인터럽트가 발생하게 되면 다시 Ready로 되돌아가게 되고, Blocked I/O 요청을 하게 되면 Blocked 상태가 된다.

Blocked 상태의 프로세스는 I/O 요청 등 Blocked 상태를 유발한 원인에 대한 결과가 발생할 때까지 대기하게 되는데 이 경우에도 여러가지 상황으로 전개될 수 있다. 
Blocked 상태로 대기하다가 메인 메모리의 공간이 부족하게 되면 현재 실행하지 않는 Blocked 상태의 프로세스는 중기 스케줄러에 의해 디스크의 스왑영역에 적재하게 된다.(중지 봉쇄 - 메인 메모리의 공간을 확보하기 위해) 

디스크 영역에 스왑아웃된 프로세스는 중간에 I/O 요청이 완료되게 되면 중지 봉쇄 단계에서 중지 준비 단계로 변경된다. 중지 준비는 중지 봉쇄ㄲ 단계에서뿐만 아니라 Ready에서 CPU 스케줄러를 기다리고 있던 
프로세스도 중지 준비 단계로 변경될 수 있는데, 이 때의 실행 우선순위가 가장 낮은 프로세스 등의 기준을 가지고 디스크로 스왑 아웃하게 된다.

프로세스는 이와 같은 과정 통해 실행되기도, 대기하기도, 저장 영역이 옮겨지기도 한다.

-------

### 🟤 PCB(Process Control Block)
준비 단계와 실행 단계의 사이에는 언터럽트에 의한 컨텍스트 스위칭이 발생한다. 컨텍스트 스위칭은 CPU가 커널에 있는 인터럽트 핸들링(시스템 콜)을 통해서 발생하게 되는데 프로세스는 자신이 실행하고 있던 상태를, 즉 프로세스를 실행하고 있던 
CPU의 레지스터 내역을 어딘가에 저장해야할 필요가 생긴다. 그래야 추후 다시 해당 프로세스가 실행될 때 전의 실행 내역 이후부터 실행할 수 있기 때문이다. 그래서 인터럽트를 통해 컨텍스트 스위칭이 발생할 때 CPU 레지스터에 있던 
프로세스의 실행 정보를 커널 메모리 영역의 PCB 자료구조 형태로 저장한다.

PCB 자료구조는 다음과 같이 구성되어 있다.
- 프로세스 번호 : 프로세스 식별자
- 프로세스 상태
- CPU 레지스터
  - 프로그램 카운터 : 다음에 실행할 명령어의 주소를 저장.
  - 스택 포인터 : 메소드 호출 및 반환시 돌아올 주소 정보를 저장
- CPU 스케줄링 정보
- 메모리 관리, 자원 사용, 입출력 상태 정보

------

## 🌱 CPU 스케줄러
CPU 스케줄러(단기 스케줄러)는 여러 요인(타이머 인터럽트, 디스크 I/O, 네트워크 I/O 등)으로 프로세스가 Blocked 상태가 되었을 경우, CPU의 이용률을 높이기 위해 Ready 상태에 있는 다른 프로세스 중 
하나를 선택하는 장치이다. CPU 스케줄러에는 프로세스를 선택하기 위한 여러가지 알고리즘이 있으며 요즘에는 RR(Round Robin)이 가장 상용적으로 쓰이는 알고리즘 중 하나이다.

스케줄링의 성능을 평가하기 위해서는 몇가지 기준이 필요하다.
- CPU 이용률 : 전체 시간 중에서 CPU가 일을 한 시간의 비율
- CPU 처리량 : 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 끝마친 개수
- 소요시간 : 준비 큐에서 기다린 시간 + 실제로 CPU를 사용한 시간
- 대기시간 : CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
- 응답시간 : 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간

위의 기준들을 가지고 각 CPU 스케줄링 알고리즘을 살펴보고자 한다.

### 🟤 선입선출(FCFS) 스케줄링
Queue의 FIFO 처럼 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식이다. 경우에 따라 평균 대기 시간이 늘어날 수 있다.(콘보이 현상)

### 🟤 최단작업 우선 스케줄링
스케줄링 시점에 처리하는 시간이 제일 짧은 프로세스를 우선적으로 처리하는 방식이다. 최단 작업 우선 스케줄링은 선점형 방식, 비선점형 방식으로 나눌 수 있다. 선점형 방식은 
프로세스를 처리하다 처리해야하는 시간보다 더 짧은 처리 시간을 가진 프로세스가 등장하게 되면 스케줄링을 통해 강제적으로 처리하는 프로세스를 변경하는 방식이다. 반면에 비선점형은 
현재 처리하고 있는 프로세스를 처리하고 나서 다음에 처리할 프로세스를 탐색할 때 제일 짧은 처리 시간을 가진 프로세스를 처리하는 방식을 의미한다.

최단작업 우선 스케줄링은 처리시간이 빠른 프로세스를 먼저 처리하기 때문에 평균 대기 시간은 짧지만 지속적으로 짧은 처리 시간을 가진 프로세스가 유입된다면 뒤의 처리 시간이 긴 프로세스는 
CPU를 할당받지 못하는 기아 현상이 발생할 수 있다.

### 🟤 우선 순위 스케줄링
준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다. 이 때에도 우선순위가 낮은 프로세스는 처리하지 못하는 단점이 있지만, 노화 기법을 
사용하여 우선순위가 낮은 프로세스에게 조금씩 순위를 높여가서 결국 처리하게 하는 방식을 함께 적용하기도 한다.

### 🟤 라운드 로빈 스케줄링
라운드로빈은 프로세스가 CPU를 점유하는 시간을 제한하는 방식이다. 마치 타이머를 통해 인터럽트를 발생시켜 프로세스가 CPU를 독점하지 못하게 하는 방식과 유사하다고 할 수 있다.

----
