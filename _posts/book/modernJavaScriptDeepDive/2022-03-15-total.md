---
layout: post
title: "Modern JavaScript Deep Dive"
subtitle: "Javascript 서적 정독 스터디"
categories: book
tags: javascript
---

> Modern JavaScript를 정독하면서..

<!---more--->

---

# 🌱 Variable (변수)

---

### 📌 변수란?

- JavaScript는 필요한 연산을 하기 위해 저장해야하는 값들을 메모리에 저장할 때 개발자가 직접 메모리에 접근하지 못하므로 `변수` 를 이용해 메모리에 접근하여 값들을 저장할 수 있다. → 즉 변수는 메모리에 접근할 수 있는 ‘값’이다.

### 📌 변수의 특징

- 호이스팅 : JavaScript는 변수를 Runtime에 실행하여 저장하지 않고 Runtime이 일어나기 직전에 선언되어 있는 변수의 식별자를 수집하여 실행 컨텍스트에 저장한다.(할당은 Runtime 순으로..)
- 식별자가 수집되어 저장될 때 undefined를 변수의 값으로 할당되어 저장된다. 이 과정을 `초기화`라고 한다.

22/03/08

# 🌱 Expression / Statement(표현식과 문)

---

### 📌 표현식 용어 정리

- 값 : 표현식이 평가되어 생성된 결과
  - 모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 같은 2진수로 저장되었다 하더라도 어떤 데이터 타입을 저장했는지에 따라 다른 값을 가진다.
- 리터럴 : 사람이 이해할 수 있는 문자 또는 기호를 사용 → 값을 생성하는 표기법
- 표현식 : `값`으로 평가될 수 있는 문
  - ex) 변수 선언문 `var a`는 값을 평가할 수 없기 때문에 표현식 X
  - ex) `x = 1 + 2`는 식 자체로 값을 평가할 수 있기 때문에 표현식 O
- 문 : 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위
  - 문은 조건문, 반복문, 할당문, 선언문 등으로 구분 가능
  - 문이라고 해서 모두 표현식은 아니다. (선언문)
- 토큰 : 문법적으로 더 이상 나눌 수 없는 기본 요소

22/03/09

# 🌱 Data Type (데이터 타입)

---

### 📌 데이터 타입의 종류

- 원시 타입
  - 숫자(number), 문자열(string), 불리언(boolean), undefined, null, Symbol
- 객체 타입
  - 객체(Object), 배열(array), 함수(function)

### 📌 숫자(Number)

- 정적 타입 언어와 다르게 JavaScript(동적 타입 언어)는 하나의 숫자 타입(실수)을 가진다.

### 📌 문자열(String)

- 문자열을 객체로 표현하는 Java와 다르게 JavaScript에서 문자열은 원시타입이다.
- 일반 문자열에서 개행 허용X → escape sequence 사용
  - window는 /r/n, macOS는 /n을 개행 방식으로 사용한다. (/r/n은 과거 타자기의 개행 방식)
- 템플릿 리터럴을 사용하면 개행, 표현식을 쉽게 사용 가능하다.

### 📌 불리언(Boolean)

- 참, 거짓 분별 - 논리적인 값

### 📌 undefined

- 변수가 선언되어 초기화될 때 제일 먼저 할당되는 값
- 아무 것도 할당되지 않은, `정의되지 않은`의 의미
- 초기화 시 할당되는 값인 만큼 개발자가 의도적으로 undefined를 할당하는 것은 권장하지 않는다. (undefined 값을 통해 변수에 값 할당 유무를 파악하기 용이)

### 📌 null

- undefined는 `정의되지 않은`의 의미를 갖지만, null은 의도적으로 `비어있다`라는 의미를 가지는 값으로 사용

### 📌 ETC(Symbol, Object, Array 등)

### 📌 데이터 타입이 필요한 이유

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간 크기 결정
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정

### 📌 동적 타이핑

- 정적 타입 언어는 변수에도 타입을 선언해야 한다.
- 동적 타입 언어는 변수에 할당된 값에 따라 타입이 동적으로 변할 수 있다.
  - 복잡한 프로그래밍에서는 개발자의 의도와 다르게 JavaScript엔진이 암묵적으로 타입을 변환할 가능성이 있다.

> 정적 타입 언어 = 안정성 ⬆️  / 코드의 양 ⬆️
> 동적 타입 언어 = 안정성 ⬇️  / 코드의 양 ⬇️

⇒ 가독성 좋은 코드가 👍🏻

>

22/03/10

# 🌱 연산자

---

### 📌 오늘의 포인트

- 그 자체를 값으로 표현할 수 있으면 표현식! 값이 아니면 문!
- 삼항 연산자는 조건’문'이자 표현’식'이다.
- NaN === NaN은 false이다.
- typeof null은 Object이다.(JavaScript의 버그)
- ES7에서 등장한 지수 연산자 `ex) 2 ** 2 === 4`

22/03/11

# 🌱 제어문

---

### 📌 오늘의 포인트

- break와 continue를 활용하면 가독성있는 프로그래밍이 될 수 있을 것 같다.
- forEach, map, filter 등 특정 반복 메소드를 사용하는 것이 단순 for문을 사용하는 것보다 가독성 측면에서 좋다.

22/03/12

# 🌱 타입 변환과 단축 평가

---

### 📌 오늘의 포인트

- 개발자가 의도적으로 타입을 변환하는 것 : 명시적 타입 변환, 타입 캐스팅
  - ex) toString()
- JavaScript 엔진이 암묵적으로 타입을 변환하는 것 : 암묵적 타입 변환, 타입 강제 변환
  - ex) ‘10’ + 2 = ‘102’
- 모든 타입 변환은 기존의 원시 값을 갱신하여 재할당하는 것이 아닌 새로운 값을 생성한다.
- `+`는 문자열 연결 연산자, `-, *, /`는 산술 연산자

22/03/13

# 🌱 객체 리터럴

---

### 📌 오늘의 포인트

- C, Java와 같은 Class 기반 객체 지향언어는 Class를 사전에 정의하고 필요한 시점에 new연산자와 constructor 생성자를 호출하여 인스턴스를 생성
- 그러나 JavaScript는 프로토타입 기반 객체지향 언어이기 때문에 다양한 방법을 통해 객체를 생성한다.
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수(new)
  - Object.create 메서드
  - 클래스
- 프로퍼티 키의 타입은 무조건 문자열
- 프로퍼티 값이 함수일 경우 메서드라고 부른다

22/03/14

# 🌱 원시 값과 객체의 비교

---

### 📌 오늘의 포인트

- 원시 타입 값은 변동이 생겼을 시 원래 있던 메모리 주소에 갱신되는 것이 아니라 새로운 메모리 주소에 생성되고 그 주소를 변수가 기억한다.
- 유사 배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length값을 가질 수 있는 객체를 의미한다.
  - ex) String은 문자 하나마다 index로 접근 가능하고, length로 글자 수까지 알아낼 수 있으니 유사 배열 객체이다.
  - 하지만 JavaScript에서 String은 원시 값이기 때문에 index로 접근하여 값을 재할당하더라도 변하지 않는다.
- 원시 값들은 `두가지의 값을 평가하는 방식`이 존재한다.
  1. a의 값을 b에 할당한다. `ex) let b = a` 첫번째의 경우 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다. (할당 시점에 a의 메모리 주소에 있던 값이 b의 메모리 주소에 할당되는 의미)
  2. a의 값을 b에 할당한다. `ex) let b = a` 두번째의 경우 할당 시점에 두 변수가 기억하는 메모리 주소가 같다. (할당 시점에 b는 a의 값이 할당되어 있는 메모리 주소를 할당받는다.)

⇒ `값의 의한 전달`도 `값을 참조`하는 것이 아니라 값을 가지고 있는 메모리 주소를 할당받는다.

- 참조 타입 값은 값이 변한다.(mutable)
  - ex) let a = { name: ‘suyeon’ }; let b = a 상황에서 a의 name을 바꾸면 b도 동일하게 바뀐다.
- 한 변수가 참조 타입 값을 할당받았을 때 변수는 참조 타입 값안에 있는 프로퍼티들의 값 주소들을 모아놓은 주소를 할당받는다.
- 형태가 같더라도 따로 할당한 참조 타입 값은 일치 연산자로 비교하면 false를 출력한다. `ex) let a = { name: ‘suyeon }; let b = { name: ‘suyeon’ }; a === b ⇒ false`

⇒ 변수에 할당되는 값은 실제로는 값이 아닌 값을 가지고 있는 메모리 주소가 할당된다고 생각하면 이해하기 수월해지는 것 같다 🙂

22/03/15

# 🌱 함수

---

### 📌 오늘의 포인트

- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 객체 타입의 값이다. 함수 리터럴도 평가되어 값을 생성한다.
- 하지만 일반 객체는 호출할 수 없지만, 함수는 호출할 수 있다.
- 함수 선언문은 함수가 평가됨과 동시에 Javascript에서 암묵적으로 함수 이름을 식별자로 생성하고 함수 객체가 할당된다. ⇒ 함수는 선언이 아닌 정의한다고 표현한다.
- 함수 선언문으로 함수를 생성하면 함수 호이스팅이 일어나지만 함수 표현식으로 함수를 생성하면 변수 호이스팅이 발생한다.
  - 함수 선언문은 런타임 전에 생성과 동시에 암묵적으로 함수 이름을 식별자로 생성해 함수 객체를 할당하기 때문에 호이스팅이 일어난다.
  - 함수 표현식은 변수에 할당된 값이 함수 리터럴이다. 그렇기 때문에 일반적으로 변수에 값을 할당하는 것과 동일하게 동작한다.
- 함수의 인자를 정해진 매개변수보다 많이 전달하면 인자는 사라지는 것이 아니라 argument라는 객체에 보관된다.

22/03/16

- 함수의 매개변수로 원시 값, 객체 값을 인수로 전달하고 함수 내에서 전달받은 값 자체를 변경할 때 원시는 불변성을 띄지만, 객체는 가변적이기 때문에 값이 변한다.
- 함수를 즉시 실행하기 위해서는 그룹 연산자를 알맞게 사용해야한다.
  - 최소한 함수의 코드 블럭까지 그룹 연산자로 묶어주어야 한다.
- 재귀 함수는 꼭! 전달받는 인수를 활용해 끝나는 지점을 정해야 한다.
- 함수 내에 정의된 함수를 중첩 함수, 내부 함수라고 한다.
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 한다. 반대로 변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수라고 한다.
- 함수형 프로그래밍은 외부의 상태에 의존하지 않고 변경하지도 않는 순수 함수를 통해 최대한 오류를 피하고 프로그램의 안정성을 높이기 위한 프로그래밍 방법론이다.

22/03/17
